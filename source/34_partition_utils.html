    <h2 id="toc205"><a id="RefHeading18521713816058"></a><a id="bkmRefHeading18521713816058"></a><a id="toc204"></a><a id="bkmtoc204"></a><a id="RefHeading13041136957987"></a><a id="bkmRefHeading13041136957987"></a><a id="bkmRefHeading13041136957987"></a><a id="bkmbkmRefHeading13041136957987"></a>Инструменты дисковой разметки и форматирования</h2>
    <p class="Textbody">Как было сказано во вступительном очерке, далее речь пойдёт о прикручивании специальных систем размещёния данных к уже установленной системе. И любой из этих процессов в этом случае начинается с разметки разделов под них, а заканчивается созданием файловых систем (каковое далее для краткости буду называть форматированием, хотя в общем случае это не тождественные понятия). И потому начать разговор следует с обзора инструментария, для этих целей предназначенного.</p>
    <h3 id="toc206"><a id="RefHeading18541713816058"></a><a id="bkmRefHeading18541713816058"></a><a id="toc205"></a><a id="bkmtoc205"></a><a id="RefHeading6601136957987"></a><a id="bkmRefHeading6601136957987"></a><a id="bkmRefHeading6601136957987"></a><a id="bkmbkmRefHeading6601136957987"></a>Виды дисковой разметки</h3>
    <p class="Textbody">Некогда тема дисковых разделов подробно рассматривалась в любом руководстве по Linux и соплеменным системам, а также во множестве специальных документов, как в Сети, так и на бумаге. С этой процедуры начинало знакомство с Linux не одно поколение грядущих его применителей. А устрашающие к ней комментарии были непременным атрибутом «курса молодого линуксоида».</p>
    <p class="Textbody">«Потом пришли другие времена» — и необходимость в столь подробных описаниях отпала. Да и число актуальных схем дисковой разметки резко поуменьшилось, сведясь к двум с половиной вариантам:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">разметка в стиле msdos; </p>
      </li>
      <li>
        <p class="Textbody">разметка в стиле gpt; </p>
      </li>
      <li>
        <p class="Textbody">полварианта для любителей и ценителей — разметка в стиле bsd. </p>
      </li>
    </ol>
    <p class="Textbody">На полуварианте останавливаться не буду — те, кто держит на своей машине Linux параллельно с какой-либо BSD-системой, знают о нём не меньше меня. Тем более, что это, как и msdos, частный случай MBR-разметки, о которой сказать необходимо.</p>
    <p class="Textbody">Разметка в стиле msdos возникла вместе с первыми IBM PC и их BIOS, предусматривающим Главную Загрузочную Запись (MBR — Master Boot Record). Она целиком умещается в так называемый нулевой сектор носителя, объёмом 512 байт. И в его части, отведённой под таблицу разделов, предусмотрено место для четырёх записей — то есть Primary Partitions. Большее количество разделов можно создать по «матрёшечному» принципу, путём объявления одного из первичных разделов Extended Partition.</p>
    <p class="Textbody">Расширенный раздел выступает в качестве контейнера, в который последовательно, как в матрёшку, вкладываются один логический раздел и ещё один расширенный раздел. Последний, в свою очередь, выступает контейнером второго уровня, и может включать ещё один логический раздел и следующий по очереди расширенный, — и так до бесконечности. Правда, аналогия с матрёшкой - не совсем строгая, потому что для пользователя все эти вложенные разделы видятся как равноправные части «головного» Extended-раздела. Да и на счёт бесконечности — тоже несколько преувеличено: на самом деле существует практический лимит для восприятия логических разделов, определяемый числом 63.</p>
    <p class="Textbody">Разметка в стиле GPT (GUID Partition Table) — это новый формат таблицы разделов на носителях информации (традиционных винчестерах, SSD-накопителях, флэшках, SD-картах). Как явствует из названия, он основан на Globally Unique Identifier (GUID) — статистически уникальных 128-битных идентификаторах всего на свете, в том числе и носителей.</p>
    <p class="Textbody">Таблица разделов GUID (далее для краткости я буду называть её просто GPT) существенно больше, нежели MBR.. Она занимает первые 34 блока (с нулевого по 33-й). Из них нулевой блок занимает всё тот же MBR — точнее, его защищённая (или защищающая? — protected) копия, предназначенная для программ, не понимающих GPT. Благодаря ему, скажем, утилита fdisk опознаёт винчестер с GPT как единый раздел неизвестного типа, но на самом деле работать с ним не может.</p>
    <p class="Textbody">Следующий блок — это оглавление таблицы разделов, в котором предусмотрено место для 128 записей. Это, соответственно, максимальное число разделов при разметке в GPT-стиле. Наконец, остальные 32 блока предназначены для записи данных о разделах.</p>
    <p class="Textbody">Таблица разделов GUID существует в двух экземплярах: основной находится в первых 34 блоках носителя, а дублирующий (полная копия основного, за исключением MBR) — в последних. При повреждении основной GPT (фиксируемом несовпадением контрольной суммы, хранящейся в оглавлении) она автоматически восстанавливается из таблицы дублирующей.</p>
    <p class="Textbody">В Linux традиционно использовалась MBR-разметка в стиле msdos, и для последней предназначались соответствующие утилиты.</p>
    <p class="Textbody">Несколько лет назад казалось, что железный конь GPT уверенно идёт на смену крестьянской лошади MBR: инсталляторы ряда популярных дистрибутивов, на которые не будем указывать пальцем, стали предлагать разметку в GPT-стиле как альтернативу, а некоторые — даже и по умолчанию. Однако довольно быстро оказалось, что это не даёт применителю ничего полезного, а вот некоторые проблемы с загрузчиком и особенно его восстановлением при сбоях создаёт. И даже самые прогрессисты от дистроения откатились обратно, сохранив поддержку GPT лишь в качестве опции.</p>
    <p class="Textbody">Надо сказать, что Ubuntu и её последователи не поддавались модному влиянию, и в инсталляторах всего этого клана GPT-разметка не поддерживалась никогда, и не поддерживается по сию пору. Хотя с дисками, размеченными в GPT-стиле внешними программами все Ubuntu'иды работают вполне справно. Однако далее я буду говорить только про MBR-разметку — интересующимся прогрессом ради прогресса могу предложить почитать <a href="http://fossbook.info/partitions/1449»%20target=">вот это</a>.</p>
    <h3 id="toc207"><a id="RefHeading18561713816058"></a><a id="bkmRefHeading18561713816058"></a><a id="toc206"></a><a id="bkmtoc206"></a><a id="RefHeading6621136957987"></a><a id="bkmRefHeading6621136957987"></a><a id="bkmRefHeading6621136957987"></a><a id="bkmbkmRefHeading6621136957987"></a>CLI: инструменты разметки</h3>
    <p class="Textbody">В Linux для разметки диска в MBR-стиле из командной строки можно использовать:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">низкоуровневую утилиту командной строки sfdisk — инструмент очень гибкий, но сложный в обращении и требующий очень большой аккуратности — все изменения дисковой разметки совершаются там в реальном времени; </p>
      </li>
      <li>
        <p class="Textbody">интерактивную диалоговую программу fdisk — почти столь же гибкую, как и sfdisk, но более простую и, главное, более безопасную в обращении — изменения дисковой разметки происходят тут только после соответствующего подтверждения пользователем правильности своих действий; </p>
      </li>
      <li>
        <p class="Textbody">интерактивную меню-ориентированную программу cfdisk, которая считается ещё более простой в использовании, чем fdisk (для которого она служит фронт-эндом) и столь же безопасна с точки зрения сохранности данных; </p>
      </li>
    </ul>
    <p class="Textbody">Кроме этого, существует универсальная утилита parted, которая позволяет создавать не только дисковые разделы, но и файловые системы на них. В числе её функций также модифицирование существующих разделов — изменение размера, копирование и перемещёние. Однако платой за её универсализм является сложность использования без постоянной практики. А поскольку разметка диска — не то занятие, которому тпичный применитель Linux'а предаётся по три раза на дню, говорить о ней я не буду.</p>
    <h4 id="toc208"><a id="RefHeading18581713816058"></a><a id="bkmRefHeading18581713816058"></a><a id="toc207"></a><a id="bkmtoc207"></a><a id="RefHeading6641136957987"></a><a id="bkmRefHeading6641136957987"></a><a id="bkmRefHeading6641136957987"></a><a id="bkmbkmRefHeading6641136957987"></a>Утилита fdisk</h4>
    <p class="Textbody">Начнем с fdisk: именно им больше всего пугали в старые времена начинающих пользователей Linux, предлагая дружественные альтернативы типа Disk Druid. Однако при ближайшем рассмотрении выясняется, что ничего устрашающего в ней нет.</p>
    <p class="Textbody">Происхождение fdisk теряется во мраке веков, уходя во времена первых UNIX для PC-архитектуры — насколько я понимаю, раньше необходимости в ней не было, а главными инструментами дисковой разметки были утилиты типа disklabel или bsdlabel. Мне не удалось также выяснить, когда эта утилита появилась в Linux. Могу только предполагать, что на самых ранних стадиях создания утилит обрамления для его ядра — т.н. linux-utils.</p>
    <p class="Textbody">Для начала следует запомнить, что запуск команды fdisk в любом качестве, даже просто для получения информации о диске, возможно только с правами суперпользователя, каковые и надо обеспечить себе обычным для Mint образом, то есть через sudo.</p>
    <p class="Textbody">Если команду fdisk дать без опций и аргументов, она выведет краткую справку об её использовании:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ sudo fdisk</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Usage: fdisk (-l) (-b SSZ) (-u) device</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">E.g.: fdisk /dev/hda  (for the first IDE disk)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  or: fdisk /dev/sdc  (for the third SCSI disk)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  or: fdisk /dev/eda  (for the first PS/2 ESDI drive)</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">  or: fdisk /dev/rd/c0d0  or: fdisk /dev/ida/c0d0  (for RAID devices)</span> </p>
    <p class="Textbody">В качестве аргумента команды фигурирует имя файла устройства — физического диска целиком. Поскольку в современных версиях ядра Linux все диски, вне зависимости от их интерфейсов (PATA, SATA, SCSI, SAS, USB) определяются единой подсистемой ATA-SCSI, на самом деле имена эти будут иметь вид /dev/sda, /dev/sdb и так далее.</p>
    <p class="Textbody">Смысл опций команды fdisk следующий:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">l не предписывает выполнения каких-либо действий, а лишь выводит информацию о диске и его разделах, если таковые имеются; </p>
      </li>
      <li>
        <p class="Textbody">b задаёт размер блока — единицы измерения дискового пространства; по умолчанию, без указание этой опции, он равен физическому блоку (512 байт), прочие возможные значения кратны его размеру — 1024, 2048 или 4096 байт; </p>
      </li>
      <li>
        <p class="Textbody">u запускает fdisk, являясь опцией по умолчанию. </p>
      </li>
    </ul>
    <p class="Textbody">Перво-наперво посмотрим на информационную функцию fdisk, для чего запустим её следующим образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo  fdisk -l /dev/sdd</span> </p>
    <p class="Textbody">Ответом будет вывод примерно такого вида:</p>
    <p class="Textbody"><span style="background-color:#dddddd">Диск /dev/sdd: 500.1 Гб, 500107862016 байт</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">255 головок, 63 секторов/треков, 60801 цилиндров, всего 976773168 секторов</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Units = секторы of 1 * 512 = 512 bytes</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Размер сектора (логического/физического): 512 байт / 512 байт</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">I/O size (minimum/optimal): 512 bytes / 512 bytes</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Идентификатор диска: 0x000b24d0</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Устр-во Загр     Начало       Конец       Блоки   Id  Система</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/dev/sdd1            2048   629147647   314572800    5  Расширенный</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/dev/sdd2       629149696   746337195    58593750   83  Linux</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/dev/sdd3       746337196   863525803    58594304   83  Linux</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/dev/sdd4       863525804   976773167    56623682   83  Linux</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/dev/sdd5            2111    62504095    31250992+  82  Linux своп / Solaris</span> </p>
    <p class="Textbody">Если опустить аргумент команды, то аналогичные сведения будут выведены для всех физических дисков данной машины: сначала — общая информация о диске, включающая его размер, число головок, секторов и цилиндров, а затем для каждого существующего на диске раздела указываются его первый и последний цилиндры (символом + маркируются разделы, не занимающие последний цилиндр полностью), размер в блоках (физических или заданных опцией b), идентификатор типа файловой системы и его название.</p>
    <p class="Textbody">Для каких-либо манипуляций с дисковыми разделами команду fdisk следует запустить в интерактивном режиме:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># fdisk /dev/sdd</span> </p>
    <p class="Textbody">Что можно сделать без всяких опций, но вот указание аргумента тут будет обязательным.</p>
    <p class="Textbody">После этого мы получаем в свое распоряжение некий интерфейс, требующий ввода определенной команды, исполнение которой сводится к ответу на несколько вопросов. С полным списком доступных команд можно ознакомиться благодаря прекрасной системе помощи, вызываемой командой m.</p>
    <p class="Textbody">Так, команда p выведет текущий список дисковых разделов с указанием их типа и размера. Далее, разделы можно создавать (командой n) или удалять (командой d), однако до команды записи изменений (w) никаких необратимых действий, могущих разрушить ранее существовавшую разметку (и, соответственно, файловые системы и данные, к ней привязанные), не последует: неудачно созданные разделы можно удалить и на их месте создать новые. И в любой момент командой q можно без всяких последствий выйти из программы.</p>
    <p class="Textbody">При создании раздела средствами fdisk сначала определяется, будет он первичным (primary) или расширенным (extended). Рассмотрим сначала первый случай. При нем далее просто указывается номер раздела (от 1 до 4). В этих пределах номер может быть любым — можно сначала создать раздел 2, а потом 1, или даже весь диск отвести под раздел 4. Номер раздела останется на века: именно он будет идентифицировать файл устройства, соответствующий созданному разделу (например, /dev/sda2, или /dev/sdb1).</p>
    <p class="Textbody">Далее задается начальный цилиндр создаваемого раздела (по умолчанию - первый свободный, для пустого диска — просто первый). Однако никто не мешает указать любой другой цилиндр в качестве стартового (на неразбитом пространстве, разумеется). А потом — конечный цилиндр (по умолчанию — последний физический на неразбитом дисковом пространстве), или просто размер раздела в каких-либо общепринятых единицах измерения информации, например, +300M; и +, и M (или что-либо аналогичное) — обязательны, иначе объём диска окажется равных ровно трёхстам цилиндрам.</p>
    <p class="Textbody">В современных версиях  fdisk возможно указание объёма в двух системах единиц (не считая цилиндров). Во-первых, он может задаваться в том, что мы испокон веков привыкли называть мегабайтами и гигабайтами, то есть степенях двойки. Однако ныне авторитетные товарищи утверждают, что такие единицы измерения должны величаться мебибайтами, гибибайтами и так далее. Их следует указывать так: +1000MB, +10GB и так далее.</p>
    <p class="Textbody">А можно определять объём раздела и в «настоящих», с точки зрения пуристов от метрологии, мегабайтах и гигабайтах, представляющих собой  собой степени десятки — тех, в которых производители жёстких дисков издревле указывают размеры своей продукции. И тогда он определяется таким образом: +1000M, +10G etc.</p>
    <p class="Textbody">При задании размера в единицах, отличных от цилиндров, он всегда будет округляться (по обычным правилам округления) до ближайшего числа, кратного целому количеству последних. Так что не следует удивляться, если вместо искомого раздела в 20 Мбайт возникнет 16-мегабайтный, а вместо 22-мегабайтного — раздел в 24 Мбайт.</p>
    <p class="Textbody">При создании расширенного раздела сначала все происходит точно также — задание номера (очевидно, что в том же диапазоне 1--4), указание начального цилиндра и конечного (или — объёма в мегабайтах). Однако это ещё полдела, нужно поделить расширенный раздел на разделы логические. И потому при следующей команде на создание раздела нам будет предложен уже выбор между первичным (если число последних ещё не исчерпано) и логическим (ведь второй extended-раздел средствами fdisk создать нельзя):</p>
    <p class="Textbody"><span style="background-color:#dddddd">Command (m for help): n</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Command action</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">   l   logical (5 or over)</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">   p   primary partition (1-4)</span> </p>
    <p class="Textbody">Дальше же логический раздел создается аналогично первичному.</p>
    <p class="Textbody">Для каждого вновь создаваемого средствами fdisk раздела (первичного или логического) по умолчанию устанавливается идентификатор типа файловой системы Linux native (83 в шестнадцатеричном исчислении). Расширенный же раздел также автоматически получает правильный идентификатор своего типа — 5. Однако типы эти не есть нечто неизменное. Более того, по крайней мере в одном случае, при создании раздела подкачки, изменение типа раздела — необходимость. Это потребуется также и для использования таких технологий, как Software RAID или LVM, о которых будет говориться позднее.</p>
    <p class="Textbody">Делается это командой t, после чего запрашивается номер раздела, тип которого должен быть изменен, а затем — идентификатор желаемого типа. Полный список поддерживаемых типов файловых систем (и их идентификаторов) можно вывести командой l. Напомню, что идентификатор типа файловой системы раздела — отнюдь не файловая система, которая на нем размещается. И на разделе Linux native, как это подчеркивает название, можно создать любую файловую систему из числа тех, которые поддерживаются Linux в качестве родных (ext2/ext3, ext4, XFS, ReiserFS, JFS, btrfs, NILFS2).</p>
    <p class="Textbody">Теоретически fdisk позволяет присвоить созданному разделу идентификатор типа почти любой из мыслимых файловых систем — от FAT12 до Free-, Open- и NetBSD. Однако сами по себе файловые системы средствами fdisk не создаются, и потому для разделов любого типа в дальнейшем потребуется их форматирование специальными командами типа mkfs, о которых будет говориться в соответствующей рубрике.</p>
    <p class="Textbody">Сказанного, надеюсь, достаточно, чтобы осознать великое достоинство fdisk — исключительную гибкость: можно определить раздел строго определенного размера и точно позиционировать его на диске. Или зарезервировать в любом месте накопителя неразбитое пространство, с двух сторон окруженное созданными разделами.</p>
    <p class="Textbody">Сложность же применения fdisk — кажущаяся: благодаря системе подсказки дисковые разделы создаются легко и непринуждённо. Тем не менее, если таки она удручает своей недостаточной наглядностью, можно воспользоваться утилитой cfdisk с меню-ориентированным интерфейсом.</p>
    <h4 id="toc209"><a id="RefHeading18601713816058"></a><a id="bkmRefHeading18601713816058"></a><a id="toc208"></a><a id="bkmtoc208"></a><a id="RefHeading6661136957987"></a><a id="bkmRefHeading6661136957987"></a><a id="bkmRefHeading6661136957987"></a><a id="bkmbkmRefHeading6661136957987"></a>Утилита cfdisk</h4>
    <p class="Textbody">Как уже говорилось, утилита fdisk часто оказывает устрашающее действие на начинающих пользователей. И потому, идя навстречу их невысказанным пожеланиям, Кевин Мартин (Kevin E. Martin) написал к ней консольный фронт-энд с меню-ориентированным интерфейсом, получивший имя cfdisk.</p>
    <p class="Textbody">Утилита cfdisk описывается в литературе гораздо реже, хотя традиционно она считается более удобной, чем fdisk — впрочем, это субъективно и зависит от привычки.</p>
    <p class="Textbody">Запустить cfdisk можно одноименной командой, с указанием имени дискового устройства в качестве аргумента:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># cfdisk /dev/sdb</span> </p>
    <p class="Textbody">Если аргумент в командной строке опущен — по умолчанию команда будет исполнена для первого физического диска машины.</p>
    <p class="Textbody">Разумеется, для использования утилиты требуются права администратора. Если попытаться запустить её от лица обычного пользователя — программа стартует с сообщением. А после запуска программы (в консоли или окне терминала) мы видим следующую картину:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_193.png">
        <img alt="Изображение540" class="frameGraphics" id="540graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_193-572x376.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:377.83057px" />
      </a>
      <a id="a542graphic"></a>
      <a id="bkm542graphic"></a>
    </p>
    <p class="Textbody">На ней выводится информация о диске, первом физическом или том, что был указан в качестве аргумента (имя файла устройства, размер, число головок, секторов, цилиндров), таблица существующих разделов (если, кончено, они действительно существуют) и меню из следующих пунктов: Bootable, Delete, Help, Maximize, Print, Quit, Type, Units, Write. Это — для диска с существующими разделами. Если же диск не разбит (или в таблице разделов курсор зафиксирован на неразбитом пространстве), меню ограничивается пунктами Help, New, Print, Quit, Units, Write.</p>
    <p class="Textbody">Смысл пунктов, думаю, понятен из их названий, как и возможности программы вообще. Замечу лишь, что здесь, как и в fdisk, до выбора пункта Write (в котором будет запрошено подтверждение действия) никаких необратимых изменений не происходит: через Quit всегда можно покинуть программу без боязни за существующие разделы и данные на них.</p>
    <p class="Textbody">И ещё: по умолчанию размеры разделов в таблице указаны в тех мегабайтах, к которым мы привыкли — 220 байт, которые, как нынче считается, положено называть мебибайтами. Однако через пункт Units (сиречь единицы измерения) можно переключиться на показ его в секторах или цилиндрах. Для создания раздела выбирается пункт New, выводящий подменю: Primary, Logical, Cancel.</p>
    <p class="Textbody">После выбора типа раздела просто задается желаемый его размер (в мегабайтах) и запрашивается, приписать ли раздел к началу диска или его концу. А потом остается только сохранить разбиение в таблице разделов выбором пункта Write (повторяю, с запросом подтверждения, и не просто как y, а вводом полного слова yes — дабы дать дополнительные мгновения на раздумье).</p>
    <p class="Textbody">Таким образом, все происходит почти также, как в fdisk. Это и не удивительно: cfdisk по сути лишь интерфейсная для fdisk оболочка. Хотя cfdisk несколько менее гибок: например, раздел в середине неразбитого дискового пространства создать нельзя.</p>
    <h4 id="toc210"><a id="RefHeading18621713816058"></a><a id="bkmRefHeading18621713816058"></a><a id="toc209"></a><a id="bkmtoc209"></a><a id="RefHeading6681136957987"></a><a id="bkmRefHeading6681136957987"></a><a id="bkmRefHeading6681136957987"></a><a id="bkmbkmRefHeading6681136957987"></a>Утилиты форматирования</h4>
    <p class="Textbody">Утилит для форматирования в Linux существует столько же, сколько и поддерживаемых её ядром файловых систем: чтобы убедиться в этом, достаточно набрать в командной строке mkfs и нажать Enter, что даст примерно такую картину:</p>
    <p class="Textbody"><span style="background-color:#dddddd">mkfs           mkfs.ext2      mkfs.ext4dev   mkfs.minix     mkfs.reiserfs</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">mkfs.bfs       mkfs.ext3      mkfs.fat       mkfs.msdos     mkfs.vfat</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">mkfs.cramfs    mkfs.ext4      mkfs.jfs       mkfs.ntfs      mkfs.xfs</span> </p>
    <p class="Textbody">И это — оглашение не всего списка: его легко поплнить установкой пакетов поддержки таких файловых систем, как nilfs, f2fs и других, о которых я и не слыхал.</p>
    <p class="Textbody">Зато из данного списка становится очевидным, как выполнять форматирование: достаточно дать команду на создание желаемой файловой системы и имя файла устройства (то есть дискового раздела) в качестве её аргумента, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo mkfs.ext4 /dev/sdg1</span> </p>
    <p class="Textbody">Как легко догадаться, конечно же, команда даётся от имени root'а. А результатом её работы будет создание на указанном разделе файловой системы ext4fs.</p>
    <p class="Textbody">Можно ограничиться и универсальной командой mkfs — но в этом случае, кроме аргумента, потребуется ещё и опция -t с явным указанием файловой системы. Прочие опции всего семейства команд mkfs специфичны для отдельных файловых систем, и говорить о них тут не будем. Как воздержимся и от обсуждения вопроса, какая из файловых систем — самая рассмая и гарантирующая своему применителю счастие немыслимое.</p>
    <h3 id="toc211"><a id="RefHeading18641713816058"></a><a id="bkmRefHeading18641713816058"></a><a id="toc210"></a><a id="bkmtoc210"></a><a id="RefHeading6701136957987"></a><a id="bkmRefHeading6701136957987"></a><a id="bkmRefHeading6701136957987"></a><a id="bkmbkmRefHeading6701136957987"></a>Про графические морды и особенно про GNOME Disks</h3>
    <p class="Textbody">Как уже говорилось, средств для управления носителями и разделами для них в Linux'ах немало. И если большинство применителей «со стажем» используют в этих целях набор специализированных утилит командной строки, то применители начинающие отдают предпочтение графическим фронт-эндам, интегрирующим функционал всех перечисленных инструментов. Впрочем, последними не брезгуют и те из опытных применителей, кто не одержим фанатизмом и уже переболел детской болезнью крутизны. Среди таких фронт-эндов наибольшую известность и распространение получила программа GParted. Она же применятся обычно во всякого рода Live-дистрибутивах ремонтно-спасательной ориентации, вроде Parted Magic и GParted Live.</p>
    <p class="Textbody">Автор этих строк тоже не пренебрегал программой GParted, когда ему требовалось разметить какой-либо носитель на скорую руку (или когда просто лениво было обращаться к инструментам CLI). Однажды, уже в бытность применителем Mint, такая потребность возникла у него в очередной раз. И потому он собрался обратиться к <span style="text-decoration:line-through">знакомым пистолетам</span> знакомому и привычному фронт-энду. Однако следствие показало, что в Mint 17 таковой в штатном комплекте отсутствует. А вместо него предлагается некий gnome-disks, фигурирующий в разделе Стандартные главного меню Cinnamon'а под простым именем — Диски. Хотя доустановить GParted из репозитория труда бы не составило, я решил опробовать этот инструмент. Ибо до сих пор только слыхал о нём — и не лучшие отзывы. В частности, что в последних его версиях отказались от поддержки softRAID, мотивируя обычным для GNOMEделателей аргументом: Народу это не нужно.</p>
    <p class="Textbody">Забегая вперёд, скажу, что опасения по части softRAID оказались не напрасными: в том варианте, в котором gnome-disks присутствует в Mint'е, он позволяет создавать разделы с данным идентификатором — и ничего более. Для дальнейших действий приходится всё равно обращаться к утилите mdadm, но это будет следующим номером нашей программы.</p>
    <p class="Textbody">Однако начну по порядку. Запустить gnome-disks можно или через CLI, одноимённой командой, или из меню. Обращаю внимание — в отличие от GParted, пароль пользователя в момент запуска не запрашивается: его спросят только перед выполнением действий, которые на самом деле требуют привилегий администратора.</p>
    <p class="Textbody">Будучи запущенным на моём десктопе, gnome-disks показывает следующую картину:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_194.png">
        <img alt="Изображение541" class="frameGraphics" id="541graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_194-572x433.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:434.82584px" />
      </a>
      <a id="a543graphic"></a>
      <a id="bkm543graphic"></a>
    </p>
    <p class="Textbody">Что соответствует реалиям моей дисковой подсистемы, в детали описания которой я сейчас вдаваться не буду — задача, как уже было сказано, передо мной стояла очень частная. Отмечу только, что, вопреки опасениям, мой программный RAID был распознан, и для него были доступны некоторые манипуляции, типа добавления или удаления разделов. Чего я, по понятным причинам, не делал. Но пару слов о возможностях программы вообще скажу.</p>
    <p class="Textbody">Шестерёнка в правом верхнем углу — вызов главного меню gnome-disks, которое выглядит так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_195.png">
        <img alt="Изображение542" class="frameGraphics" id="542graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_195.png" style="border:1.0px solid #000080;padding:0;width:481.84317px;height:274.8384px" />
      </a>
      <a id="a544graphic"></a>
      <a id="bkm544graphic"></a>
    </p>
    <p class="Textbody">Пара сцепленных шестерёнок ниже графика распределения диска по разделам вызывает очень похожее, хотя и не идентичное, меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_196.png">
        <img alt="Изображение543" class="frameGraphics" id="543graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_196.png" style="border:1.0px solid #000080;padding:0;width:425.83057px;height:301.82425px" />
      </a>
      <a id="a545graphic"></a>
      <a id="bkm545graphic"></a>
    </p>
    <p class="Textbody">Смысл всех пунктов обоих меню интуитивно понятен. Следует только учесть, что пункты «верхнего» меню соответствуют манипуляциям над дисками в целом, «нижнего» — над его разделами. Этим и объясняются некоторые различия в этих меню: очевидно, что SMART не имеет смысла для раздела, а изменение параметров монтирования — для диска в целом. Кроме того, пункты, именованные в обоих меню одинаково, выполняют разные действия. Так, Форматирование из «верхнего» меню — ни что иное, как создание таблицы разметки диска (варианты — в стиле MSDOS или GPT):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_197.png">
        <img alt="Изображение544" class="frameGraphics" id="544graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_197-572x167.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:168.8227px" />
      </a>
      <a id="a546graphic"></a>
      <a id="bkm546graphic"></a>
    </p>
    <p class="Textbody">А одноимённый пункт из меню «нижнего» — это действительно создание файловой системы на разделе:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_198.png">
        <img alt="Изображение545" class="frameGraphics" id="545graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_198-572x261.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:262.85733px" />
      </a>
      <a id="a547graphic"></a>
      <a id="bkm547graphic"></a>
    </p>
    <p class="Textbody">Причём через меню предусмотрен выбор только между FAT, NTFS и Ext4 (в том числе с шифрованием):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_199.png">
        <img alt="Изображение546" class="frameGraphics" id="546graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_199-572x261.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:262.85733px" />
      </a>
      <a id="a548graphic"></a>
      <a id="bkm548graphic"></a>
    </p>
    <p class="Textbody">Названия прочих файловых систем следует, выбрав строку <span style="font-weight:bold">Другой</span>, ввести вручную (например, btrfs). Список поддерживаемых файловых систем зависит от установленного в системе инструментария для работы с ними. Например, чтобы отформатировать раздел в JFS, необходимо иметь в установленном виде пакет jfsutils.</p>
    <p class="Textbody">Кстати, поле с именем Название — ни что иное, как метка диска.</p>
    <p class="Textbody">Думаю, понятно, что оба «форматирования» возможны только на отмонтированных носителях и требуют прав администратора. Причём пароль на доступ к оным запрашивается в самый последний момент, после всех подтверждений серьёзности своих намерений.</p>
    <p class="Textbody">Перед этим неплохо бы рассмотреть параметры приводов. В зависимости от типа накопителей, они оказались разными. Так, для SSD информационная панель включала две вкладки — управления питанием</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_200.png">
        <img alt="Изображение547" class="frameGraphics" id="547graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_200-572x274.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:275.85892px" />
      </a>
      <a id="a549graphic"></a>
      <a id="bkm549graphic"></a>
    </p>
    <p class="Textbody">и включения кеша записи:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_201.png">
        <img alt="Изображение548" class="frameGraphics" id="548graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_201-572x274.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:275.85892px" />
      </a>
      <a id="a550graphic"></a>
      <a id="bkm550graphic"></a>
    </p>
    <p class="Textbody">Обе функции по умолчанию отключены. Оно и понятно — для десктопа управление питанием не требуется. А с включением кеширования я решил пока не экспериментировать — ведь речь шла не о тестировании нового накопителя, а о практической работе на реальной машине.</p>
    <p class="Textbody">Для традиционного винчестера на 500 ГБ параметры выглядели так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_202.png">
        <img alt="Изображение549" class="frameGraphics" id="549graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_202-572x294.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:295.85257px" />
      </a>
      <a id="a551graphic"></a>
      <a id="bkm551graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_203.png">
        <img alt="Изображение550" class="frameGraphics" id="550graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_203-572x294.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:295.85257px" />
      </a>
      <a id="a552graphic"></a>
      <a id="bkm552graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_204.png">
        <img alt="Изображение551" class="frameGraphics" id="551graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_204-572x294.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:295.85257px" />
      </a>
      <a id="a553graphic"></a>
      <a id="bkm553graphic"></a>
    </p>
    <p class="Textbody">Вволю поигравшись с функциями gnome-disks и сделав зарубки на счёт того, какие из них мне могут понадобиться в дальнейшем, я приступил к выполнению поставленной боевой задачи — переразметке экспериментального диска /dev/sdc. Каковой выглядел следующим образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_205.png">
        <img alt="Изображение552" class="frameGraphics" id="552graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_205-572x520.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:521.83057px" />
      </a>
      <a id="a554graphic"></a>
      <a id="bkm554graphic"></a>
    </p>
    <p class="Textbody">Так что первой задачей было удаление некоего «отсебятного» раздела. Для чего, как подсказала мне солдатская смекалка, требовалось нажать кнопку с минусом рядом с кнопкой вызова «нижнего» меню. Что, как и ожидалось, привело к следующему результату:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_206.png">
        <img alt="Изображение553" class="frameGraphics" id="553graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_206-572x520.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:521.83057px" />
      </a>
      <a id="a555graphic"></a>
      <a id="bkm555graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_206.png"> </a>
    </p>
    <p class="Textbody">Та же солдатская смекалка говорила, что нажатие кнопки с плюсиком приведёт к созданию на пространстве, ставшем неразмеченным, нового раздела, который оставалось только определить как расширенный:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_207.png">
        <img alt="Изображение554" class="frameGraphics" id="554graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_207-572x315.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:316.82898px" />
      </a>
      <a id="a556graphic"></a>
      <a id="bkm556graphic"></a>
    </p>
    <p class="Textbody">В результате чего разметка устройства /dev/sdc приобрела такой вид:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_208.png">
        <img alt="Изображение555" class="frameGraphics" id="555graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_208-572x520.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:521.83057px" />
      </a>
      <a id="a557graphic"></a>
      <a id="bkm557graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_208.png"> </a>
    </p>
    <p class="Textbody">Наличные примерно 300 ГБ расширенного раздела я планировал разметить на 5 примерно равных по объёму разделов логических. Что, с помощью той же самой кнопки Плюс, и проделал для первого, предназначенного в будущем для openSUSE Factory, задав ему для определённости соответствующую метку:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_209.png">
        <img alt="Изображение556" class="frameGraphics" id="556graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_209-572x315.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:316.82898px" />
      </a>
      <a id="a558graphic"></a>
      <a id="bkm558graphic"></a>
    </p>
    <p class="Textbody">Далее оставалось проделать ту же процедуру для остальных четырёх логических томов, после чего получилась следующая картина:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_210.png">
        <img alt="Изображение557" class="frameGraphics" id="557graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_210-572x520.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:521.83057px" />
      </a>
      <a id="a559graphic"></a>
      <a id="bkm559graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_210.png"> </a>
    </p>
    <p class="Textbody">Выбором файловых систем я не заморачивался — он будет сделан при инсталляции целевого дистрибутива. А метки для разделов я присвоил или в соответствие с названиями предполагаемых на них систем, либо просто по именам устройств. Для уже созданных (но не смонтированных) разделов (точнее — файловых систем, ибо label — это её аттрибут) метку можно задать через пункт Изменить файловую систему «нижнего» меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_211.png">
        <img alt="Изображение558" class="frameGraphics" id="558graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_211.png" style="border:1.0px solid #000080;padding:0;width:274.8384px;height:149.84946px" />
      </a>
      <a id="a560graphic"></a>
      <a id="bkm560graphic"></a>
    </p>
    <p class="Textbody">К слову сказать, через предыдущий пункт того же меню, Изменить раздел, можно задать индентификатор его типа:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_212.png">
        <img alt="Изображение559" class="frameGraphics" id="559graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_212.png" style="border:1.0px solid #000080;padding:0;width:361.84317px;height:183.82741px" />
      </a>
      <a id="a561graphic"></a>
      <a id="bkm561graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_212.png"> </a>
    </p>
    <p class="Textbody">Каковых имеется более чем вдоволь:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_213.png">
        <img alt="Изображение560" class="frameGraphics" id="560graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_213-159x572.png" style="border:1.0px solid #000080;padding:0;width:160.84789px;height:573.83685px" />
      </a>
      <a id="a562graphic"></a>
      <a id="bkm562graphic"></a>
    </p>
    <p class="Textbody">Впрочем, из этого изобилия практически значимы лишь менее полудюжины. Да и делать это для разделов, несущих файловые системы, тем более с данными, не очень рекомендуется. Конечно, изменение идентификатора типа к разрушению файловой системы и потере данных не приведёт, проверено на опыте. Но как будут восприниматься идентификаторы, отличные от Linux'ового 0x83 всякими программами работы с дисками — ведомо только Ахурамазде. А самое главное — это нафиг не нужное занятие.</p>
    <p class="Textbody">Подведу итоги. Сравнивать GParted напрямую с gnome-disks не возьмусь. Но одно преимущество последней утилиты лежит на поверхности: если GParted запрашивает пароль на доступ к административным правам сразу при запуске, то gnome-disks — только непосредственно перед выполнением операций, для которых они на самом деле требуются. Так, просто поглядеть на схему разметки, параметры носителя и его состояние можно в режиме обычного пользователя. Конечно, это не гарантирует от ошибок, которые в деле разметки дисков могут быть критическими, но несколько снижает их вероятность.</p>
    <p class="Textbody">А в целом функционал gnome-disks показался мне вполне достаточным для выполнения всех повседневных практических задач в области работы с дисками, разделами и файловыми системами. И в большинстве обыденных случаев он вполне может заменить комплекс утилит CLI, включая и команду dd для создания образов дисков (кстати, GParted, кажется, делать этого не умеет).  Если, конечно, не требуются какие-то специфические параметры разметки или монтирования — тут специализированные утилиты командной строки вне конкуренции.</p>
