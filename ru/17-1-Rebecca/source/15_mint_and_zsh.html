    <h2 id="toc105"><a id="RefHeading16521713816058"></a><a id="bkmRefHeading16521713816058"></a><a id="toc104"></a><a id="bkmtoc104"></a><a id="RefHeading12661136957987"></a><a id="bkmRefHeading12661136957987"></a><a id="bkmRefHeading12661136957987"></a><a id="bkmbkmRefHeading12661136957987"></a>Mint и Zsh</h2>
    <p class="Textbody">В предыдущем очерке работа в CLI была рассмотрена на примере Bash — самой распространённой командной оболочки Linux'а. Однако о ней написаны пуды бумажной литературы и мегабайты сетевых материалов, повторять которые было бы скучно. И к тому же в реальной жизни я её практически не использую. Поэтому далее будет рассмотрена оболочка Zsh.</p>
    <p class="Textbody">Кроме борьбы со скукой, есть и немало более технических аргументов в пользу применения Zsh как пользовательской оболочки (login shell):</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">функциональность, существенно превосходящая возможности Bash в интерактивной работе; </p>
      </li>
      <li>
        <p class="Textbody">расширяемость за счёт дополнительных модулей; </p>
      </li>
      <li>
        <p class="Textbody">настраиваемость, ограниченная практически только фантазией применителя; </p>
      </li>
      <li>
        <p class="Textbody">прекрасная документированность — объём официальной документации составляет более 3 МБ в формате HTML (не считая прочих форматов); </p>
      </li>
      <li>
        <p class="Textbody">активное сообщество энтузиастов — разработчиков и применителей. </p>
      </li>
    </ul>
    <p class="Textbody">Не последним аргументом в пользу Zsh является его отличная интеграция с утилитой apt, лежащей в основе пакетного менеджмента дистрибутива Mint. До сих пор, описывая действия по управлению пакетами в CLI, я, будучи давним пользователем Zsh, приводил их к общему знаменателю с Bash. В один прекрасный момент мне это надоело. Причём отказываться от мощного функционала Zsh, к которому привык так, что без него как без рук, не не собираюсь. И потому решил впредь помещать в тексты своих сочинений команды в «Zsh'изированной» форме. А для пояснения их сути — написать настоящуюю серию мини-очерков и включить её в книгу про Mint.</p>
    <h3 id="toc106"><a id="RefHeading16541713816058"></a><a id="bkmRefHeading16541713816058"></a><a id="toc105"></a><a id="bkmtoc105"></a><a id="RefHeading4981136957987"></a><a id="bkmRefHeading4981136957987"></a><a id="bkmRefHeading4981136957987"></a><a id="bkmbkmRefHeading4981136957987"></a>Zsh как login shell</h3>
    <p class="Textbody">В Mint в качестве системной командной оболочки, то есть интерпретатора общесистемных сценариев, выступает Dash (Debian-клон оболочки Альмквиста, ash), лёгкая и компактная, но имеющая слабые возможности для интерактивной работы. Для последней, как и в подавляющем большинстве дистрибутивов Linux, используется Bash, которая является пользовательской оболочкой (login shell) по умолчанию. Что же до Zsh, она отсутствует в стандартной инсталляции Mint, но доступна в официальном репозитории, из которого легко может быть установлена.</p>
    <p class="Textbody">Начинающему применителю Mint проще всего установить Zsh с помощью описанного ранее менеджера пакетов. Для чего сначала надо отыскать соответствующий пакет:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_001.png">
        <img alt="Изображение237" class="frameGraphics" id="237graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_001-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a237graphic"></a>
      <a id="bkm237graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_001.png"> </a>
    </p>
    <p class="Textbody">После чего поглядеть на его описание и установить:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_002.png">
        <img alt="Изображение238" class="frameGraphics" id="238graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_002-572x530.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:531.8463px" />
      </a>
      <a id="a238graphic"></a>
      <a id="bkm238graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_002.png"> </a>
    </p>
    <p class="Textbody">Однако просто иметь Zsh мало — его надо сделать регистрационной оболочкой (login shell) в своём аккаунте. Как ни странно, в обоих графических модулях Системных настроек Cinnamon такой возможности нет. Однако можно прибегнуть к графической утилите usermode, предварительно установив её через Менеджер приложений и запустив из главного меню, где она скрывается в секции Параметры под именем О себе и после запуска выглядит таким образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_003.png">
        <img alt="Изображение239" class="frameGraphics" id="239graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_003.png" style="border:1.0px solid #000080;padding:0;width:341.84946px;height:252.84157px" />
      </a>
      <a id="a239graphic"></a>
      <a id="bkm239graphic"></a>
    </p>
    <p class="Textbody">После установки Zsh её можно будет выбрать из выпадающего списка в поле Оболочка:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_004.png">
        <img alt="Изображение240" class="frameGraphics" id="240graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_004.png" style="border:1.0px solid #000080;padding:0;width:380.8542px;height:376.8479px" />
      </a>
      <a id="a240graphic"></a>
      <a id="bkm240graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_004.png"> </a>
    </p>
    <p class="Textbody">Кажется, это единственное, что может сделать полезного данная утилита. Поэтому возникает вопрос — а стоит ли устанавливать её ради разовой операции? Может быть, лучше прибегнуть к самому простому способу смены login shell — прямой команде? Тот этой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chsh -s /bin/zsh</span> </p>
    <p class="Textbody">Вопрос, как вы понимаете, риторический…</p>
    <p class="Textbody">Каким бы образом ни была назначена Zsh <span style="text-decoration:line-through">любимой женой</span> пользовательской командной оболочкой, следующая авторизация данного пользователя в «голой» консоли однозначно её запустит. В эмуляторах же терминала, возможно, потребуется внести некоторые изменения в их настройках, например, предписать запуск /bin/zsh явным образом, или отметить опцию запуска оболочки как login shell.</p>
    <p class="Textbody">В любом случае первый запуск сеанса пользователя с новой оболочкой предложит такие варианты выбора:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">q — выход из программы автоконфигурирования без последствий; при следующем входе в оболочку вызов её будет повторён; </p>
      </li>
      <li>
        <p class="Textbody">0 — выход из автоконфигурирования с созданием пустого конфига ~/.zshrc, предотвращающем в дальнейшем повторения автоконфигурирования; </p>
      </li>
      <li>
        <p class="Textbody">1 — вызов главного меню; </p>
      </li>
      <li>
        <p class="Textbody">2 — создание конфига ~/.zshrc по образу и подобию эталонного, /etc/zsh/newuser.zshrc.recommended, который в дальнейшем может редактироваться вручную. </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_005.png">
        <img alt="Изображение241" class="frameGraphics" id="241graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_005-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a241graphic"></a>
      <a id="bkm241graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_005.png"> </a>
    </p>
    <p class="Textbody">С вариантом q всё ясно, это просто откладывание вопроса на потом, вариант 1, с автоконфигурированием, был некогда <a href="http://fossbook.info/subproj/shell/1120" target="_blank">описан достаточно подробно</a>, и с тех пор процесс этот ничуть не изменился, вариант же 2 зависит от настроек общего конфига оболочки, принятых майнтайнерами данного дистрибутива. Так что я хотел бы сконцентрировать внимание на «нулевом» варианте. И последовательно рассмотреть все настройки, которые потребуется выполнить применителю для создания комфортной среды CLI. Не абстрактно, разумеется, а применительно к целям и задачам себя, любимого. Так что читатель должен воспринимать всё сказанное в этих очерках далее, не как догму, а как руководство к действиям, то есть экспериментам, и к размышлениям о своих потребностях.</p>
    <p class="Textbody">Однако прежде отмечу, что применителю не обязательно сразу определять Zsh как login shell. Он может вызвать её из командной строки Bash:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /bin/zsh</span> </p>
    <p class="Textbody">Запуск Zsh ознаменуется сменой вида приглашения командной строки с Bash'евской, которая в Mint'е по умолчанию выглядит так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zshuser@alv-cinn ~ $</span> </p>
    <p class="Textbody">на умолчальную Zsh'еву:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alv-cinn%</span> </p>
    <p class="Textbody">Вот с настройки вида приглашения командной строки я и начну. Добавив только, что после каждого изменения в конфиге ~/.zshrc для вступления его в силу вовсе не обязательно завершать сеанс и авторизоваться заново — достаточно такой команды:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alv-cinn% source .zshrc</span> </p>
    <p class="Textbody">Кстати, конфигурационных файлов для Zsh предусмотрено много, и порядок их считывания тоже определён жёстко. Однако далее речь будет идти, за одним специально оговоренным исключением, только о редактировании ~/.zshrc. Почему? Да потому, что остальные конфиги или были придуманы для совместимости с оболочкой совсем другого семейства, Tcsh, или не оказывают влияния на пользовательский сеанс.</p>
    <h3 id="toc107"><a id="RefHeading16561713816058"></a><a id="bkmRefHeading16561713816058"></a><a id="toc106"></a><a id="bkmtoc106"></a><a id="RefHeading5001136957987"></a><a id="bkmRefHeading5001136957987"></a><a id="bkmRefHeading5001136957987"></a><a id="bkmbkmRefHeading5001136957987"></a>Документация</h3>
    <p class="Textbody">Но прежде чем перейти к настройкам Zsh, надо сказать несколько слов о его документации, столь расхваленной мной во вводных словах. И первое, что тут удивляет — отсутствие для его текущих версий (5.0.X) стандартных man-страниц. Раньше они были, причём во множестве: собственные страницы были посвящены отдельным частям этой оболочки (опциям, параметрам, функциям etc.), а сама по себе страница man (1) zsh играла роль оглавления.</p>
    <p class="Textbody">Но со временем суммарный объём man-документации достиг такого размера, что ей стало практически невозможно пользоваться в том режиме, в котором мы все привыкли общаться с любимой тётей Маней. И потому разработчики Zsh от man-страниц в составе самого пакета отказались.</p>
    <p class="Textbody">Но зато, во-первых, пакет zsh и жёстко с ним связанный zsh-common сопровождается пакетом zsh-doc, который в большинстве дистрибутивов (в том числе и в Mint) следует устанавливать отдельно. Он содержит материалы в форматах info и html общим объёмом 6 МБ, а также включает PDF-руководство на 400 страниц.</p>
    <p class="Textbody">Во-вторых, Zsh сопровождается также пакетом zsh-lovers — он также устанавливается отдельно, и его компоненты после этого будут располагаться в каталоге /usr/share/doc/zsh-lovers. Он озаглавлен так: Советы, рекомендации и примеры для Z Shell. И содержит большинство тех самых man-страниц, которые были изъяты из основного пакета — в чисто текстовом формате или в виде gz-компрессированных файлов. А также — заявленные советы, рекомендации и примеры, созданные многочисленными применителями этой оболочки. Все они поимённо перечислены в файле /usr/share/doc/zsh-lovers/README. Своего рода квинтэссенцией пакета является страница man (1) zsh-lovers, в конспективной форме описывающая основные возможности этой оболочки, иллюстрируя их примерами. Собственно, её обзор (OVERVIEW) и начинается словами:</p>
    <p class="Textbody">Каждый раз, когда мы заглядываем в руководство по Zsh, мы удивляемся, почему там нет примеров или просто случаев из жизни в командной оболочке. Возможностей у Zsh, много, а руководства, иллюстрирующего их примерами, нет. Поэтому мы написали своё руководство.<br />…<br />Это просто развлекухи ради.</p>
    <p class="Textbody">И, надо сказать, развлекуха получилась не без пользы для нас, применителей. Кстати, читать эту развлекуху можно также в форматах HTML и PDF.</p>
    <p class="Textbody">В-третьих, неисчислимое по объёму количество информации о Zsh'е имеется в Интернете — и всё это богачество доступно по ссылкам с <a href="http://www.zsh.org/" target="_blank">официальный сайт</a>, главнейшей из которых является ссылка на <a href="http://zsh.sourceforge.net/" target="_blank">zsh.sourceforge.net</a>. Здесь можно найти руководства по этому шеллу на любой вкус — от «юзерофильного» до исчерпывающего, а также ссылки на книги, wiki, статьи и прочие материалы. Разбираться в этом океане я предоставляю заинтересованным (или заинтересовавшимся) читателям.</p>
    <p class="Textbody">В-четвёртых, существует сайт, именуемый <a href="http://ohmyz.sh/" target="_blank">Oh My ZSH!</a>. Это коллекция плагинов, скриптов, конфигов и тем приглашения командной строки. Она инсталлируется на локальную машину и в дальнейшем автоматически синхронизируется с родительским сайтом, который пользуется всенародной популярностью и широкой известностью в узких кругах энтузиастов Zsh.</p>
    <p class="Textbody">Наконец, в-пятых, официальными, полуофициальными и общенародными ресурсами информация о Zsh не исчерпывается — существует много «неучтённых» на zsh.sourceforge.net сайтов и блогов, ведомых любителями этого шелла. И на них часто можно найти освещёние неожиданных и интересных нюансов его конфигурирования. В последние годы в их числе появились и русскоязычные ресурсы. Из последних хотелось бы отметить подборку статей на <a href="http://muhas.ru/" target="_blank">сайте Михаила Мищенкова aka muhas</a>).</p>
    <h3 id="toc108"><a id="RefHeading16581713816058"></a><a id="bkmRefHeading16581713816058"></a><a id="toc107"></a><a id="bkmtoc107"></a><a id="RefHeading5021136957987"></a><a id="bkmRefHeading5021136957987"></a><a id="bkmRefHeading5021136957987"></a><a id="bkmbkmRefHeading5021136957987"></a>Настройка приглашения</h3>
    <p class="Textbody">Как известно со времён со времён Константин Сергеича Станиславского, театр начинается с вешалки, а дистрибутив — с инсталлятора. Командная же оболочка начинается с приглашения командной строки. Каковая, во-первых, отражает готовность системы к выполнению действий применителя, а во-вторых, несёт (или должна бы нести) некую существенную для него информацию.</p>
    <p class="Textbody">Правда, умолчальное приглашение Zsh информативностью не блещёт, сообщая только имя хоста (в примере на предыдущей странице — alv-cinn), и то, что сеанс шелла запущен обычным пользователем — в отличие от Bash'а, здесь это по умолчанию выражается символом %. Однако добавить информации нам никто не мешает. А помогает — файл zshexports.gz из пакета zsh-lovers, упомянутого в позапрошлом очерке. Его можно просмотреть командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ zcat path3/zshexports.gz</span> </p>
    <p class="Textbody">отыскать в нём секцию, начинающуюся словами</p>
    <p class="Textbody"><span style="background-color:#dddddd"># PS{1,2,3}, RPOMPT, ..</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"># The "prompt" of the shell</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">внимательно изучить её, а также фрагмент конкретных примеров:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># Some examples:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">#  PS1="PS1='%B%n%b@%m:%4c&gt;'"</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">осмыслить прочитанное и опробованное на примерах. После чего решить, какую же информацию вы хотите видеть в приглашении командной строки.</p>
    <p class="Textbody">Я, например, не хочу видеть там имени хоста, поскольку не дожил ещё до ситуации из известного аккордеонистого бояна: «Кто я, кто я? Губайдулин я!» Да и вообще, времена, когда каждая машина в сети имела собственное неповторимое имя, канули в лету, и нынче так называемое «хвостнаме» берётся от булды.</p>
    <p class="Textbody">А вот имя пользователя в явном виде будет не лишним — у меня на основной машине их обычно не менее трёх: рабочий, экспериментальный и умолчально-восстановительный. Также неплохо иметь представление о своём положении в файловой иерархии, причём в полном виде — одноимённые подкаталоги часто находятся в разных её ветвях. Приглашение получается перегруженным? Отнюдь, потому что в Zsh таковых предусмотрено два — просто PROMPT и RPROMT, и перечисленные элементы можно разнести таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/home/data/current $=&gt;                                  [alv]</span> </p>
    <p class="Textbody">Или наоборот, таким:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">[zshuser]$=&gt;                                  [/home/data/current]</span> </p>
    <p class="Textbody">Добиться этого можно, как вы понимаете, редактированием файла ~/.zshrc. До сих пор он у нас содержал единственную строку комментария:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># Created by newuser for 5.0.2</span> </p>
    <p class="Textbody">Теперь же добавляем в него сторки для получения приглашения первого вида:</p>
    <p class="Textbody"><span style="background-color:#dddddd">## Prompt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">PROMPT='%~ $=&gt; '</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">RPROMPT=' [%n] '</span> </p>
    <p class="Textbody">Или второго:</p>
    <p class="Textbody"><span style="background-color:#dddddd">## Prompt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">PROMPT='[%n]$=&gt; '</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">RPROMPT=' [%~] '</span> </p>
    <p class="Textbody">Раньше мне больше нравился первый вариант, но ныне я перешёл на второй.</p>
    <p class="Textbody">Кроме обычного, то есть «левого» приглашения и приглашения «правого», в Zsh поддерживаются также приглашение «вторичное», выводимое в многострочных командах, и «третичное» — предложение вариантов замены при включённой коррекции ошибок, PROMPT2 и PROMPT3, соответственно. Вторичное приглашение у меня имеет вид</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">PROMPT2='%i%U&gt; '</span> </p>
    <p class="Textbody">В результате в нём выводится номер «вторичной» строки в данном сеансе шелла, указывается стрелкой на то, что ввод следует в ней продолжить, а сам ввод даётся подчёркнутым шрифтоначертанием. Вживе это выглядит так:</p>
    <p class="Textbody"><span style="background-color:#dddddd">[zshuser]$=&gt; echo $USER \                                   [~]</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">33&gt; echo $SHELL \</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">34&gt; echo $PATH</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zshuser echo /bin/zsh echo /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span> </p>
    <p class="Textbody">Что же до коррекции ошибок, у меня она отключена (к этому вопросу мы ещё вернёмся).</p>
    <p class="Textbody">А вообще, как можно увидеть в файле zshexports.gz, в любом из видов приглашения командной строки могут фигурировать:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">полное или сокращенное имя хост-машины; </p>
      </li>
      <li>
        <p class="Textbody">путь к текущему каталогу в различных формах; </p>
      </li>
      <li>
        <p class="Textbody">номер текущей команды в буфере истории или строки в данном сеансе работы; </p>
      </li>
      <li>
        <p class="Textbody">имя пользователя; </p>
      </li>
      <li>
        <p class="Textbody">название командной оболочки; </p>
      </li>
      <li>
        <p class="Textbody">номер виртуальной консоли или текущего терминала; </p>
      </li>
      <li>
        <p class="Textbody">дата и время в разных форматах; </p>
      </li>
      <li>
        <p class="Textbody">индикация работы от лица суперпользователя; </p>
      </li>
      <li>
        <p class="Textbody">любые символы типа стрелок, крышечек, скобочек; </p>
      </li>
      <li>
        <p class="Textbody">текстовые сообщения (например, поздравление с началом трудового процесса); </p>
      </li>
      <li>
        <p class="Textbody">и многое другое. </p>
      </li>
    </ul>
    <p class="Textbody">Кроме того, приглашение могут быть оформлены визуально различно: выделением жирным шрифтом (boldface mode), инвертированием текста/фона (standout mode), полчёркиванием (underline mode), а также цветами. «Раскрашенный» шелл мне нравится не больше, чем «раскрашенный» Штирлиц, инвертирование также вызывает раздражение, а вот выделение полужирным шрифтоначертанием и подчёркиванием я использую. В результате секция настройки вида приглашения в моём ~/.zshrc выглядит так:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># Left prompt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">PROMPT='%B[%n]$=&gt;%b '</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">PROMPT2='%i%U&gt; '</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">#</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"># Right prompt</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">RPROMPT=' %B[%~]%b '</span> </p>
    <p class="Textbody">Как уже говорилось, я не призываю к подражательству, а лишь предлагаю поэкспериментировать, чтобы добиться максимальной информативности приглашения и его внешней выразительности.</p>
    <h3 id="toc109"><a id="RefHeading16601713816058"></a><a id="bkmRefHeading16601713816058"></a><a id="toc108"></a><a id="bkmtoc108"></a><a id="RefHeading5041136957987"></a><a id="bkmRefHeading5041136957987"></a><a id="bkmRefHeading5041136957987"></a><a id="bkmbkmRefHeading5041136957987"></a>Темы приглашений</h3>
    <p class="Textbody">Только что речь шла о том, как оформить приглашение командной строки Zsh своими руками, в соответствие с собственными вкусами и предпочтениями. Однако можно пойти другим путём, и воспользоваться уже готовыми темами приглашений. Они входят в пакет zsh-common, который всегда, насколько я знаю, устанавливается как зависимость пакета zsh. После установки местоположение готовых тем — каталог /usr/share/zsh/functions/Prompts.</p>
    <p class="Textbody">Сами по себе темы приглашения — файлы вида prompt_themename_setup, представляющие собой функции Zsh, описывающие как вид приглашения, так и, часто, некоторый его декор, типа расцветки, которая может быть нескольких видов. Однако разбираться в устройстве этих функций не обязательно — с ними можно ознакомиться визуально.</p>
    <p class="Textbody">Знакомство это начинается с запуска функций управления видом приглашений:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ autoload -U promptinit &amp;&amp; promptinit</span> </p>
    <p class="Textbody">После чего можно давать команду на «смотрины невест»:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ prompt -p</span> </p>
    <p class="Textbody">которая выведет их все (в моей системе — около двух десятков, плюс цветовые вариации) примерно в таком виде:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_006.png">
        <img alt="Изображение242" class="frameGraphics" id="242graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_006-540x572.png" style="border:1.0px solid #000080;padding:0;width:541.8243px;height:573.83685px" />
      </a>
      <a id="a242graphic"></a>
      <a id="bkm242graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_006.png"> </a>
    </p>
    <p class="Textbody">Среди «невест» можно видеть весьма пёстро наряженных:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_0071.png">
        <img alt="Изображение243" class="frameGraphics" id="243graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_0071-540x572.png" style="border:1.0px solid #000080;padding:0;width:541.8243px;height:573.83685px" />
      </a>
      <a id="a243graphic"></a>
      <a id="bkm243graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_0071.png"> </a>
    </p>
    <p class="Textbody">Но и одетых весьма скромно также есть:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_008.png">
        <img alt="Изображение244" class="frameGraphics" id="244graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_008-540x572.png" style="border:1.0px solid #000080;padding:0;width:541.8243px;height:573.83685px" />
      </a>
      <a id="a244graphic"></a>
      <a id="bkm244graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_008.png"> </a>
    </p>
    <p class="Textbody">Выбрав подходящую <span style="text-decoration:line-through">невесту</span> тему, её можно тут же установить командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ prompt имя_темы</span> </p>
    <p class="Textbody">при желании — с указанием цветовых параметров, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ prompt fade white grey blue</span> </p>
    <p class="Textbody">Что в «живом» терминальном окне (терминал Sakura) будет выглядеть так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_009.png">
        <img alt="Изображение245" class="frameGraphics" id="245graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_009-572x290.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:291.8463px" />
      </a>
      <a id="a245graphic"></a>
      <a id="bkm245graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_009.png"> </a>
    </p>
    <p class="Textbody">А в выпадающем терминале Guake — несколько иначе:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_010.png">
        <img alt="Изображение246" class="frameGraphics" id="246graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_010-572x305.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:306.85104px" />
      </a>
      <a id="a246graphic"></a>
      <a id="bkm246graphic"></a>
    </p>
    <p class="Textbody">Кстати, а в «голой» консоли вид этой же темы будет существенно скромнее — разбираться с программами для изготовления скриншотов консоли мне было лень, так что прошу поверить на слово.</p>
    <p class="Textbody">Установленная таким образом тема будет функционировать только в данном терминальном окне в течении текущего сеанса. Чтобы увековечить её, необходимо вписать в файл ~/.zshrc такие строки:</p>
    <p class="Textbody"><span style="background-color:#dddddd">autoload -Uz promptinit</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">promptinit</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">prompt clint</span> </p>
    <p class="Textbody">В примере приведена тема, пожалуй, наиболее информативного приглашения, которое «вживе» вылядит так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_011.png">
        <img alt="Изображение247" class="frameGraphics" id="247graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_011-572x290.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:291.8463px" />
      </a>
      <a id="a247graphic"></a>
      <a id="bkm247graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_011.png"> </a>
    </p>
    <p class="Textbody">Большое количество тем можно при желании отыскать на сайте <a href="http://ohmyz.sh/" target="_blank">Oh My ZSH!</a>, но эти я уже заниматься не стал.</p>
    <h3 id="toc110"><a id="RefHeading16621713816058"></a><a id="bkmRefHeading16621713816058"></a><a id="toc109"></a><a id="bkmtoc109"></a><a id="RefHeading5061136957987"></a><a id="bkmRefHeading5061136957987"></a><a id="bkmRefHeading5061136957987"></a><a id="bkmbkmRefHeading5061136957987"></a>Приёмы навигации</h3>
    <p class="Textbody">Сознательные граждане, активно применяющие CLI, используют множество команд, как встроенных в их любимый шелл, так и внешних. Но, думаю, что самыми употребимыми в повседневной жизни являются такие:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">pwd для определения своего текущего положения на файловом древе — да-да, иногда, после многократных переходов между подкаталогами, забываешь, не только кто я, но и где я (уж не в Тимирязском ли?); </p>
      </li>
      <li>
        <p class="Textbody">ls — для просмотра содержимого текущего каталога; </p>
      </li>
      <li>
        <p class="Textbody">cd — для перехода в определённый каталог. </p>
      </li>
    </ul>
    <p class="Textbody">Однако здесь Zsh вносит свои коррективы, здорово облегчающие жизнь его применителя. Только что было показано, как фактическим можно избавиться от команды pwd, выведя путь к текущему каталогу в качестве RPROMPT. Без команды ls, конечно, не обойтись и Zsh. А вот команда cd в Zsh просто… не нужна.</p>
    <p class="Textbody">Да, дорогие мои болельщики, в среде Zsh без этой команды не просто можно обойтись, а жить куда комфортней, нежели с ней. Ведь давайте вспомним, что такое переход в каталог имя_рек? Для типа файлов, именуемого каталогом (directory) это то же самое, что исполнение для обычного (ordinary) файла, будь он откомпилированным бинарником или интерпретируемым сценарием.</p>
    <p class="Textbody">И потому более чем логично то, что как для запуска скрипта оболочки не требуется никакой внешней команды (хотя и не возбраняется что-нибудь типа . или /bin/sh), так и для перехода в каталог, к которому данный юзер имеет доступ (то есть попадает в число тех, для кого у этого каталога установлен бит исполнения), ему достаточно указать полный путь к нему, без всяких команд. Например, введя к командной строке что-нибудь вроде</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /usr/share/fonts/truetype/</span> </p>
    <p class="Textbody">можно сразу оказаться в каталоге с TTF-шрифтами.</p>
    <p class="Textbody">«Бескомандный» переход в каталоги распространяется и на «символические» обозначения последних. Так, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ~</span> </p>
    <p class="Textbody">переместит пользователя в его домашний каталог. Как, кстати, и команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ $HOME</span> </p>
    <p class="Textbody">Хотя практического смысла последний вариант не имеет. Зато директива</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ..</span> </p>
    <p class="Textbody">волшебным образом ознаменует переход в каталог, родительский относительно текущего.</p>
    <p class="Textbody">Правда, всё это происходит не само собой: для практического воплощения этого волшебства в общесистемном конфиге /etc/zsh/zshrc или пользовательском ~/.zshrc должна присутствовать строка</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">setopt autocd</span> </p>
    <p class="Textbody">В пару к ней можно добавить ещё и такую строку:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">cdpath=(~/ /home/current/ /home/data/)</span> </p>
    <p class="Textbody">где в скобках перечислены каталоги, к подкаталогам которых чаще всего требуется быстрый доступ. И теперь, где бы в пределах файлового древа ни находился пользователь, ввод им директивы</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ Documents</span> </p>
    <p class="Textbody">нечувствительно сделает текущим каталогом /home/username/Documents.</p>
    <p class="Textbody">То есть опция autocd и массив переменных cdpath отнюдь не исключают, а прекрасно дополняют друг друга.</p>
    <h3 id="toc111"><a id="RefHeading16641713816058"></a><a id="bkmRefHeading16641713816058"></a><a id="toc110"></a><a id="bkmtoc110"></a><a id="RefHeading5081136957987"></a><a id="bkmRefHeading5081136957987"></a><a id="bkmRefHeading5081136957987"></a><a id="bkmbkmRefHeading5081136957987"></a>Автодополнение</h3>
    <p class="Textbody">Волшебное свойство клавиши Tab, вызывающей автодополнение — одно из первых, с чем знакомится применитель CLI. Хотя при этом часто забывается, что когда-то, в перворождённом шелле Борна, никакого автодополнения не было. Оно появилось в Csh — и сначала только для путей, но не для команд. Тем не менее, ныне представить себе интерактиную работу в командной строке без автодополнения невозможно (да и не нужно).</p>
    <p class="Textbody">Однако в Zsh клавиша Tab волшебна дважды: она не только дополняет пути и команды после их частичного ввода, но и способна развернуть аббревиатуры для тех и других. Например, нажатие клавиши табулции после набора последовательности</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /u/s/f/tr</span> </p>
    <p class="Textbody">развернёт её в полный путь к каталогу со шрифтами TrueType</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /usr/share/fonts/truetype</span> </p>
    <p class="Textbody">а после нажатия клавиши Enter сделает этот каталог текущим, как мы только что видели.</p>
    <p class="Textbody">Правда, само по себе развёртывание аббревиатур работать не будет — его надо активизировать такими строками в файле ~/.zshrc:</p>
    <p class="Textbody"><span style="background-color:#dddddd"> autoload -Uz compinit</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">compinit</span> </p>
    <p class="Textbody">Можно пойти дальше, и не просто разворачивать безальтернативные аббревиатуры, типа приведённый выше, но и выбирать стрелками, как в меню, подкаталги или файлы среди предлагаемый альтернатив. Например, если набрать ту же самую<br />последовательность символов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /u/s/f/tr</span> </p>
    <p class="Textbody">а затем дважды нажать клавишу табуляции, то она не только развернётся в полный путь</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /usr/share/fonts/truetype/</span> </p>
    <p class="Textbody">но и выведет список подкаталогов указанного каталога:</p>
    <p class="Textbody"><span style="background-color:#dddddd">dejavu/ freefont/ openoffice/ ubuntu-font-family/ droid/ liberation/</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">ttf-dejavu/ wqy/</span> </p>
    <p class="Textbody">И выбор нужного среди них можно выполнять либо стрелками управления курсором, либо обычными кейбиндингами типа Control+f, Control+b и им подобными:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_012.png">
        <img alt="Изображение248" class="frameGraphics" id="248graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_012-572x305.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:306.85104px" />
      </a>
      <a id="a248graphic"></a>
      <a id="bkm248graphic"></a>
    </p>
    <p class="Textbody">Правда, и такая реакция Zsh на Tab возникает не из воздуха, а из присутстствия в файле ~/.zshrc таких строк:</p>
    <p class="Textbody"><span style="background-color:#dddddd"> setopt menucomplete</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zstyle ':completion:*' menu select=1 _complete _ignored _approximate</span> </p>
    <p class="Textbody">По умолчанию их там нет, а вот стоит ли их вносить — применитель должен решить для себя сам — перебор вариантов традиционным способом, то есть последовательным нажатием клавиши табулции, может показаться более удобным.</p>
    <h3 id="toc112"><a id="RefHeading16661713816058"></a><a id="bkmRefHeading16661713816058"></a><a id="toc111"></a><a id="bkmtoc111"></a><a id="RefHeading5101136957987"></a><a id="bkmRefHeading5101136957987"></a><a id="bkmRefHeading5101136957987"></a><a id="bkmbkmRefHeading5101136957987"></a>История команд</h3>
    <p class="Textbody">Возможность просмотра истории введённых ранее команд клавишами Up/Down кажется таким же неотъемлемым атрибутом CLI, как и автодополнение командной строки. И, как и последнее, напрочь отсутствовало в перворождённом шелле Борна, однако ныне имеется во всеш развитых шеллах. Причём доступ к истории команд в них не ограничивается командой history и упомянутыми стрелками. В частности, в Bash широко практикуется инкрементный поиск по клавишной последовательности Control+R и вводу последовательности символов одной из предыдущих команд или её аргументов.</p>
    <p class="Textbody">В tcsh же испокон веков существовала (и, что характерно, обычно была активирована по умолчанию) другая возможность — так называемый history-substring-search, то есть инкрементный перебор истории команд по вводимым символам. Что это такое — проще пояснить на примере: вы вводите в командной строке один символ (для примера — s) и нажимаете клавишу Up. И тут в перебор включаются только те команды из истории, которые с буковки s начинаются. Вводя дополнительные символы, можно сузить круг поиска: например, последовательность sudo позволяет просмотреть, что было наколбасино от лица суперпользователя вообще.</p>
    <p class="Textbody">Поскольку Zsh изначально задумывалась как синтез всех передовых достижений шелло-строительной мысли, аналогичная возможность имеется и здесь. Правда, как и многие другие продвинутые фичи этой оболочки, она требует активации. То есть — внесения в файл ~/.zshrc таких строк:</p>
    <p class="Textbody"><span style="background-color:#dddddd">bindkey "^[[A" up-line-or-search</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">bindkey "^[[B" down-line-or-search</span> </p>
    <p class="Textbody">Как выяснилось, надо подчеркнуть: перебор history-substring-search и инкрементный поиск по Control+R отнюдь не исключают друг друга, а дополняют: первым способом проще искать ранее введённые директивы по имени команды, вторым — по её аргументам, например, по имени файла.</p>
    <p class="Textbody">Справедливости ради надо сказать, что history-substring-search нынче реализован и в Bash, хотя, как и в Zsh, требует активации.</p>
    <p class="Textbody">Опытный применитель Zsh, не имевший ранее дела с Ubuntu и её производными (в том числе и с Mint'ом), будет весьма удивлён тем обстоятельством, что эта фича (по моему мнению, одна из самых полезных среди всех достоинств нашей героини), с кондачка работать не будет. Даже при условии правильно настроенного конфига — при внесённых в него строках, указанных выше. Точнее, не будет делать это в окне любого иксового эмулятора терминала, хотя не откажется от выполнения history-substring-search в «голой» консоли. Причём интересно, что это же касается и Bash, хотя в Tcsh данная фича будет работать «искаропки».</p>
    <p class="Textbody">Следствие, проведённое в Джуйке и благодаря участию джуковца @altwazar'а, показало, что это давний известный баг, восходящий к Debian'у, знаменитому своей стабильностью во всех отношениях (в том числе и в отношении багов, вероятно). И бороться с этим можно различными методами. Мне самым простым показался такой: создание в домашнем каталоге файла ~/.zshenv с единственной строкой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">DEBIAN_PREVENT_KEYBOARD_CHANGES=yes</span> </p>
    <p class="Textbody">Разумеется, на поведение Bash это никак не скажется: в нём history-substring-search включается не через его профильный файл, а через inputrc — конфиг для readline. Как именно — оставляю на рассмотрение преданных поклонников этой оболочки.</p>
    <p class="Textbody">Разумеется, возможности настройки доступа к истории команд всем сказанным выше не исчерпываются: имеет место быть и исключение из неё дубликатов, и пустых строк, и прочего баласта, а также подключения некоторых полезных фич, вроде ограничения общей истории и истории текущего сеанса. А также — дополнения файла истории. Однако ничего особенного, специфичного именно для Zsh, тут уже нет. Так что к рассмотрению этих вопросов я вернусь под занавес — когда буду говорить о ~/.zshrc для себя, любимого...</p>
    <h3 id="toc113"><a id="RefHeading16681713816058"></a><a id="bkmRefHeading16681713816058"></a><a id="toc112"></a><a id="bkmtoc112"></a><a id="RefHeading5121136957987"></a><a id="bkmRefHeading5121136957987"></a><a id="bkmRefHeading5121136957987"></a><a id="bkmbkmRefHeading5121136957987"></a>Рекурсивный поиск</h3>
    <p class="Textbody">Все применители CLI знают и любят утилиту find — и любят заслуженно, ибо это апофеоз командного интерфейса: с её помощью можно отыскать в файловой системе всё, что угодно — и почти всё, что нужно, с найденным сделать, конечно, с помощью некоторых дополнительных средств, вроде xargs и конвейеров. Однако для многих рутинных задач мощь этой команды кажется излишней, напоминая знаменитое упражнение по отстрелу мелких пернатых их зенитно-ракетных комплексов. И вот тут Zsh опять позволяет решать такие задачи малой кровью — то есть с минимальным ударением по клавишам. Ибо поддерживает такую штуку, как рекурсивные поиск.</p>
    <p class="Textbody">Что это такое — как обычно, проще показать, чем рассказать. Предположим, перед применителем стоит задача отыскать все картинки в каталоге некоего проекта, включая все вложенные в него подкаталоги. Средствами Zsh сделать это очень просто — достаточно дать команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls path3/**/*.png</span> </p>
    <p class="Textbody">где path3, как нетрудно догадаться, «корневой» каталог поиска, *.png — маска искомых файлов, а «двузвёздие» — так сказать, директива рекурсивного поиска.</p>
    <p class="Textbody">Правда, вопреки утверждениям некоторых уж очень правоверных Zsh'истов, эта возможность не делает команду find избыточной, ибо, как все знают, она умеет и многое другое. Но зато такая простая директива позволяет не беспокоить Её Величество по пустякам...</p>
    <p class="Textbody">А заодно — конструкции вида **/* можно использовать как аргументы команд управления файлами, таких, как cp, mv, rm. В частности, с помощью команды вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ rm -f path3/**/*~</span> </p>
    <p class="Textbody">можно легко гуртом избавиться от всех временных копий, которые по умолчанию так любят сохранять некоторые текстовые редакторы и ворд-процессоры, если им не запретить это самым категорическим образом.</p>
    <p class="Textbody">Разумеется, можно фильтровать базар. Давеча в приступе чёрной меланхолии переслушивал я всё, что сочинил и спел Фред Солянов — увы, большинство моих потенциальных читателей о его существовании не подозревают: в отличе от многих всенародно известных так называемых «бардов», он не был популярен при жизни. А когда его верхние люди позвали — люди нижние про него забыли напрочь. И зря — но это из совсем другой оперы. А в нынешней арии мне было интересно, сколько же Фред сочинил песен за ту четверть чека, что ему отпустила на то судьба. И я дал очень простую команду:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls path3/fred/**/*.mp3 | wc -l</span> </p>
    <p class="Textbody">И она мне сказала, что сочинил Фред 168 песен. Откидываем дубликаты, неизбежные в любой коллекции — но здесь их очень мало, на штуки счёт.</p>
    <p class="Textbody">Откинем откровенно слабые песенки — ведь даже гений не каждое утро начинает с сочинения чего-то шедеврального. Откинем песенки вторичные — Фред никогда не претендовал на основоположничество, и, в отличе от некоторых более иных авторов, на которых я не хотел бы указывать пальцем, не считал для себя западло называть своего реального учителя в ентом деле, Булат Шавловича...</p>
    <p class="Textbody">Для себя откину те песенки, которые лично меня не очень зацепили — их, по сравнению с прочими фильтрами, больше всего, почти полсотни.</p>
    <p class="Textbody">Остаётся - около ста песен. За двадцать пять лет. Мало по сравнению с раннеперестроечными сборниками типа «Шестьсот лучших песен имя река»? Да, не много. Но ведь (и это мнение не только моё, а тысяч людей с такими же биографиями) эти песни стали, как нынче принято говорить, культовыми.</p>
    <p class="Textbody">Ну, дальше на эту тему распространяться не буду, а вернусь к генеральной линии сюжета. А именно — что маски типа **/*можно использовать в аргументах команды grep и для поиска фрагментов текстов. Так, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ grep KDE **/*html</span> </p>
    <p class="Textbody">выведет все строки с упоминанием KDE в html-файлах каталога текущего и вложенных. А в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ grep -i kde **/kde*.html</span> </p>
    <p class="Textbody">она произведёт аналогичный поиск только в файлах вида kde01.html, kde02.html и так далее. Причём без учёта регистра — но к мадемуазель Zsh, интересы которой я представляю в данный момент, это не имеет никакого отношения.</p>
    <h3 id="toc114"><a id="RefHeading16701713816058"></a><a id="bkmRefHeading16701713816058"></a><a id="toc113"></a><a id="bkmtoc113"></a><a id="RefHeading5141136957987"></a><a id="bkmRefHeading5141136957987"></a><a id="bkmRefHeading5141136957987"></a><a id="bkmbkmRefHeading5141136957987"></a>Перенаправление расширенное и множественное</h3>
    <p class="Textbody">Что такое перенаправление ввода/вывода — знают все применители CLI. Однако в Zsh возможности его очень широки, почему оно и называется здесь расширенным перенаправлением. Этот механизм позволяет в ряде случаев обходиться без некоторых команд вообще. Например, обычно для просмотра текстового файла применяют или команду cat, или команды-пейджеры типа more, less, most. Выбор между конкатенатором и одним из пейджеров определяется ситуацией, выбор внутри «тройки по борьбе с <span style="text-decoration:line-through">басмачами</span> файлами» зависит от привычек или предпочтений. Однако Zsh может избавить применителя от мук буриданова осла, подменяя любую из этих команд оператором перенаправления в виде команды</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ &lt; filename</span> </p>
    <p class="Textbody">Результатом чего будет постраничный вывод содержимого файла, подобный таковому любого пейджера.</p>
    <p class="Textbody">С помощью того же оператора можно просмотреть одновременно содержимое двух файлов — то есть, конечно, не одновременно, а последовательно, но в едином потоке. То есть команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ &lt; {zshenv,zshrc}</span> </p>
    <p class="Textbody">покажет оба файла как одно целое. Причём в данном случае можно поступить ещё проще, ибо маски имён файлов также не возбраняются:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ &lt; z*</span> </p>
    <p class="Textbody">Кстати, в терминах Zsh развёртывание масок имён файлов называется globbing — с ним мы уже сталкивались в рассказе о рекурсивном поиске.</p>
    <p class="Textbody">Число «оперируемых» файлов ничем не ограничено, кроме здравого смысла и целесообразности. Так, есть резон проглядеть таким образом на скорую руку, как будут выглядеть 5-6 заметок по несколько строк каждая, если их объединить в одну статью. Но просматривать с помощью оператора перенаправления книжку, состоящую из пары десятков глав по много страниц каждая, уже явный перебор.</p>
    <p class="Textbody">Однако бывают случаи, когда большое число «оперируемых» файлов очень даже уместно. Например, если требуется объединить ряд текстовых фрагментов в единый файл. И тогда, легким движением рук набрав в командной строке конструкцию</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ &lt; chapter[01-10] &gt; mybook</span> </p>
    <p class="Textbody">мы на выходе из разрозненных глав получаем готовую книгу.</p>
    <p class="Textbody">Таким образом мы перешли уже к множественному перенаправлению. Применение которого просмотром файлов не исчерпывается — их содержимое может быть перенаправлено не только на стандартный вывод, но и на ввод какой-либо команды, подменяя командный конвейер. Например, конструкция вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sort &lt; file_{1,2}</span> </p>
    <p class="Textbody">совместно отсортирует строки обоих файлов, file_1 и file_2, точно так же, как это сделал бы конвейер команд</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cat file_1 file_2 | sort</span> </p>
    <p class="Textbody">Кстати, перенаправление вполне может играть с конвейерами в одной команде. Например, конструкция вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ time commandname [options] [arguments] &gt; filename | cat</span> </p>
    <p class="Textbody">занесёт время выполнения некоей команды в файл с одновременным выводом его на экран, заменяя команду tee. Это особенно полезно при всяких «тестированиях на быстродействие», когда надо и сохранить результат для дальнейшей обработки, и не терпится посмотреть на него сразу.</p>
    <p class="Textbody">Множественное перенаправление удобно использовать для суммарного подсчёта числа символов в нескольких файлах таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ wc -m &lt;*txt</span> </p>
    <p class="Textbody">Что на выводе даст единственное число, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">5382</span> </p>
    <p class="Textbody">Казалось бы, та же команда в «обычной» форме даже короче на один символ:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ wc -m *txt</span> </p>
    <p class="Textbody">Однако вывод её будет развёрнут:</p>
    <p class="Textbody"><span style="background-color:#dddddd">2820 my_file_1.txt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> 606 my_file_2.txt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> 401 my_file_3.txt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">1555 my_file_4.txt</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">5382 итого</span> </p>
    <p class="Textbody">Что при работе во встроенных терминальных окнах текстовых редакторов вроде Geany или Kate , часто небольших по размеру может оказаться лишним. А ведь именно там приёмы, подобные описанным в этом разделе, оказываются весьма эффективными.</p>
    <p class="Textbody">В общем, уже за одну только конструкцию &lt; filename разработчики Zsh заслужили памятник, а все остальные возможности расширенного и множественного перенаправления выступают как бесплатное приложение к ней.</p>
    <h3 id="toc115"><a id="RefHeading16721713816058"></a><a id="bkmRefHeading16721713816058"></a><a id="toc114"></a><a id="bkmtoc114"></a><a id="RefHeading5161136957987"></a><a id="bkmRefHeading5161136957987"></a><a id="bkmRefHeading5161136957987"></a><a id="bkmbkmRefHeading5161136957987"></a>Просто псевдонимы и псевдонимы глобальные</h3>
    <p class="Textbody">Что такое псевдонимы, по простому aliases, — знают все, кто применяет любую командную оболочку: их поддержка существует со времён перворождённого шелла Борна. Это один из простых способов минимизировать ввод командных директив, начиная с простейшего рекурсивного копирования файлов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias cp='cp -R'</span> </p>
    <p class="Textbody">И заканчивая бессчётным количеством псевдонимов для команды ls.</p>
    <p class="Textbody">Однако в Zsh есть ещё одна фича — глобальные псевдонимы, по сей день не имеющие аналогов, насколько я знаю, во всяких там ваших башах. И даже в почти соплеменных тсишах их нет.</p>
    <p class="Textbody">Но начну по порядку. Опять же, кого не раздражала ситуация: в ответ на поиск файла find'ом или поиск фрагмента текста grep'ом выдаётся сто пятьсот экранов сообщений, что доступ к каталогу запрещён?</p>
    <p class="Textbody">Разумеется, каждый применитель Bash'а знает, как с этим бороться — достаточно присобачить к конструкции поиска посредством той или другой утилиты маленький аппендикс в виде 2&gt; /dev/null, отправляющий в небытие все сообщения об ошибках.</p>
    <p class="Textbody">Сложнее применителям Tcsh — там подавления вывода нежелательных сообщений об ошибках возможно в виде такой конструкции:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">% (command &gt; out)&gt;&amp; err</span> </p>
    <p class="Textbody">где command — команда со всеми её опциями и аргументами, out — условное имя файла, в который перенаправляется «полезный» вывод команды, а &amp; в данном контексте представляет весь остаток от оного, то есть сообщения об ошибках, которые помещаются в файл err. Имя последнего также условно, так что никто не запрещает подменить его сакраментальным /dev/null.</p>
    <p class="Textbody">Конструкция далеко не столь проста, как в sh-совместимых оболочках типа Bash. Кроме того, для просмотра «полезного» вывода она потребует ещё одной команды — вызова какого-либо пейджера вроде less:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">% (command &gt; out)&gt;&amp; err ; less out</span> </p>
    <p class="Textbody">А вот применителям Zsh — проще всех. Им достаточно задать такой глобальный псевдоним:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ alias -g N='2&gt;/dev/null'</span> </p>
    <p class="Textbody">где -g указывает, что следующий символ (или символы) являют собой на простой псевдоним, а глобальный, N — его имя, а следующая после равенства последовательность в строгих кавычках — подменяемое им выражение. После чего можно практиковать такое:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find path3 -name [filename] N</span> </p>
    <p class="Textbody">И больше не заботиться о фильтрации зёрен от плевел.</p>
    <p class="Textbody">Глобальные псевдонимы очень полезны в командных конструкциях перенаправления по конвейеру, например, для поэкранного вывода:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ alias -g L='|less'</span> </p>
    <p class="Textbody">Пример для «пролистывания» вывода команды dmesg:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ dmesg L</span> </p>
    <p class="Textbody">Для фильтрации по вхождению «слова» можно задать такой глобальный псевдоним:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias -g G='|grep'</span> </p>
    <p class="Textbody">После чего использовать его в конструкциях, подобных такой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ dmesg G raid</span> </p>
    <p class="Textbody">что выведет нечто вроде</p>
    <p class="Textbody"><span style="background-color:#dddddd">[    1.434246] md: raid0 personality registered for level 0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">[    1.434376] md/raid0:md0: md_size is 390742016 sectors.</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">Мне весьма полезен глобальный псевдоним вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias -g W='|wc -m'</span> </p>
    <p class="Textbody">Поскольку часто требуется прибегать к такой конструкции</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cat filename W</span> </p>
    <p class="Textbody">которая в данном случае выведет число символов в текстовом файле — для меня оно важнее числа байт (а при использовании 16-битной кодировки для преимущественно кириллического текста эти значения не совпадают).</p>
    <p class="Textbody">К именам глобальных псевдонимов применяются те же требования, что и к именам псевдонимов обычных: они должны быть по возможности короткими, мнемонически прозрачными. И, разумеется, определения всех постоянно используемых глобальных псевдонимов следует занести в свой кондуитик — то есть в ~/.zshrc.</p>
    <p class="Textbody">Разумеется, здесь не описаны все возможные случаи употребления глобальных псевдонимов — они лимитируются только потребностями применителя и его фантазией. И, конечно, наказом, который дал атаман Платов небезызвестному Левше:</p>
    <p class="Textbody">Не пей мало, не пей много, а пей средственно.</p>
    <p class="Textbody">То есть — не придумывайте глобальных псевдонимов больше, чем сможете запомнить.</p>
    <h3 id="toc116"><a id="RefHeading16741713816058"></a><a id="bkmRefHeading16741713816058"></a><a id="toc115"></a><a id="bkmtoc115"></a><a id="RefHeading5181136957987"></a><a id="bkmRefHeading5181136957987"></a><a id="bkmRefHeading5181136957987"></a><a id="bkmbkmRefHeading5181136957987"></a>Псевдонимы-суффиксы</h3>
    <p class="Textbody">Кроме обычных и глобальных псевдонимов, в Zsh существует ещё одна их разновидность — псевдонимы «суффиксные», более удачного определения на языке родных осин я не придумал, псевдонимы.</p>
    <p class="Textbody">Подобно тому, как добаление к команде alias опции -g с помощью магии превращает обычный псевдоним в глобальный, так и опция -s делает обычный псевдоним «суффиксным». То есть привязывает суффикс имени файла (те, кто, подобно автору этих строк, затронуты порчей чёрным DOS'ом, до сих пор часто называют его «расширением») к некоей программе, которая может сотворить над ним нужное действо. Например, если задать псевдоним такого вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ alias -s html=links</span> </p>
    <p class="Textbody">а затем набрать в CLI такое</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ path3/некто.html</span> </p>
    <p class="Textbody">то этот самый некто.html будет открыт в текстовом браузере Links.</p>
    <p class="Textbody">Чем, разумеется, возможности «суффиксных» псевдонимов не исчерпываются — как всегда, предел им ставит только фантазия применителя применительно к его задачам. Ограничусь одним примером.</p>
    <p class="Textbody">Какой же русский не любит Командера-полуночника? В том числе и потому, что он — один из сыновей прославленного командера Нортона, имя которого, в свою очередь, не более чем alias незабвенного лейтенанта Шмидта (история его чудесного спасения из лап царской охранки и последующей блестящей карьере сначала в ВМС Пендостана, а затем в интернациональном софтверном бузиненсе реконструирована <a href="http://alv.me/?p=290#1">нашими замечательными историками</a> из славного Екатеринбурга). Впрочем, со временем наш русский применитель, не смотря на весь свой патриотизм, начинает понимать, что слепая любовь к MC связывает ему руки в операциях с возлюбленной CLI, и хорошо бы с командиром расстаться, как это делают цивилизованные люди — без скандалов и истерик.</p>
    <p class="Textbody">Но тут возникает проблема: MC — один из самых удобных способов просмотра того, из чего состоят файлы пакетов (будь то deb, rpm или что ещё из tar.*z-серии). Так вот, механизм «суффиксных» псевдонимов Zsh предлагает нам адекватную замену: если дать команду, например,</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ alias -s deb='dpkg -c'</span> </p>
    <p class="Textbody">а затем набрать в командной строке такое:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ path3/opera-beta_25.0.1614.11_amd64.deb</span> </p>
    <p class="Textbody">то мы сразу увидим, что же припасли для нас разработчики этого многими любимого браузера в своём полуподпольном пре-релизе за нумером 25 (впрочем, за время сочинения этой книги он стал вполне официальным, приобретя номер версии 27):</p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x root/root         0 2014-09-13 03:54 ./</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x root/root         0 2014-09-13 03:54 ./usr/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x root/root         0 2014-09-13 03:54 ./usr/bin/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x root/root         0 2014-09-13 03:54 ./usr/lib/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x root/root         0 2014-09-13 03:54 ./usr/lib/x86_64-linux-gnu/</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">Понятное дело, что аналогичные псевдонимы можно придумать и для всяких rpm-и tgz-пакетов. И, разумеется, наиболее востребованные из них занести в кондуит... то есть в ~/.zshrc.</p>
    <h3 id="toc117"><a id="RefHeading16761713816058"></a><a id="bkmRefHeading16761713816058"></a><a id="toc116"></a><a id="bkmtoc116"></a><a id="RefHeading5201136957987"></a><a id="bkmRefHeading5201136957987"></a><a id="bkmRefHeading5201136957987"></a><a id="bkmbkmRefHeading5201136957987"></a>Конфигурирование</h3>
    <p class="Textbody">В качестве обобщения всего сказанного выше в заключение этого очерка я размещаю свой конфигурационный файл ~/.zshrc, прокомментированный, по мере сил, подробно. Этот конфиг существует с 2001 года, кочуя с машина на машину, из системы в систему, постоянно модернизируюсь в соответствие с изменениями моих потребностей и возможностей Zsh. И в текущем состоянии он обеспечивает все функции и особенности, о которых я говорил ранее, и некоторые другие, которые станут понятными после знакомства с Mint-утилитой пакетного менеджмента apt.</p>
    <p class="Textbody">Данный конфиг может быть использован полностью или фрагментарно всеми заинтересованными лицами: блоки, заключённые в теги &lt;pre&gt;&lt;/pre&gt;, пригодны для прямого копирования, за одним исключением, о котором будет сказано в своё время. Однако я отнюдь не призываю к этому, напротив: настоятельно рекомендую, используя данный конфиг и аналогичные, которые можно найти в Сети, по мере сил и возможности создавать конфиг собственный. Ибо хороший (для конкретного применителя) ~/.zshrc — это не результат, а процесс, и причём процесс преувлекательный.</p>
    <p class="Textbody">Как и большинство уважающих себя конфигов, мой начинается с секции, закрытой комментариями, в которой сообщается, что:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">это ~/.zshrc — то есть «домашний» конфигурационный файл для командной оболочки Zsh; </p>
      </li>
      <li>
        <p class="Textbody">используется только в интерактивных её экземплярах; </p>
      </li>
      <li>
        <p class="Textbody">содержит крманды для определения псевдонимов, функций, опций и прочих кейбиндингов; </p>
      </li>
      <li>
        <p class="Textbody">укладывается в последовательность считывания конфигов таким образом: zshenv, zprofile, zshrc, zlogin. </p>
      </li>
    </ul>
    <p class="Textbody">Всё это <span style="text-decoration:line-through">потибрено</span> унаследовано от прототипа, распространяющегося разрабочиками Zsh. От себя я добавил лишь такую строку:</p>
    <p class="Textbody"><span style="background-color:#dddddd">#</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"># Alv's edition for Mint</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#</span> </p>
    <p class="Textbody">Это не значит, что данный конфиг нельзя использовать вне Mint: подавляющая часть его строк будет иметь силу в любых дистрибутивах Linux'а или в BSD-системах. Но отдельные его блоки (специально оговоренные) в них просто не будут иметь смысла.</p>
    <p class="Textbody">Далее начинается собственно строки определения конфигурируемых параметров. Для удобства восприятия (по крайней мере, моего собственного) они разделены на блоки «целевого назначения». Последовательность блоков, как и строк внутри них, в большинстве случаев рояля не играет, отдельные исключения также оговорены специально.</p>
    <p class="Textbody">Поскольку всё имеет своё начало, начать свой конфиг мне показалось логичным с блока строк, имеющих отношение к истории команд. Перво-наперво — определение числа команд, сохраняемых в буфере во время данного сеанса, имени файла истории, и числа сохраняемых в нём команд:</p>
    <p class="Textbody"><span style="background-color:#dddddd">HISTSIZE=2000</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">HISTFILE=~/.zhistfile</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">SAVEHIST=10000</span> </p>
    <p class="Textbody">Обычно для HISTSIZE и SAVEHIST рекомендуют принимать одинаковые значения (по умолчанию при автоматическом конфигурировании они равны 1000). Однако если действительно трудно представить ввод более чем тысячи команд в течении сеанса, то вот за весь цикл жизнедеятельности оболочки в системе превысить этот лимит достаточно просто.</p>
    <p class="Textbody">Кроме того, надо учесть, что в обоих случаях сохраняются не просто команды, а целые директивы с опциями и аргументами, перенаправлениями и конвейерами, подчас достаточно сложными и редко используемыми. В Zsh имеются очень эффективные механизмы извлечения командных строк из сохранённой истории — не только по именам команд, но и по их опциям и аргументам. Обычно этим мало кто заморчивается, однако в некоторых, пусть и не частых, случаях такие командные конструкции могут потребоваться вторично. И тогда приятно сознавать, что они храняться в файле истории, откуда вытащить их всё равно проще, чем пытаться воспроизвести по памяти или отыскивать аналоги в сети.</p>
    <p class="Textbody">Так что со временем я, увеличив на всякий пожарный случай HISTSIZE вдвое, отвёл под SAVEHIST 10000 строк. Кстати, когда предупреждают о том, что увеличение обоих значений может привести к торможению, следует учитывать, что в памяти постоянно находится только содержимое HISTSIZE, тогда как из SAVEHIST оно извлекается по мере необходимости. Не говоря уже о том, что при типичных для современных машин объёмах памяти об этом просто смешно говорить.</p>
    <p class="Textbody">Имя файла истории я тоже изменяю на ~/.zhistfile. Во-первых потому, что иногда по старой памяти балуюсь Tsch, а в ней файл истории по умолчанию также именуется ~/.histfile (собственно, оттуда он в Zsh и был потибрен, в хорошем смысле этого слова). А во-вторых, просто для удобства восприятия — чтобы все имеющие отношение к Zsh файлы в домашнем каталоге были рядом.</p>
    <p class="Textbody">Однако продолжим наши «исторические» опции. Следующие строки задают условия сохранения команд в файле истории:</p>
    <p class="Textbody"><span style="background-color:#dddddd">setopt  INC_APPEND_HISTORY</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">setopt  HIST_IGNORE_ALL_DUPS</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">setopt  HIST_REDUCE_BLANKS</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">setopt  HIST_IGNORE_SPACE</span> </p>
    <p class="Textbody">Они определяют, соответственно:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">инкрементное наращивание файла истории — без указания этой опции (или одной из однотипных) его прежние команды будут заменены командами текущего сеанса; </p>
      </li>
      <li>
        <p class="Textbody">удаление предыдущих полных дубликатов нововведённых командных конструкций; </p>
      </li>
      <li>
        <p class="Textbody">избавление от пустых строк, возникающих после ошибочного нажатия Enter в «голом» приглашении; </p>
      </li>
      <li>
        <p class="Textbody">удаление лишних пробелов из командной конструкции. </p>
      </li>
    </ol>
    <p class="Textbody">Зачем нужны пункты 2–4 — ясно без комментариев. А вот о пункте 1-м надо сказать несколько слов. Ибо он не просто обеспечивает наращивание файла истории (для этого было бы достаточно опции, APPEND_HISTORY), но делает это в ходе сеанса, не дожидаясь его завершения. В результате команда, введённая в одном терминальном окне или вкладе терминала, будет доступна в истории команд другого терминала или вкладки (хотя и с некоторой задежкой).</p>
    <p class="Textbody">Далее следуют две очень важные строки, определяющие одну из полезнейших возможностей Zsh — тот самый механизм history-substring-search, о котором говорилось ранее:</p>
    <p class="Textbody"><span style="background-color:#dddddd">bindkey "^[[A" up-line-or-search</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">bindkey "^[[B" down-line-or-search</span> </p>
    <p class="Textbody">Следующие две строки касаются уже простого пролистывания истории в командной строке, позволяя делать это клавишами PageUp и PageDown (а не только стрелками Up и Down, которые в этом качестве работают всегда и везде):</p>
    <p class="Textbody"><span style="background-color:#dddddd">bindkey "^[[5~" up-line-or-history</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">bindkey "^[[6~" down-line-or-history</span> </p>
    <p class="Textbody">Этими строками перебрасывается логический мостик к определению кейбиндингов для клавиш, которые в Zsh по умолчанию работают «неправильно» в большинстве терминалов (если не во всех). У меня это Home, End, Delete — их поведение исправляется такими, соответственно, строками:</p>
    <p class="Textbody"><span style="background-color:#dddddd">bindkey "^[OH" beginning-of-line</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">bindkey "^[OF" end-of-line</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">bindkey "^[[3~" delete-char</span> </p>
    <p class="Textbody">Это как раз пример тех строк, которые as is копировать не нужно. Во-первых, в общем случае, могут не работать другие клавиши (скорее, не только эти). Во-вторых же и главных, в более иных терминалах коды тех же клавиш могут быть совсем другими. Какими — легко определить, нажав Control+V, а затем «неправильную» клавишу. Именно таким образом получены коды для Home, End и Delete в системе, в которой сочиняются эти строки.</p>
    <p class="Textbody">Теперь — опции, определяющие магию Zsh при навигации по файловой системе:</p>
    <p class="Textbody"><span style="background-color:#dddddd">cdpath=(/home/current /home/current/alv.me /etc)</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">setopt autocd</span> </p>
    <p class="Textbody">Первая строка позволяет с помощью команды cd переходить в подкаталоги перечисленных каталогов, не набирая никаких путей, ни относительных, ни абсолютных, вторая же — обходиться без команды cd.</p>
    <p class="Textbody">На грани между опциями навигации и автодополнения находятся такие строки:</p>
    <p class="Textbody"><span style="background-color:#dddddd">setopt menucomplete</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zstyle ':completion:*' menu select=1 _complete _ignored _approximate</span> </p>
    <p class="Textbody">Они в паре обеспечивают «менюобразный» вывод списка доступных дополнений по нажатию клавиши табуляции. И это как раз тот случай, когда последовательность строк имеет значение.</p>
    <p class="Textbody">Аналогично и со следующими строками — теми самыми, которые обеспечивают волшебство развёртывания <a href="http://alv.me/?p=6745">сокращённого ввода пути в полный</a>:</p>
    <p class="Textbody"><span style="background-color:#dddddd">autoload -Uz compinit</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">compinit</span> </p>
    <p class="Textbody">Расширенные подстановки и дополнения обеспечиваются вот этими строками:</p>
    <p class="Textbody"><span style="background-color:#dddddd">setopt extendedglob nomatch notify</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zstyle ':completion:*' completer _expand _complete _ignored _correct _approximate</span> </p>
    <p class="Textbody">Строка</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zstyle ':completion:*' use-compctl false</span> </p>
    <p class="Textbody">знаменует собой отречение от старого мира — системы дополнения compctl, в пользу новой системы compsys.</p>
    <p class="Textbody">Строка</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'</span> </p>
    <p class="Textbody">устанавливает равноправие при дополнениях символов нижнего регистра с верхним.</p>
    <p class="Textbody">А строка</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zstyle :compinstall filename '/home/zsh/.zshrc'</span> </p>
    <p class="Textbody">фиксирует файл, в который compinstall (функция автоматического конфигурирования compsys) будет вносить свои изменения при грядущих её вызовах (если они, конечно, будут).</p>
    <p class="Textbody">Пора переходить к псевдонимам. Сначала — серия таковых для команд манипуляции файлами, предписывающие запрос подтверждения на таковые или, напротив, форсированное исполнение, в зависимости от ситуации:</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias mv='mv -i'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias cp='cp -iR'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias cpr='cp -fR'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias rm='rm -i'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias rmf='rm -f'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias rmrf='rm -fR'</span> </p>
    <p class="Textbody">Оказывается, что для одной-единственной команды ls можно придумать больше псевдонимов, чем для всех файломанипулирующих команд, вместе взятых:</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias ls='ls -F'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias ll='ls -lh'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias la='ls -A'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias li='ls -ial'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias lsd='ls -ld *(-/DN)'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias lsa='ls -ld .*'</span> </p>
    <p class="Textbody">На самом деле их можно придумывать ещё и ещё — этот тот необходимый минимум, который я в состоянии запомнить без вреда для рассудка. Расшифровывать псевдонимы не буду — кому надо, и так могут сорвать с них маски, а кто не знает — так ему это и не нужно.</p>
    <p class="Textbody">Далее идёт серия псевдонимов для различных команд и утилит разного назначения. Здесь также расшифровка будет лишней. Ибо они или оболее-менее общеприняты:</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias h=history</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias df='df -h'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias du='du -h'</span> </p>
    <p class="Textbody">Либо обусловлены давними привычками (как, например, more-образный вывод команды less):</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias less='less -M'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias wget='wget -c'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias nano='nano -$'</span> </p>
    <p class="Textbody">Либо связаны со спецификой деятельности:</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias wcl='wc -l'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias wcw='wc -w'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias wcm='wc -m'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias wcc='wc -c'</span> </p>
    <p class="Textbody">Так что можно переходить к следующей убойной фиче Zsh — определению глобальных псевдонимов:</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias -g N='2&gt;/dev/null'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias -g L='|less'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias -g G='|grep'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias -g W='|wc -m'</span> </p>
    <p class="Textbody">Где, впрочем, комментарии тоже излишни.</p>
    <p class="Textbody">А посему перехожу к тем самым дистрибутив-специфическим блокам, которые я предназначил для применения в Mint. Это — псевдонимы для субкоманд её утилиты apt, призванные минимизировать ввод при наиболее частых действиях по пакетному менеджменту:</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias aptin='apt install --yes'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias apter='apt purge'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias aptup='apt update'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias aptug='apt upgrade'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias aptse='apt search'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias aptsh='apt show'</span> </p>
    <p class="Textbody">Псевдонимы для внутренних команд apt из APT также имеет смысл определить, по крайней мере один, для получения списка инсталлированных пакетов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias aptlist='/usr/bin/apt list --installed'</span> </p>
    <p class="Textbody">Смысл этих псевдонимов будет ясен после знакомства с очерком об утилите apt. И в них нет ничего Zsh-специфичного. В отличие от альтернативного метода, основанного на псевдонимах глобальных, которые определяются для соответствующих аргументов команды sudo. Правда, особенность реализации утилиты apt в Mint такова, что она не требует ввода этой команды в явном виде. И потому здесь у меня осталась единственная строка для псевдонима команды добавления репозиториев:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias -g Ar='add-apt-repository'</span> </p>
    <p class="Textbody">Хотя я и утверждал не так давно, что приглашение оболочки — нечто вроде вешалки для театра, сам добрался до этой темы только к концу своего конфига. Однако вот — обычное левосторонне приглашение:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#PROMPT='%B[%n]$=&gt;%b '</span> </p>
    <p class="Textbody">Вторичное приглашение:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#PROMPT2='%i%U&gt; '</span> </p>
    <p class="Textbody">Правостороннее приглашение:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#RPROMPT=' %B[%~]%b '</span> </p>
    <p class="Textbody">А вот это — альтернативы, которыми я баловался во время сочинения раздела про приглашения. Все они начинаются с такой пары строк:</p>
    <p class="Textbody"><span style="background-color:#dddddd">autoload -Uz promptinit</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">promptinit</span> </p>
    <p class="Textbody">После которых вызывается уже одна из конкретных тем:</p>
    <p class="Textbody"><span style="background-color:#dddddd">#prompt fade</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">prompt fade white grey blue</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#prompt clint</span> </p>
    <p class="Textbody">Естественно, что остальные строки должны быть закомментированы.</p>
    <p class="Textbody">Осталось немного — всякая всячина. Например, предотвращение выхода из оболочки после случайного нажатия Control+D в пустой командной строке:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">setopt IGNORE_EOF</span> </p>
    <p class="Textbody">Отключение раздражающего звукового сигнала при ошибках набора:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">setopt NO_BEEP</span> </p>
    <p class="Textbody">Фиксация emacs-образного поведения клавиш (хотя это и так имеет место быть по умолчанию):</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">bindkey -e</span> </p>
    <p class="Textbody">И под занавес — определение пары переменных среды, для начала умолчального пейджера. Хотя я не так давно говорил, что расширенное перенаправление делает его практически не нужным, но, кроме всего прочего, это ещё и средство для просмотра man-страниц:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">export PAGER="less"</span> </p>
    <p class="Textbody">И умолчальный редактор: не смотря на свою любовь к Joe, навыки работы с ним я утратил напрочь, поэтому так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">export EDITOR="nano"</span> </p>
    <p class="Textbody">Вот вроде и всё. Остаётся последний дистрибутив-специфичный стришок — исправление нехорошего поведения history-substring-search в Mint, унаследованного от Ubuntu. А точнее, поведения никакого — эта фича без дополнительных мер просто не работает. Благо меры эти очень просты — создание файла ~/.zshenv с единственной строкой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">DEBIAN_PREVENT_KEYBOARD_CHANGES=yes</span> </p>
    <p class="Textbody">Вот теперь действительно всё — с конфигурированием Zsh «мануальным» способом покончено.</p>
