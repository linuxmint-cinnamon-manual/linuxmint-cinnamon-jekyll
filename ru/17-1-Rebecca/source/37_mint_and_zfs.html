    <h2 id="toc214"><a id="RefHeading18701713816058"></a><a id="bkmRefHeading18701713816058"></a><a id="toc213"></a><a id="bkmtoc213"></a><a id="RefHeading13101136957987"></a><a id="bkmRefHeading13101136957987"></a><a id="bkmRefHeading13101136957987"></a><a id="bkmbkmRefHeading13101136957987"></a>Mint и ZFS</h2>
    <p class="Textbody">Соедующая серия очерков посвящена ZFS — универсальной системе размещёния данных, интегрирующей в себе собственно файловую систему и технологию управления дисковыми массивами и логическими томами. Если softRAID и LVM посвящено множество сетевых материалов, то тема ZFS в Linux'е (так называемая ZFS on Linux) на русском язые освящена существенно слабее. Поэтому я и решил остановиться на ней подробно.</p>
    <h3 id="toc215"><a id="RefHeading18721713816058"></a><a id="bkmRefHeading18721713816058"></a><a id="toc214"></a><a id="bkmtoc214"></a><a id="RefHeading6721136957987"></a><a id="bkmRefHeading6721136957987"></a><a id="bkmRefHeading6721136957987"></a><a id="bkmbkmRefHeading6721136957987"></a>Общее введение</h3>
    <p class="Textbody">Одна из главнейших задач при работе на компьютере — манипулирование данными: создание, модификация, копирование, перемещёние и так далее. И тут первое — это организация их размещёния. Это понятие включает в себя широкий круг частных вопросов — схемы дисковой разметки, управления дисковыми массивами и логическими томами, файловые системы и их монтирование в файловую иерархию. Они тесно связаны между собой, но традиционно решаются каждая с помощью собственного инструментария.</p>
    <p class="Textbody">Однако в последние годы в Linux’е получили распространение интегрированные системы размещёния данных, объединяющие в себе и файловые системы, и задачи управления массивами и томами, и даже, частично, задачи разметки дисков. Такие системы существовали очень давно — со времен доисторического UNIX’а, но были они проприетарными. ZFS же, разработанная фирмой Sun для своей ОС Solaris, ныне распространяется свободно, под лицензией CDDL. Благодаря чему была портирована на FreeBSD, а в последние годы нативно поддерживается и в Linux’е.</p>
    <p class="Textbody">Именно ZFS on Linux и будет героиней нашего романа, и не только в силу своих несравненных достоинств. А во-вторых, развитие проекта ZFS on Linux блестяще демонстрирует торжество инженерного разума над юридической заумью. И потому являет собой просто замечательный литературный сюжет, мимо которого не в силах пройти ни один сочинитель в жанре технологической новеллы. И начать этот сюжет надо издалека.</p>
    <h3 id="toc216"><a id="RefHeading18741713816058"></a><a id="bkmRefHeading18741713816058"></a><a id="toc215"></a><a id="bkmtoc215"></a><a id="RefHeading6741136957987"></a><a id="bkmRefHeading6741136957987"></a><a id="bkmRefHeading6741136957987"></a><a id="bkmbkmRefHeading6741136957987"></a>Дисковая разметка</h3>
    <p class="Textbody">Говорят, что во времена далекие, теперь почти былинные, файловых систем не было: информация на носители записывалась побитно, без всякой организации в именованные её наборы. Впрочем, такой способ записи данных применялся и много позднее — например, при резервном копировании на стриммерные ленты. Можно обходиться без файловых систем и при записи на стандартные блочные устройства — винчестеры, SSD, компакт-диски.</p>
    <p class="Textbody">Однако в большинстве случаев данные на носителях блочного типа организуются в виде файлов, а файлы объединяются в файловые системы — плоские, как в древнем DOS’е, древовидные, как во всех UNIX-подобных операционках, или, так сказать, «многодревные», как в Windows. Каковые могут быть созданы непосредственно на носителе как raw-устройстве, но обычно накладываются на дисковые разделы.</p>
    <p class="Textbody">Исторически сложилось так, что одному разделу соответствовала одна файловая система. Соответственно, и выходить за границы несущего их устройства файловые системы не могли. И если требовалось работать более чем с одной файловой системой на одном физическом накопителе (а в UNIX-подобных ОС это почти всегда так), то был необходим тщательный расчет дискового пространства для каждой из них: ошибки в расчётах влекли весьма неприятные последствия, вплоть до необходимости переразбиения диска и переустановки ОС вообще.</p>
    <p class="Textbody">Правда, дисковые разделы могут не только разделяться, но и объединяться в программные массивы или в группы томов, о которых говорилось в предыдущих очерках.</p>
    <h3 id="toc217"><a id="RefHeading18761713816058"></a><a id="bkmRefHeading18761713816058"></a><a id="toc216"></a><a id="bkmtoc216"></a><a id="RefHeading6761136957987"></a><a id="bkmRefHeading6761136957987"></a><a id="bkmRefHeading6761136957987"></a><a id="bkmbkmRefHeading6761136957987"></a>Файловые системы</h3>
    <p class="Textbody">Как известно ещё с советских атеистических времен, Господь Бог, создавая человека, хотел сделать его умным, честным и партийным. Но оказалось, что даже он, при всём своём всемогуществе, не смог ему дать больше двух качеств вместе.</p>
    <p class="Textbody">Аналогично и с файловыми системами: разработчики хотели бы видеть их быстрыми, надежными и простыми в обращении. Давайте посмотрим, удалось ли им превзойти Господа.</p>
    <p class="Textbody">В UNIX-подобных системах требование быстродействия удовлетворяется, во-первых, оптимизированным расположением каталогов, метаданных и данных файлов на физических носителях. Но во-вторых и главных — кэшированием записи.</p>
    <p class="Textbody">Думаю, каждого, кто начинал знакомство с Linux’ом во времена безраздельного господства файловой системы ext2fs, поражала быстрота выполнения всех файловых операций, обусловленная их асинхронностью — то есть кэшированием данных и метаданных. Оборотная сторона медали — отказ системы по любой причине влёк за собой тяжкие последствия, вплоть до полного ее разрушения. Но и даже когда до полной катастрофы дело не доходило, отказы (например, по питанию) вызывали за собой долгую и нудную процедуру проверки целостности файловой системы.</p>
    <p class="Textbody">Были разработаны различные механизмы решения этой проблемы. Однако основным в Linux стало так называемое журналирование, когда сведения о файловых операциях записываются в специальный файл журнала до того, как эти операции будут фактически выполнены. Это дает возможность после любого сбоя «откатить» файловую систему до последнего непротиворечивого состояния. Оборотной стороной чего, как обычно, является снижение быстродействия — различное для отдельных файловых систем и видов файловых операций.</p>
    <p class="Textbody">Правда, с точки зрения простоты использования ни в одну из файловых систем Linux’а бросить камень рука не подымется: создание и монтирование их никаких трудностей не сулит. Так что требование «партийности» выполняется, пожалуй, при всех соотношениях «ума» и «честности». Но эта ситуация сохраняется, пока мы не начинаем комбинировать «ум, честность и партийность» файловых систем с аналогичными качествами систем управления RAID’ами или с LVM. В результате чего получаем:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">либо быстрое и относительно простое решение на основе RAID Level 0, не блещущее надёжностью; </p>
      </li>
      <li>
        <p class="Textbody">либо надёжное решение без ощутимой потери быстродействия на основе одного из RAID с избыточностью, не являющееся, однако, эталоном простоты; </p>
      </li>
      <li>
        <p class="Textbody">либо, наконец, относительно надёжное и потенциально быстрое решение при использовании технологии LVM — однако и оно не блещёт простотой. </p>
      </li>
    </ul>
    <p class="Textbody">Ибо все эти решения — многоуровневые. И очевидно, что удлинение «цепочки» уровней в любом случае приводит к снижению надежности: чем больше в ней звеньев, тем вероятней отказ всей цепи.</p>
    <p class="Textbody">И тут-то и возникает вопрос: а нельзя ли уменьшить количество уровней, сделать систему более «плоской»? И системы размещёния данных, в том числе и ZFS — попытка ответа на него.</p>
    <h3 id="toc218"><a id="RefHeading18781713816058"></a><a id="bkmRefHeading18781713816058"></a><a id="toc217"></a><a id="bkmtoc217"></a><a id="RefHeading6781136957987"></a><a id="bkmRefHeading6781136957987"></a><a id="bkmRefHeading6781136957987"></a><a id="bkmbkmRefHeading6781136957987"></a>Из истории систем размещёния</h3>
    <p class="Textbody">Не в интересах правды, а истины ради нужно заметить, что ZFS была отнюдь не первой комплексной системой размещёния данных — хотя её исторические предшественницы также именовались просто файловыми системами.</p>
    <p class="Textbody">Первой из таких предшественниц была, видимо, файловая система Veritas (или VxFS), разработанная фирмой Veritas Software и представленная миру в 1991 году. Она же претендует на звание первой в истории мироздания журналируемой файловой системы. Хотя, насколько мне известно, JFS — эпоним всех журналируемых ФС — в своей реализации для AIX появилась в 1990 году, так что вопрос приоритета остаётся не вполне ясным.</p>
    <p class="Textbody">VxFS была основной файловой системой в HP UX, работает также во всех ныне живущих проприетарных UNIX’ах и теоретически может использоваться в Linux’е. Однако о практических примерах последнего я не слышал: VxFS является системой проприетарной и весьма дорогой.</p>
    <p class="Textbody">VxFS тесно интегрирована с менеджером логических томов — VxVM. Благодаря чему в ней возможно изменение (в любую сторону) размера файловой системы «на лету», включение различных режимов использования томов — стриппинг данных, их зеркалирование, а также комбинации того и другого, создание избыточных массивов по типу RAID Level 5, изменение внутренней организации данных без остановки работы. Всё это позволяет VxFS (в сочетании с VxVM) претендовать на звание комплексной системы размещёния данных.</p>
    <p class="Textbody">Впрочем, не меньше к тому оснований было и у AdvFS — файловой системы, разработанной к 1993 году фирмой DEC для своего проприетарного варианта UNIX, именовавшегося сначала OSF/1, затем Digital UNIX, и завершившего свою жизнь под именем Tru64 UNIX. Судьба её была печальной. Снискав заслуженное признание на своей родной платформе DEC Alpha под управлением указанной ОС, она после покупки DEC фирмой Compaq оказалась в загоне. А после того, как Compaq, в свою очередь, был поглощён фирмой Hewlett Packard, использовавшей для своего UNIX’а на платформах HP PA и Itanium только что упомянутую VxFS, AdvFS оказалась совсем не при делах.</p>
    <p class="Textbody">В результате HP сделала щедрый дар сообществу свободного софта вообще и Linux-сообществу в особенности: в середине 2008 года исходники файловой системы AdvFS были открыты под лицензией GPv2 — ради максимальной совместимости с ядром Linux. С предложением использовать их в качестве богатой технологической базы для этой ОС. Правда, оговорка, что сама HP не заинтересована в дальнейшем развитии AdvFS заставляла вспомнить народную присказку: «Возьми, боже, что мне не гоже».</p>
    <p class="Textbody">Да и предложение несколько запоздало: как мы скоро увидим, к тому времени интенсивно развивались и ZFS, и btrfs.</p>
    <p class="Textbody">Однако, помимо исходников, HP предоставила также доступ ко всей документации — благодаря чему об AdvFS при желании можно узнать больше, чем о любой другой проприетарной файловой системе для UNIX-подобных операционок. Это избавляет меня от необходимости описания особенностей AdvFS. Замечу только, что среди них мы увидим все черты развитой комплексной системы размещёния данных. Те самые, с которыми ознакомимся, когда дело дойдёт наконец до рассмотрения устройства ZFS. Но для начала перейдём к обзору уже её истории.</p>
    <h3 id="toc219"><a id="RefHeading18801713816058"></a><a id="bkmRefHeading18801713816058"></a><a id="toc218"></a><a id="bkmtoc218"></a><a id="RefHeading6801136957987"></a><a id="bkmRefHeading6801136957987"></a><a id="bkmRefHeading6801136957987"></a><a id="bkmbkmRefHeading6801136957987"></a>Начало истории ZFS</h3>
    <p class="Textbody">Разработчики ZFS поставили себе честолюбивую цель: создать систему хранения данных, которая отвечала бы всем трем критериям идеала. Разработка её проводилась в компании Sun Microsystems, командой под руководством Джеффа Бонвика и Мэттью Аренса (Matthew Ahrens). Первоначально название ZFS рассматривалось как аббревиатура от Zettabyte File System, но быстро стало просто условным именованием. Его можно интерпретировать как последнюю точку в развитии файловых систем вообще. И в последующем мы увидим: это недалеко от истины.</p>
    <p class="Textbody">Результаты работы над ZFS были представлены миру в августе 2004 года. А в 2006 году она была включена в штатный состав OS Solaris 10 (релиз 6/06). То есть, подобно своим предшественницам, она также была проприетарным продуктом. И пользователям свободных UNIX-подобных систем поначалу от ее существования было ни холодно, ни жарко. Однако период камерного существования ZFS продолжался недолго — уже в ноябре 2005 года, то есть до включения в Solaris, ее поддержка была интегрирована в открытый её вариант, OpenSolaris. Ибо она основывалась на том же ядре SunOS 5, что и коммерческий прототип.</p>
    <p class="Textbody">Исходники ZFS распространяются, как и собственно OpenSolaris, под лицензией CDDL (Common Development and Distribution License). Эта лицензия, базирующаяся на Mozilla Public License (MPL), не влияет на общую лицензию проекта, в состав который включены CDDL-компоненты. И потому оказывается совместимой с большинством свободных лицензий. За исключением... какой? Правильно, GPL во всех её проявлениях.</p>
    <p class="Textbody">Разумеется, ZFS была задействована в клонах openSolaris, таких, как BeleniX, SchilliX и, в первую голову, в Nexenta OS. Правда, последняя развивалась в направлении коммерческой системы хранения данных, а о числе пользователей остальных можно было только гадать.</p>
    <p class="Textbody">Некоторое время ZFS была доступна пользователям Macintosh’а — в Mac OS X Leopard от осени 2007 года. Правда, ходившие перед её выходом слухи, что она будет там файловой системой по умолчанию, оказались несколько преувеличенными: поддержка ZFS оказалась опциональной и лишь в режиме «только для чтения». А в последующих версиях семейства кошачьих вообще исчезла и, видимо, уже не возродится.</p>
    <p class="Textbody">Так что для широких народных масс ZFS по прежнему оставалась недоступной. Пока... пока ее не портировали под FreeBSD в 2007 году, и официально не включили её поддержку в 7-ю версию этой ОС, вышедшую в начале 2008 года. В чём, как и в дальнейшем её развитии, основная заслуга принадлежит Павлу-Якубу Давидеку (Pawel Jakub Dawidek) и Ивану Ворасу (Ivan Voras). Правда, до недавнего времени ZFS нельзя было задействовать при установке FreeBSD средствами её штатного инсталлятора и конфигуратора sysinstall. Однако это без труда можно было осуществить в дальнейшем руками. В том числе и разместить на ZFS корень файловой иерархии.</p>
    <p class="Textbody">С самого начала поддержки ZFS во FreeBSD появилась и возможность задействовать её, что называется, «искаропки», в десктоп-ориентированном клоне последней — PC-BSD. А с переходом FreeBSD, начиная с версии 9.0, на новую программу установки — BSDInstall, эта функция распространилась и на материнскую систему.</p>
    <p class="Textbody">Успех ZFS во FreeBSD, где она стала если не главной файловой системой, то добилась равноправия с UFS2, послужил примером для других BSD-систем. Так, ныне ZFS поддерживается в NetBSD — эта работа была начата Оливером Голдом (Oliver Gould) летом 2007 года в рамках акции Google Summer of Code. А в 2009 году Адам Хамсик (Adam Hamsik) интегрировал её код в ядро NetBSD. Правда, использование ZFS в этой операционке рекомендуется только в экспериментальных целях.</p>
    <p class="Textbody">Наконец, одно время в списках рассылки DragonFlyBSD активно обсуждался вопрос о портировании ZFS и на эту операционку. Потом, правда, разговоры эти стихли — вероятно, в связи с активной разработкой файловой системы Hammer, обладающей во многом аналогичными возможностями. Однако, учитывая лёгкость адаптации к DragonFlyBSD любых сторонних файловых систем, можно не сомневаться, что поддержка ZFS на уровне обмена данными будет включена в неё тогда и если (или если и тогда), когда (и если) это кому-то понадобится.</p>
    <p class="Textbody">Таким образом, пользователям большинства BSD-систем ZFS или уже доступна как нативная, или может стать доступной в ближайшее время.</p>
    <h3 id="toc220"><a id="RefHeading18821713816058"></a><a id="bkmRefHeading18821713816058"></a><a id="toc219"></a><a id="bkmtoc219"></a><a id="RefHeading6821136957987"></a><a id="bkmRefHeading6821136957987"></a><a id="bkmRefHeading6821136957987"></a><a id="bkmbkmRefHeading6821136957987"></a>Из истории юриспруденции</h3>
    <p class="Textbody">А что же Linux, спросите вы меня? Как обстоит дело с поддержкой ZFS в самой массовой из свободных UNIX-подобных операционных систем нашего времени? А вот с Linux’ом все оказывается гораздо сложнее. Ибо не зря поминали мы выше лицензию CDDL. Которая сама по себе очень даже свободная, и не накладывает почти никаких ограничений на распространение защищаемых ею программ.</p>
    <p class="Textbody">В частности, не запрещает CDDL и коммерческого распространения производных продуктов в виде бинарников, без открытия исходных текстов. Как известно, не накладывает такого ограничения и лицензия BSD, почему включение кода поддержки ZFS в любые BSD-системы и проходит юридически безболезненно, как мы только что видели на примере FreeBSD.</p>
    <p class="Textbody">А вот с лицензией GPL обеих актуальных версий (v2 и v3) CDDL входит в диалектическое противоречие. Ибо любые продукты, производные от программ под GPL, вне зависимости от формы распространения, должны сопровождаться исходными текстами. Что делает юридически невозможным включение кода поддержки ZFS непосредственно в ядро Linux, распространяемое, как известно, на условиях GPLv2.</p>
    <p class="Textbody">Кроме того, невозможность включения в ядро Linux кода поддержки ZFS объясняется тем, что GPL требует распространения всех основанных на ней продуктов под GPL же, тогда как CDDL — сохранения её для «своих» компонентов.</p>
    <p class="Textbody">Правда, часть кода ZFS была открыта под GPL с тем, чтобы соответствующий патч можно было включить в загрузчик GRUB. Это обеспечило возможность загрузки Open Solaris непосредственно с ZFS-раздела. Однако оказалось недостаточным для полноценной реализации этой системы, которую можно было бы распространять под данной лицензией.</p>
    <p class="Textbody">Впрочем, не будучи юристом, ломать голову над лицензионными вопросами не буду, и моим читателям не советую, ибо понять это всё равно невозможно. А достаточно лишь запомнить, что всеми резонными и юридически подкованными людьми признано, что поддержки ZFS в ядре Linux быть не может.</p>
    <p class="Textbody">Таким образом, сложилась абсурдная, с точки зрения здравого смысла, ситуация: два программных продукта под свободными лицензиями (обсуждать вопрос, какая из них «свободней другой», мы сейчас не будем), созданные друг для друга, как Huggies и... э-ээ... место пониже спины (дальнейшие события показали, что технических сложностей при портировании ZFS на Linux практически нет), невозможно было использовать в составе одного проекта. По крайней мере, для законопослушных граждан, чтущих... нет, не уголовный кодекс, а принципы свободного программного обеспечения.</p>
    <p class="Textbody">И, разумеется, здравомыслящие люди попытались эту ситуацию разрешить. И первая такая попытка была предпринята ещё в 2006 году в рамках Google Summer of Code. Основывалась она на поддержке ZFS через FUSE (Filesystem in Userspace). Поскольку модуль FUSE работает как пользовательское приложение, необходимости во включение кода ZFS в ядро Linux нет, что снимает все юридические вопросы. Однако встают вопросы другие — производительности и устойчивости.</p>
    <p class="Textbody">Проект ZFS-FUSE развивается по сей день, хотя и не очень быстрыми темпами. Правда, находясь в стадии хронической бета-версии, он до сих пор рассматривается как сугубо экспериментальный. Да и в любом случае в таком виде ZFS выполнять свои функции — быть надёжным хранилищем данных большого объёма — скорее всего, не сможет.</p>
    <p class="Textbody">Так что ZFS-FUSE нельзя считать кардинальным решением вопроса с этой системой размещёния данных в Linux.</p>
    <h3 id="toc221"><a id="RefHeading18841713816058"></a><a id="bkmRefHeading18841713816058"></a><a id="toc220"></a><a id="bkmtoc220"></a><a id="RefHeading6841136957987"></a><a id="bkmRefHeading6841136957987"></a><a id="bkmRefHeading6841136957987"></a><a id="bkmbkmRefHeading6841136957987"></a>Появление героини</h3>
    <p class="Textbody">И тем не менее, решение этой проблемы нашлось — и решение столь же изящное, сколь и очевидное. Его предложил весной 2010 года Брайан Белендорф, некогда один из основных разработчиков web-сервера Apache. Он создал модуль поддержки ZFS, который собирается и может распространяться отдельно от ядра, сохраняя прародительскую лицензию CDDL. А поскольку последняя, как уже говорилось, является лицензией «пофайловой», этим самым обходится антагонистическое противоречие — запрет на распространение продуктов, в которых смешан код, лицензируемый под CDDL и GPL.</p>
    <p class="Textbody">На базе разработки Брайана возникло сразу два проекта. Первый осуществлялся индийской компанией KQ Infotech, которой уже в сентябре 2010 года удалось выпустить работоспособный, пригодный для тестирования Linux-ядра с реализацией файловой системы ZFS. А в январе следующего, 2011, года появилась финальная его версия, доступная тогда в исходниках и в виде двоичных пакетов для Fedora 14, RHEL6, Ubuntu 10.04 и 10.10.</p>
    <p class="Textbody">Однако весной того же года KQ Infotech была куплена фирмой STEC, занимающейся производством SSD-накопителей, каковых, впрочем, в наших палестинах мало кто видел. И работы по дальнейшему развитию нативной поддержки ZFS были свёрнуты. Хотя исходники модуля и сопутствующих компонентов до сих пор доступны, последнее их обновление происходило более года назад. А информации о дальнейшей судьбе проекта с тех пор не появлялось.</p>
    <p class="Textbody">Второй проект реализовывался самим Брайном вместе с сотрудниками Ливерморской национальной лаборатории, каковая, будучи в подчинении Министерства энергетики США, занимается не только вопросами ядерного оружия (эвфемизмы вроде Минсредмаша в ходу не только в бывшем Советском Союзе), но и разработкой суперкомьютеров. В результате скоро возник проект ZFS on Linux — ZFS on Linux, в рамках которого модуль поддержки ZFS и сопутствующие утилиты поддержки, портированные из Solaris — так называемый SPL (Solaris Porting Layer), были доведены до ума, и к началу 2011 года стали пригодны для использования в экспериментальном режиме. А к настоящему времени, несмотря на формальное сохранение статуса release candidatе, порт ZFS on Linux можно считать готовым к практическому применению.</p>
    <p class="Textbody">Правда, майнтайнеры основных дистрибутивов не торопились включать поддержку ZFS в свои системы даже в качестве дополнительных неофициальных пакетов. Подозреваю, что не столько из косности и лени, сколько из-за очередной сложности: видимо, по всё тем же лицензионным ограничениям модули zfs и spl приходится привязывать к фиксированной версии (и даже конкретной сборке) ядра Linux. Что, при регулярных, даже корректирующих, обновлениях последнего требует и их пересборки.</p>
    <p class="Textbody">Тем не менее, разработчики проекта воплотили результаты своей работы в виде PPA-репозитория для Ubuntu. Каковым без проблем могут пользоваться и применители Mint.</p>
    <h3 id="toc222"><a id="RefHeading18861713816058"></a><a id="bkmRefHeading18861713816058"></a><a id="toc221"></a><a id="bkmtoc221"></a><a id="RefHeading6861136957987"></a><a id="bkmRefHeading6861136957987"></a><a id="bkmRefHeading6861136957987"></a><a id="bkmbkmRefHeading6861136957987"></a>Обзор возможностей</h3>
    <p class="Textbody">Прежде чем погружаться в вопросы, связанные с ZFS, читатель, вероятно, хотел бы убедиться в том, что это стоит делать. То есть — ознакомиться с возможностями, которые она ему предоставляет.</p>
    <p class="Textbody">Для начала — немного цифр. В отличие от всех предшествовавших файловых систем и систем размещёния данных, ZFS является 128-битной. То есть теоретическое ограничение на её объём и объёмы её составляющих превышают не только реальные, но и воображаемые потребности любого пользователя. По выражению создателя ZFS, Джеффа Бонвика, для её заполнения данными и их хранения потребовалось бы вскипятить океан.</p>
    <p class="Textbody">Так, объём пула хранения данных (zpool — максимальная единица в системе ZFS) может достигать величины 3×1023 петабайт (а один петабайт, напомню, это 1015 или 250 байт, в зависимости от системы измерения). Каждый пул может включать в себя до 264 устройств (например, дисков), а всего пулов в одной системе может быть тоже не больше 264.</p>
    <p class="Textbody">Пул может быть разделён на 264 наборов данных (dataset — в этом качестве выступают, например, отдельные файловые системы), по 264 каждая. Правда, ни одна из таких файловых систем не может содержать больше 248 файлов. Зато размер любого файла ограничивается опять же значением в 264 байт.</p>
    <p class="Textbody">Количество таких ограничений можно умножить. Как уже было сказано, они лежат вне пределов человеческого воображения. И привожу я их только для того, чтобы вселить в пользователя уверенность: ни он сам, ни его внуки и правнуки в реальности не столкнутся c ограничениями на размер файловой системы или отдельного файла, как это бывало при использовании FAT или ext2fs.</p>
    <p class="Textbody">Так что перейду к особенностям ZFS, наиболее интересным, по моему мнению, десктопному пользователю. Здесь в первую очередь надо отметить гибкое управление устройствами. В пул хранения данных можно объединить произвольное (в обозначенных выше пределах) число дисков и их разделов. Устройства внутри пула могут работать в режиме расщепления данных, зеркалирования или избыточности с подсчётом контрольных сумм, подобно RAID’ам уровней 0, 1 и 5, соответственно. В пул можно включать накопители, специально предназначенные для кэширования дисковых операций, что актуально при совместном использовании SSD и традиционных винчестеров.</p>
    <p class="Textbody">Пул хранения становится доступным для работы сразу после его создания, без рестарта машины. В процессе работы дополнительные диски или разделы, в том числе и устройства кэширования, могут как присоединяться к пулу, так и изыматься из его состава в «горячем» режиме.</p>
    <p class="Textbody">Пул хранения может быть разделён на произвольное количество иерархически организованных файловых систем. По умолчанию размер их не определяется, и растёт по мере заполнения данными. Это избавляет пользователя от необходимости расчёта места, потребного под системные журналы, домашние каталоги пользователей и другие трудно прогнозируемые вещи. С другой стороны, не запрещёно при необходимости и квотирование объёма отдельных файловых систем — например, домашних каталогов отдельных излишне жадных пользователей.</p>
    <p class="Textbody">Файловые системы ZFS также доступны для размещёния на них данных сразу после создания, никаких специальных действий по обеспечению их монтирования не требуется. Создание файловых систем внутри пула — процесс предельно простой: разработчики стремились сделать его не сложнее создания каталогов, и это им вполне удалось. Но при этом составляющие пула остаются именно самостоятельными файловыми системами, которые могут монтироваться со своими специфическими опциями, в зависимости от назначения.</p>
    <p class="Textbody">Среди других возможностей ZFS, интересных настольному пользователю, можно упомянуть:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">создание снапшотов файловой системы, позволяющих восстановить её состояние в случае ошибки; </p>
      </li>
      <li>
        <p class="Textbody">клонирование файловых систем; </p>
      </li>
      <li>
        <p class="Textbody">компрессия данных файловой системы и дедупликация (замена повторяющихся данных ссылками на «первоисточник»); </p>
      </li>
      <li>
        <p class="Textbody">создание нескольких копий блоков с критически важными данными и, напротив, возможность отключения проверки контрольных сумм для повышения скорости доступа к ним. </p>
      </li>
    </ul>
    <p class="Textbody">В общем, даже если не говорить об быстродействии ZFS (а оно весьма высоко, особенно в многодисковых конфигурациях), перечислять её достоинства можно очень долго. Так долго, что поневоле успеваешь задаться вопросом: а есть ли у неё недостатки?</p>
    <p class="Textbody">Разумеется, есть. Хотя большая их часть — скорее особенности: например, ограничения при добавлении или удалении накопителей в пуле, или отсутствие поддежки TRIM.</p>
    <p class="Textbody">По большому счёту для пользователя Linux’а у ZFS обнаруживается два кардинальных недостатка: некоторая усложнённость её использования, обусловленная юридическими факторами, и высокие требования к аппаратуре.</p>
    <p class="Textbody">Первый недостаток если не ликвидирован, то сглажен трудами Брайана Белендорфа (Brian Behlendorf) со товарищи и майнтайнерами прогрессивных дистрибутивов вкупе с примкнувшими к ним независимыми разработчиками. Аппаратные же претензии ZFS мы сейчас и рассмотрим.</p>
    <h3 id="toc223"><a id="RefHeading18881713816058"></a><a id="bkmRefHeading18881713816058"></a><a id="toc222"></a><a id="bkmtoc222"></a><a id="RefHeading6881136957987"></a><a id="bkmRefHeading6881136957987"></a><a id="bkmRefHeading6881136957987"></a><a id="bkmbkmRefHeading6881136957987"></a>Аппаратные потребности</h3>
    <p class="Textbody">Итак, ZFS предоставляет пользователю весьма много возможностей. И потому вправе предъявлять немало претензий к аппаратной части — процессору (изобилие возможностей ZFS создает на него достаточную нагрузку), оперативной памяти и дисковой подсистеме.</p>
    <p class="Textbody">Впрочем, претензии эти отнюдь не сверхъестественные. Так, процессор подойдёт любой из относительно современных, начиная, скажем, с Core 2 Duo. Минимальный объём памяти определяется в 2 ГБ, с оговоркой, что применение компрессии и дедупликации требуют 8 ГБ и более.</p>
    <p class="Textbody">Сама по себе ZFS прекрасно функционирует и на одиночном диске. Однако в полном блеске показывает себя при двух и более накопителях. В многодисковых конфигурациях рекомендуется разнесение накопителей на разные контроллеры: современные SSD способны полностью загрузить все каналы SATA-III, и равномерное распределение нагрузки на пару контроллеров может увеличить быстродействие.</p>
    <p class="Textbody">К «железным» претензиям добавляются и притязания программные. В первую очередь, ZFS on Linux требует 64-битной сборки этой ОС, поскольку в 32-разрядных системах действует ограничение на адресное пространство физической памяти. Кроме того, в конфигурации ядра должнв быть отключена опция CONFIG_PREEMPT.</p>
    <p class="Textbody">Если вас привлекли достоинства ZFS и не устрашили её «железные» аппетиты, самое время опробовать её в деле. Что потребует знакомства с некоторыми специфическими понятиями.</p>
    <h3 id="toc224"><a id="RefHeading18901713816058"></a><a id="bkmRefHeading18901713816058"></a><a id="toc223"></a><a id="bkmtoc223"></a><a id="RefHeading6901136957987"></a><a id="bkmRefHeading6901136957987"></a><a id="bkmRefHeading6901136957987"></a><a id="bkmbkmRefHeading6901136957987"></a>Терминология</h3>
    <p class="Textbody">Центральным понятием ZFS является пул хранения данных (zpool). В него может объединяться несколько физических устройств хранения — дисков или дисковых разделов, причём первый вариант рекомендуется. Но не запрещёно и создание пула из одного диска или его раздела.</p>
    <p class="Textbody">Каждый пул состоит из одного или нескольких виртуальных устройств (vdev). В качестве таковых могут выступать устройства без избыточности (то есть всё те же диски и/или их разделы), или устройства с избыточностью — зеркала и массивы типа RAID-Z:</p>
    <p class="Textbody">Зеркальное устройство (mirror) — виртуальное устройство, хранящее на двух или более физических устройствах, но при чётном их количестве, идентичные копии данных на случай отказа диска;</p>
    <p class="Textbody">RAID-Z — виртуальное устройство из нескольких устройств физических, предназначенное для хранения данных и их контрольных сумм с однократным или двойным контролем чётности. В первом случае теоретически требуется не менее двух, во втором — не менее трёх физических устройств.</p>
    <p class="Textbody">Если пул образован устройствами без избыточности (просто дисками или разделами), то одно из vdev, соответствующее ему целиком, выступает в качестве корневого устройства. Пул из устройств с избыточностью может содержать более одного корневого устройства — например, два зеркала.</p>
    <p class="Textbody">Пулы, образованные виртуальными устройствами, служат вместилищем для наборов данных (dataset). Они бывают следующих видов:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">файловая система (filesystem) — набор данных, смонтированный в определённой точке и ведущий себя подобно любой другой файловой системе; </p>
      </li>
      <li>
        <p class="Textbody">снапшот (snapshot) — моментальный снимок текущего состояния файловой системы, доступный только для чтения; </p>
      </li>
      <li>
        <p class="Textbody">клон (clone) — точная копия файловой системы в момент его создания; создаётся на основе снимка, но, в отличие от него, доступен для записи; </p>
      </li>
      <li>
        <p class="Textbody">том (volume) — набор данных, эмулирующий физическое устройство, например, раздел подкачки. </p>
      </li>
    </ul>
    <p class="Textbody">Наборы данных пула должны носить уникальные имена такого вида:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd">pool_name/path/(dataset_name)(@snapshot_name) </span>
    </p>
    <p class="Textbody">Пулы и наборы данных в именуются по правилам пространства имён ZFS, впрочем, довольно простым. Запрещёнными символами для всех являются символы подчёркивания, дефиса, двоеточия, точки и процента. Имя пула при этом обязательно должно начинаться с алфавитного символа и не совпадать с одним из зарезервированных имён — log, mirror, raidz или spare (последнее обозначает имя устройства «горячего» резерва). Все остальные имена, в соответствие с демократическими традициями пространства имён ZFS, разрешены.</p>
    <p class="Textbody">А вот об именах физических устройств, включаемых в пул, следует сказать особо.</p>
    <h3 id="toc225"><a id="RefHeading18921713816058"></a><a id="bkmRefHeading18921713816058"></a><a id="toc224"></a><a id="bkmtoc224"></a><a id="RefHeading6921136957987"></a><a id="bkmRefHeading6921136957987"></a><a id="bkmRefHeading6921136957987"></a><a id="bkmbkmRefHeading6921136957987"></a>Модели именования устройств</h3>
    <p class="Textbody">В современном Linux’е использование для накопителей имён «верхнего уровня», имеющих вид /dev/sda, не является обязательным, а в некоторых случаях и просто нежелательно. Однако правила менеджера устройств udev позволяют определять и другие модели идентификации накопителей:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">метке тома (/dev/disk/by-label); </p>
      </li>
      <li>
        <p class="Textbody">идентификатору диска (/dev/disk/by-id); </p>
      </li>
      <li>
        <p class="Textbody">пути к дисковому устройству (/dev/disk/by-path); </p>
      </li>
      <li>
        <p class="Textbody">универсальному уникальному идентификатору, Universally Unique IDentifier (/dev/disk/by-uuid). </p>
      </li>
    </ul>
    <p class="Textbody">А с полным списком вариантов идентификации блочных устройств можно ознакомиться, просмотрев имена подкаталогов в каталоге /dev/disk, их содержимое — это символические ссылки на имена «верхнего уровня».</p>
    <p class="Textbody">С идентификацией по метке тома и по UUID, вероятно, знакомо большинство читателей. И к тому же в пространстве имён ZFS они не используются. А вот с идентификацией by-path и by-id нужно познакомиться поближе.</p>
    <p class="Textbody">Модель именования by-path использует имена устройств, привязанные к их положению на шине PCI и включающие номер шины и канала на ней. Имя дискового устройства выглядит примерно так:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd">pci-0000:00:1f.2-scsi-0:0:0:0 </span>
    </p>
    <p class="Textbody">Дисковые разделы маркируются добавлением к имени устройства суффикса part#.</p>
    <p class="Textbody">Модель именования by-path идентифицирует устройства вполне однозначно, и особенно эффективна при наличии более чем одного дискового контроллера. Однако сами имена и устройств, и разделов описываются довольно сложной для восприятия последовательностью. Да и в большинстве «десктопных» ситуаций модель эта избыточна.</p>
    <p class="Textbody">Модель идентификации by-id представляет имена носителей информации в форме, наиболее доступной для человеческого понимания. Они образованы из названия интерфейса, имени производителя, номера модели, серийного номера устройства и, при необходимости, номера раздела, например:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd">ata-SanDisk_SDSSDX120GG25_120823400863-part1 </span>
    </p>
    <p class="Textbody">Таким образом, все компоненты имени устройства в модели by-id определяются не условиями его подключения или какими-то правилам, а задаются производителем и жёстко прошиты в «железе». И потому эта модель является наиболее однозначной для именования устройств. А также, что немаловажно, строится по понятной человеку логике.</p>
    <p class="Textbody">Какую из моделей именования устройств выбрать для данного пула — зависит от его назначения и масштабов. Имена «верхнего уровня» целесообразно применять для однодисковых пулов (особенно если в машине второго диска нет и не предвидится). Они же, по причине простоты и удобопонятности, рекомендуются для экспериментальных и разрабатываемых пулов. И очень не рекомендуются — во всех остальных случаях, так как зависят от условий подключения накопителей.</p>
    <p class="Textbody">Этого недостатка лишена модель by-id: как пишет Брайан, при её использовании «диски можно отключить, случайно смешать и подключить опять произвольным образом — и пул будет по-прежнему корректно работать». Как недостаток её рассматривается сложность конфигурирования больших пулов с избыточностью. И потому она рекомендуется для применения в «десктопных» и «квартирных» (типа семейного сервера) условиях.</p>
    <p class="Textbody">Для больших (более 10 устройств) пулов из дисков, подключённых к нескольким контроллерам, рекомендуется идентификация by-path. Однако в наших целях она громоздка и избыточна.</p>
    <p class="Textbody">Наконец, ZFS on Linux предлагает и собственную модель идентификации — /dev/disk/zpool, в котором именам by-path ставятся в соответствие уникальные и осмысленные «человекочитаемые» имена, даваемые пользователем. Модель эта рекомендуется для очень больших пулов, каковых на настольной машине ожидать трудно.</p>
    <p class="Textbody">Так что дальше я буду использовать имена «верхнего уровня», говоря об абстрактных или экспериментальных ситуациях, и об именах by-id, когда речь зайдёт о практических примерах применения ZFS.</p>
    <h3 id="toc226"><a id="RefHeading18941713816058"></a><a id="bkmRefHeading18941713816058"></a><a id="toc225"></a><a id="bkmtoc225"></a><a id="RefHeading6941136957987"></a><a id="bkmRefHeading6941136957987"></a><a id="bkmRefHeading6941136957987"></a><a id="bkmbkmRefHeading6941136957987"></a>Включение поддержки ZFS в Mint</h3>
    <p class="Textbody">Для практического использования ZFS on Linux перво-наперво необходимо обеспечить её поддержку в вашем дистрибутиве — ибо по причинам, описанным ранее, сама собой она не поддержится ни в одном Linux’е.</p>
    <p class="Textbody">Как это сделать, зависит от дистрибутива. В Сети можно найти подробные инструкции для Ubuntu, которые легко распространяются на все производные от неё системы, в том числе и на Mint.</p>
    <p class="Textbody">Как уже было сказано, пакеты поддержки ZFS представлены в PPA-репозитори, где они реализованы в виде сценариев dkms, предполагающих сборку модулей под текущую версию ядра. Пакеты эти объединены в метапакет zfs-native, существующий в двух варианта — <a href="https://launchpad.net/%7Ezfs-native/+archive/ubuntu/stable»%20target=">ZFS Stable Releases</a> и <a href="https://launchpad.net/%7Ezfs-native/+archive/ubuntu/daily»%20target=">ZFS Daily Releases</a>, то есть стабильной и тестовой сборках, соответственно.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_229.png">
        <img alt="Изображение578" class="frameGraphics" id="578graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_229-572x470.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:471.82745px" />
      </a>
      <a id="a580graphic"></a>
      <a id="bkm580graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_229.png"> </a>
    </p>
    <p class="Textbody">Для использования ZFS в Ubuntu для начала нужно подключить нужный PPA-репозиторий. Поскольку все последующие действия потребуют прав суперпользователя, перво-наперво обретаем их на длительное время командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo -i</span> </p>
    <p class="Textbody">с вводом пользовательского пароля. А затем собственно подключаем репозиторий:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># add-apt-repository ppa:zfs-native/stable</span> </p>
    <p class="Textbody">Или, при желании поэкспериментировать --</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># add-apt-repository ppa:zfs-native/daily</span> </p>
    <p class="Textbody">Обновляем кэш:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># apt update</span> </p>
    <p class="Textbody">Теперь строим дерево зависимостей — в Mint 17.1 Rebecca это обязательный шаг, хотя ранее я обходился без него:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># apt build-dep ubuntu-zfs</span> </p>
    <p class="Textbody">И собираем необходимые пакеты:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># apt install ubuntu-zfs</span> </p>
    <p class="Textbody">Поскольку в репозитории они существуют не в бинарном виде, а в виде исходников, приведённая команда потянет за собой сборочный инструментарий. И сама сборка пакетов займёт определённое время. Но рано или поздно она закончится, и можно будет скомандовать</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># modprobe zfs</span> </p>
    <p class="Textbody">и проверить результат командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># lsmod | grep zfs</span> </p>
    <p class="Textbody">вывод которой будет выглядеть примерно так:</p>
    <p class="Textbody"><span style="background-color:#dddddd">zfs                  1158757  4</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">zcommon                51283  1 zfs</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">znvpair                81997  2 zfs,zcommon</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">zavl                   15011  1 zfs</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">zunicode              331226  1 zfs</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">spl                    88617  5 zfs,zcommon,znvpair,zavl,zunicode</span> </p>
    <p class="Textbody">После чего остаётся создать точку монтирования для пула ZFS — в моём случае таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># mkdir /home/data</span> </p>
    <p class="Textbody">Дать ей атрибуты принадлежности обычному пользователю:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># chown -R alv:alv /home/data</span> </p>
    <p class="Textbody">Теперь можно приступать к применению ZFS в мирных практических целях.</p>
    <h3 id="toc227"><a id="RefHeading18961713816058"></a><a id="bkmRefHeading18961713816058"></a><a id="toc226"></a><a id="bkmtoc226"></a><a id="RefHeading6961136957987"></a><a id="bkmRefHeading6961136957987"></a><a id="bkmRefHeading6961136957987"></a><a id="bkmbkmRefHeading6961136957987"></a>Создаём простой пул</h3>
    <p class="Textbody">Освоив ранее основные понятия, мы научились понимать ZFS. Для обратной же задачи — чтобы ZFS понимала нас — нужно ознакомиться с её командами. Главные из них — две: zpool для создания и управления пулами, и zfs для создания и управления наборами данных. Немного, правда? Хотя каждая из этих команд включает множество субкоманд, с которыми мы со временем разберёмся.</p>
    <p class="Textbody">Очевидно, что работу с ZFS следует начинать с создания пула хранения. Начнём с этого и мы. В простейшем случае однодисковой конфигурации это делается так:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zpool create tank dev_name </span>
    </p>
    <p class="Textbody">Здесь create — субкоманда очевидного назначня, tank — имя создаваемого пула (оно обычно даётся в примерах, но на самом деле может быть любым — с учётом ограничений ZFS, я использую имя data), а dev_name — имя устройства, включаемого в пул. Каковое может строиться по любой из описанных ранее моделей. И, чтобы не повторяться, напомню: все команды по манипуляции с пулами и наборами данных в них выполняются от лица администратора.</p>
    <p class="Textbody">В случае, если в состав пула включается один диск, и второго не предвидится, можно использовать имя устройства верхнего уровня — например, sda для цельного устройства (обратим внимание, что путь к файлу устройства указывать не нужно). Однако реально такая ситуация маловероятна: загрузка с ZFS проблематична, так что как минимум потребуется раздел с традиционной файловой системой под /boot (и/или под корень файловой иерархии), так что команда примет вид вроде следующего:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zpool create data sda3 </span>
    </p>
    <p class="Textbody">Однако если можно ожидать в дальнейшем подсоединения новых накопителей и их включения в существующий пул, то лучше воспользоваться именем по модели by-id, например:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zpool create data ata-Crucial_CT512MX100SSD1_14330CEEA98C-part3 </span>
    </p>
    <p class="Textbody">Очевидно, что в случае однодискового пула ни о какой избыточности говорить не приходится. Однако уже при двух дисках возможны варианты. Первый — создание пула без избыточности:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zpool create data dev_name1 dev_name2 </span>
    </p>
    <p class="Textbody">где dev_name1 и dev_name1 — имена устройств в принятой модели именования.</p>
    <p class="Textbody">В приведённом примере будет создано нечто вроде RAID’а нулевого уровня, с расщеплением (stripping) данных на оба устройства. Каковыми могут быть как дисковые разделы, так и диски целиком. Причём, в отличие от RAID0, диски (или разделы) не обязаны быть одинакового размера.</p>
    <p class="Textbody">После указанной команды никаких сообщений не последует. No news — good news, говорят англичане; в данном случае это означает, что пул был благополучно создан. В чём можно немедленно убедиться двумя способами. Во-первых, в корневом каталоге появляется точка его монтирования /data. А во-вторых, этой цели послужит субкоманда status:<br /># zpool status data</p>
    <p class="Textbody">которая выведет нечто вроде этого:</p>
    <p class="Textbody"><span style="background-color:#dddddd">pool: data</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">state: ONLINE</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">scan: none requested</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">config:</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME        STATE     READ WRITE CKSUM</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">mypool      ONLINE       0     0     0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">sdd       ONLINE       0     0     0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">sdf       ONLINE       0     0     0</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">errors: No known data errors</span> </p>
    <p class="Textbody">А с помощью субкоманды list можно узнать объём новообразованного пула:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># zpool list data</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">data  18,9G    93K  18,9G     0%  1.00x  ONLINE  -</span> </p>
    <p class="Textbody">Легко видеть, что он равен сумме объёмов обеих флэшек, если «маркетинговые» гигабайты пересчитать в «настоящие».</p>
    <p class="Textbody">К слову сказать, если дать субкоманду list без указания аргумента — имени пула, то она выведет информацию о всех пулах, задействованных в системе. В моём случае это выглядит так:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># zpool list</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">exp   18,9G    93K  18,9G     0%  1.00x  ONLINE  -</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">data  199G  20,8G   178G    10%  1.00x  ONLINE  -</span> </p>
    <p class="Textbody">Обращаю внимание, что даже чисто информационные субкоманды вроде list и status требуют прав администратора.</p>
    <p class="Textbody">Разумеется, два пула в одной, да ещё и настольной, машине — излишняя роскошь. Так что пул, созданный в экспериментальных целях, подлежит уничтожению, что делается с помощью субкоманды destroy:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zpool destroy exp</span> </p>
    <p class="Textbody">После чего он пропадёт из списка пулов. А что можно сделать с пулом до его уничтожения, увидим со временем.</p>
    <h3 id="toc228"><a id="RefHeading18981713816058"></a><a id="bkmRefHeading18981713816058"></a><a id="toc227"></a><a id="bkmtoc227"></a><a id="RefHeading6981136957987"></a><a id="bkmRefHeading6981136957987"></a><a id="bkmRefHeading6981136957987"></a><a id="bkmbkmRefHeading6981136957987"></a>«Избыточные» пулы</h3>
    <p class="Textbody">Избавившись от ставшего ненужным пула, рассмотрим второй вариант — создание пула с зеркальным устройством. Создаём его из двух накопителей одинакового объёма:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zpool create -f exp2 mirror sdf sdg</span> </p>
    <p class="Textbody">Проверка показывает, что итоговый пул, как и следовало ожидать, равен объёму одного накопителя:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># zpool list mypool</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">exp2  3,72G  91,5K  3,72G     0%  1.00x  ONLINE  -</span> </p>
    <p class="Textbody">При различии объёмов больший диск будет «обрезан» до объёма меньшего.</p>
    <p class="Textbody">Полное зеркалирование любыми, по моему мнению, в настольных условиях — роскошь непозволительная: банальные бэкапы данных проще и надёжнее. Тем не менее, не исключаю, что некоторая избыточность на уровне проверки контрольных сумм может оказаться не лишней, да и не столь накладна. Так что давайте посмотрим и на третий вариант пула из более чем одного устройства — RAID-Z.</p>
    <p class="Textbody">Теоретически виртуальное устройство с одинарным контролем чётности, как уже говорилось, можно создать при наличии двух устройств физических. Однако практически это оказывается накладно, особенно если устройства не одинакового размера. Поэтому задействуем под него три накопителя:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zpool create exp3 raidz sdd sdf sdg</span> </p>
    <p class="Textbody">что даст нам следующую картину:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># zpool list exp3</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">exp3  11,1G   205K  11,1G     0%  1.00x  ONLINE  -</span> </p>
    <p class="Textbody">Впрочем, как мне кажется, в настольных условиях не стоит выделки и эта овчинка.</p>
    <h3 id="toc229"><a id="RefHeading19001713816058"></a><a id="bkmRefHeading19001713816058"></a><a id="toc228"></a><a id="bkmtoc228"></a><a id="RefHeading7001136957987"></a><a id="bkmRefHeading7001136957987"></a><a id="bkmRefHeading7001136957987"></a><a id="bkmbkmRefHeading7001136957987"></a>Пул кэшируемый</h3>
    <p class="Textbody">И, наконец, последний вариант организации пула из более чем одного устройства — создание пула с кэшированием. Для чего создаём из двух устройств простой пул без избыточности и подсоединяем к нему устройство для кэша:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zpool create exp4 sdd sdf cache sdg</span> </p>
    <p class="Textbody">Очевидно, что устройство для кэширования не должно входить в пул любого рода — ни в простой, ни в избыточный. Что мы и видим в выводе субкоманды list:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># zpool list exp4</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">exp4  18,9G    82K  18,9G     0%  1.00x  ONLINE  -</span> </p>
    <p class="Textbody">где никаких следов его обнаружить не удаётся. Если же появляются сомнения, а подключилось ли оно на самом деле, обращаемся к субкоманде status, которая покажет беспочвенность наших опасений.</p>
    <p class="Textbody">Как я уже говорил в обзоре возможностей ZFS, подключение устройства кэширования имеет смысл при наличии большого традиционного винчестера (или винчестеров) и относительно небольшого SSD, которое и играет роль дискового кэша.</p>
    <h3 id="toc230"><a id="RefHeading19021713816058"></a><a id="bkmRefHeading19021713816058"></a><a id="toc229"></a><a id="bkmtoc229"></a><a id="RefHeading7021136957987"></a><a id="bkmRefHeading7021136957987"></a><a id="bkmRefHeading7021136957987"></a><a id="bkmbkmRefHeading7021136957987"></a>О некоторых опциях команды zpool</h3>
    <p class="Textbody">Команда zpool поддерживает ещё множество субкоманд, предназначенных для экспорта и импорта пула, добавления к нему устройств и изъятия оных, и так далее. Но сейчас я расскажу о некоторых опциях, которые могут оказаться необходимыми при создании пула.</p>
    <p class="Textbody">Одна из важный опций — -f: она предписывает принудительное выполнение данной операции и требуется, например, при создании пула из неразмеченных устройств.</p>
    <p class="Textbody">Полезной может оказаться опция -n. Она определяет тестовый режим выполнения определённой субкоманды, то есть выводит результат, например, субкоманды zpool create без фактического создания пула. И, соответственно, сообщает об ошибках, если таковые имеются.</p>
    <p class="Textbody">Интересна также опция -m mountpoint. Как уже говорилось, при создании пула по умолчанию в корне файловой иерархии создаётся каталог /pool_name, который в дальнейшем будет точкой монтирования файловых систем ZFS. Возможно, что это окажется не самым лучшим местом для их размещёния, и, как мы увидим в дальнейшем, это несложно будет изменить. Но можно задать каталог для пула сразу — например, /home/data: это и будет значением опции -m. Никто не запрещает определить в качестве такового и какой-либо из существующих каталогов, если он пуст, иначе автоматическое монтирование файловых систем пула в него окажется невозможным.</p>
    <p class="Textbody">Наконец, нынче важное значение приобретает опция ashift=#, значением которой является размер блока файловой системы в виде степеней двойки. По умолчанию при создании пула размер блока определяется автоматически, и до некоторого времени это было оптимально. Однако затем, с одной стороны, появились диски так называемого Advanced Format, в других размер блока равен 4 КБ. С другой стороны, получили распространение SSD-накопители, обычно также имеющие четырёхкилобайтный блок. В этих условиях автоматика ZFS может работать некорректно, что приводит к падению производительности пула.</p>
    <p class="Textbody">Для предотвращения означенного безобразия и была придумана опция ashift. Значение её по умолчанию — 0, что соответствует автоматическому определению размера блока. Прочие же возможные значения лежат в диапазоне от 9 для блока в 512 байт (29 = 512) до 16 для 64-килобайтного блока (216 = 65536). В интересующем нас случае четырёхкилобайтного блока оно составляет 12 (212 = 4096). Именно последнее значение и следует указать явным образом при создании пула из винчестеров AF или большинства SSD-накопителей.</p>
    <h3 id="toc231"><a id="RefHeading19041713816058"></a><a id="bkmRefHeading19041713816058"></a><a id="toc230"></a><a id="bkmtoc230"></a><a id="RefHeading7041136957987"></a><a id="bkmRefHeading7041136957987"></a><a id="bkmRefHeading7041136957987"></a><a id="bkmbkmRefHeading7041136957987"></a>Создание файловых систем</h3>
    <p class="Textbody">Пулы хранения представляют собой вместилища для наборов данных, для манипуляции которыми предназначена вторая из главнейших команд — zfs. Самыми важными наборами данных являются файловые системы, к рассмотрению которых мы и переходим.</p>
    <p class="Textbody">Для создания файловых систем предназначена субкоманда create команды zfs, которая требует единственного аргумента — имени создаваемой ФС и обычно не нуждается ни в каких опциях:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zfs create pool_name/fs_name </span>
    </p>
    <p class="Textbody">Внутри пула можно создавать сколь угодно сложную иерархию файловых систем. Единственное условие — родительская файловая система для системы более глубокого уровня вложенности должна быть создана заблаговременно. Ниже я покажу это на конкретном примере создания файловых систем внутри каталога /home — наиболее оправданное место для размещёния наборов данных ZFS.</p>
    <p class="Textbody">Начну я немножечко издалека. При стандартной установке Mint не обойтись без создания учетной записи обычного пользователя, и, следовательно, в каталоге /home будет присутствовать по крайней мере один подкаталог — /home/username.</p>
    <p class="Textbody">Смонтировать же файловую систему ZFS в непустой каталог невозможно, и, значит, мы не можем сразу прибегнуть к опции -m для определения «постоянной прописки» создаваемого пула.</p>
    <p class="Textbody">Поэтому для начала делаем для пула «прописку» во временной точке — пусть это будет традиционный /tank:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zpool create -o ashift=12 tank ata-SanDisk_SDSSDX120GG25_120823400863-part3 ata-SanDisk_SDSSDX120GG25_120823402786-part3</span> </p>
    <p class="Textbody">Теперь создаём файловую систему для будущего домашнего каталога:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs create tank/home</span> </p>
    <p class="Textbody">А внутри же неё — необходимые дочерние ветви, как то:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># zfs create tank/home/alv</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody">которая потом заменит мой домашний каталог — в нём я не держу ничего, кроме конфигурационных файлов;</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs create tank/home/proj</span> </p>
    <p class="Textbody">это файловая система для моих текущих проектов, и так далее.</p>
    <p class="Textbody">Как и было обещано разработчиками ZFS, процедура ничуть не сложнее, чем создание обычных каталогов. Благодаря этому файловые системы можно легко создавать по мере надобности, для решения какой-либо частной задачи. И столь же легко уничтожать их, когда задача эта выполнена. Что делается таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs destroy pool_name/fs_name</span> </p>
    <p class="Textbody">Использовать субкоманду destroy следует аккуратно: никакого запроса на подтверждение при этом не будет. Правда, и уничтожить файловую систему, занятую в каком-либо текущем процессе, можно только с указанием опции -f, а файловую систему, содержащую системы дочерние, не получится убить и таким образом.</p>
    <p class="Textbody">Ни в какой специальной операции монтирования новообразованные файловые системы не нуждаются — оно происходит автоматически в момент их создания, о чём свидетельствует следующая команда:<br />$ mount | grep tank tank/home on /tank/home type zfs (rw,atime,xattr) tank/home/alv on /tank/home/alv type zfs (rw,atime,xattr) tank/home/proj on /tank/home/proj type zfs (rw,atime,xattr) ...</p>
    <p class="Textbody">Для обеспечения монтирования файловых систем ZFS при рестарте машины не требуется и никаких записей в файле /etc/fstab: это также происходит само собой, совершенно нечувствительно для пользователя. Правда, если для файловой системы ZFS определить свойство mountpoint=legacy, то с ней можно управляться и традиционным способом.</p>
    <p class="Textbody">Как и для обычного каталога, объём каждой файловой системы ничем не лимитирован, и в момент создания для любой из них потенциально доступно всё пространство пула, которое равномерно уменьшается по мере разрастания файловых систем. На данный момент в моей системе это выглядит так.</p>
    <p class="Textbody">Казалось бы, для тех же целей можно ограничиться обычными каталогами. Однако в наборах данных ZFS мы имеем дело с полноценными файловыми системами, для которых могут быть установлены индивидуальные свойства, аналогичные опциям монтирования файловых систем традиционных. Чем мы сейчас и займёмся.</p>
    <h3 id="toc232"><a id="RefHeading19061713816058"></a><a id="bkmRefHeading19061713816058"></a><a id="toc231"></a><a id="bkmtoc231"></a><a id="RefHeading7061136957987"></a><a id="bkmRefHeading7061136957987"></a><a id="bkmRefHeading7061136957987"></a><a id="bkmbkmRefHeading7061136957987"></a>Файловые системы: устанавливаем свойства</h3>
    <p class="Textbody">При создании файловая система ZFS получает по умолчанию определённый набор свойств, во многом сходный с атрибутами традиционных файловых систем, определяемыми опциями их монтирования. Полный их список можно получить командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs get all fs_name</span> </p>
    <p class="Textbody">Свойств этих очень много, однако далеко не все они представляют для нас интерес. Важно только помнить, что любое из свойств каждой файловой системы можно поменять с помощью субкоманды set и её параметра вида свойство=значение. Причём изменение свойств для материнской системы рекурсивно распространяется на все дочерние. Однако для любой последней свойства можно изменить в индивидуальном порядке. Что я сейчас и проиллюстрирую на примерах.</p>
    <p class="Textbody">Так, абсолютно лишним представляется свойство atime, то есть обновление времени последнего доступа к файлам. Оно, во-первых, снижает быстродействие, с другой — способствует износу SSD-накопителей (правда, нынче и то, и другое чисто символичны). Так что отключаем это свойство для всех файловых систем:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs set atime=off tank/home</span> </p>
    <p class="Textbody">Аналогичным образом расправляемся и со свойством xattr:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs set xattr=off tank/home</span> </p>
    <p class="Textbody">А вот дальше можно заняться и индивидуализацией. Как я уже говорил, в момент создания файловые системы ZFS «безразмерны». Если это не подходит, для них можно установить квоты. Однако я этого делать не буду — в моём случае это приводит к потере половины смысла ZFS. А вот зарезервировать место для критически важных каталогов, дабы его не отъела, скажем, мультимедиа, известная своей прожорливостью, будет не лишним. И потому я для файловых систем tank/home/proj и tank/home/alv устанавливаю свойство reservation. Для файловой системы проектов оно будет максимальным:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs set reservation=10G tank/home/proj</span> </p>
    <p class="Textbody">Для остальных ограничусь более скромным гигабайтом резерва.</p>
    <p class="Textbody">Далее, поскольку данные в файловой системе tank/home/proj для меня действительно важны, и шутить с ними я склонен даже гораздо меньше, чем с дамами, предпринимаю дополнительные меры по их сохранности путём удвоения числа копий (по умолчанию оно равно 1):</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs set copies=2 tank/home/proj</span> </p>
    <p class="Textbody">А для данных не столь важных — тех, что часто проще скачать заново, нежели отыскать на локальной машине, можно выполнить и обратную операцию — отказаться от подсчёта контрольных сумм:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs set checksum=off tank/home/media</span> </p>
    <p class="Textbody">Для файловых систем, содержащих хорошо сжимаемые данные (например, для моего домашнего каталога, где лежат одни dot-файлы), можно включить компрессию:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zfs set compression=on tank/home/alv </span>
    </p>
    <p class="Textbody">Я этого не делал: экономия места получается грошовая, а нагрузка на процессор и расход памяти, как говорят, очень приличные. Однако это свойство целесообразно включать в системах с огромными логами, если выделить под них файловую систему в пуле ZFS.</p>
    <p class="Textbody">При желании для некоторых файловых систем (например, того же домашнего каталога) можно отключить такие свойства, как exec, setuid, devices — легко догадаться, что результат будет аналогичен указанию опций монтирования noexec, nosuid, nodev для традиционных файловых файловых систем. И, разумеется, для файловых систем, изменение которых нежелательно, можно придать свойство readonly.</p>
    <p class="Textbody">Все необходимые свойства файловых систем желательно установить до их наполнения контентом, ибо многие из них (например, компрессия) обратной силы не имеют.</p>
    <h3 id="toc233"><a id="RefHeading19081713816058"></a><a id="bkmRefHeading19081713816058"></a><a id="toc232"></a><a id="bkmtoc232"></a><a id="RefHeading7081136957987"></a><a id="bkmRefHeading7081136957987"></a><a id="bkmRefHeading7081136957987"></a><a id="bkmbkmRefHeading7081136957987"></a>Перемонтирование</h3>
    <p class="Textbody">После создания файловых систем и задания всех необходимых их свойств наступает психологический момент для перемонтирования их по месту «постоянной прописки» — то есть в каталог /home. Что потребует некоторых подготовительных действий.</p>
    <p class="Textbody">Поскольку предполагается, что все новообразованные файловые системы должны быть полностью доступны обычному пользователю (то есть мне, любимому), перво-наперво следует изменить атрибуты из принадлежности — ведь создавались они от имени администратора и принадлежат юзеру по имени root. Для чего даю команду:<br /># chown -R alv:users /tank/home/*</p>
    <p class="Textbody">Теперь нужно скопировать конфиги из каталога /home/alv в /tank/home/alv:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># cp -Rp /home/alv/.* /tank/home/alv/ </span>
    </p>
    <p class="Textbody">не забыв про опцию -p для сохранения атрибутов.</p>
    <p class="Textbody">Все предыдущие операции можно было выполнять, получив права администратора с помощью команды sudo. Причём где угодно — в текстовом виртуальном терминале или в терминальном окне Иксового сеанса. Теперь же потребуется переавторизоваться в «голой» консоли.</p>
    <p class="Textbody">Монтирование файловых систем ZFS в каталог с любым содержимым невозможно, так что требуется очистить каталог /home от следов прежней жизнедеятельности пользователя таким образом:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># rm -Rf /home/alv </span>
    </p>
    <p class="Textbody">При хоть одном активном пользовательском процессе в ответ на это последует сообщение об ошибке. Так что, возможно, перед этим придётся убить все реликтовые процессы, запущенные в Иксах от имени пользователя. Сначала выявляем их командой</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># ps aux | grep alv </span>
    </p>
    <p class="Textbody">обращая внимание на идентификаторы процессов (PID). А затем последовательно мочим их в сортире:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># kill -9 #### </span>
    </p>
    <p class="Textbody">Альтернативный способ — разрузка системы в recovery mode с выбором пункта меню root, что в Mint эквивалентно однопользовательскому режиму. В этом случае никаких пользовательских процессов не будет по определению, и перенос файлов из /home/username в /tank/home/username можно выполнить напрямую.</p>
    <p class="Textbody">Выполнив все указанные действия, определяем для набора данных tank/home свойство mountpoint, что и осуществит перемонтирование:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zfs set mountpoint=/home tank/home </span>
    </p>
    <p class="Textbody">Теперь остаётся только с помощью команды ls убедиться, что в /home появились новые подкаталоги с нужными атрибутами:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd">drwxr-xr-x 26 alv users 48 Sep 23 14:27 alv/<br />drwxr-xr-x 18 alv users 18 Sep 22 02:28 proj/<br />... </span>
    </p>
    <p class="Textbody">А команда</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># mount | grep /home </span>
    </p>
    <p class="Textbody">покажет нам новые точки монтирования файловых систем:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd">tank/home on /home type zfs (rw,noatime,noxattr)<br />tank/home/alv on /home/alv type zfs (rw,noatime,noxattr)<br />tank/home/proj on /home/proj type zfs (rw,noatime,noxattr)<br />... </span>
    </p>
    <p class="Textbody">На этом дело с подготовкой файловых систем ZFS к практической работе можно считать законченным: при перезагрузке машины все они будут благополучно смонтированы в автоматическом режиме.</p>
    <h3 id="toc234"><a id="RefHeading19101713816058"></a><a id="bkmRefHeading19101713816058"></a><a id="toc233"></a><a id="bkmtoc233"></a><a id="RefHeading7101136957987"></a><a id="bkmRefHeading7101136957987"></a><a id="bkmRefHeading7101136957987"></a><a id="bkmbkmRefHeading7101136957987"></a>Подключение пула ZFS, созданного в другой системе</h3>
    <p class="Textbody">Здесь речь пойдёт о том, как подключить к некоей Linux-системе (конкретно, Ubuntu) пул ZFS, ранее созданный в другой системе — теоретически это могут быть Solaris, FreeBSD или более иной дистрибутив Linux, для которого предусмотрена поддержка ZFS on Linux. Но практически я опробовал только последний вариант, о чём и расскажу.</p>
    <p class="Textbody">Перво-наперво нужно перезагрузиться в ту систему, в которой создавался пул (в моём случае это была openSUSE), и экспортировать его командой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zpool export data</span> </p>
    <p class="Textbody">где data — имя пула с точкой монтирования /home/data.</p>
    <p class="Textbody">Следующий шаг — вернуться в Ubuntu и создать в ней аналогичную точку монтирования для пула ZFS — в моём случае таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo mkdir /home/data</span> </p>
    <p class="Textbody">Дать ей атрибуты принадлежности обычному пользователю:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo chown -R alv:alv /home/data</span> </p>
    <p class="Textbody">И импортировать созданный в openSUSE пул ZFS:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo zpool import -f data</span> </p>
    <p class="Textbody">Не забыв об опции -f, предписывающей принудительной выполнение импорта. Без неё ответом на эту команду будет сообщение об ошибке.</p>
    <p class="Textbody">Теперь в каталоге /home/data можно видеть те же самые файловые системы ZFS, которые были созданы в родителькой для пула системе, вместе со всеми размещёнными в них данными. С которыми можно начинать работать.</p>
    <p class="Textbody">Сказанное справедливо, если идентификаторы пользователя в обеих системах совпадают — в моём случае это именно так. Однако в случае общем это совсем не обязательно — и тогда надо озаботиться каким-либо способом обеспечения совместного доступа к ним из разных систем. Впрочем, к ZFS, о которой мы сейчас разговариваем, это не имеет ни малейшего отношения.</p>
