<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html lang="ru-RU" xml:lang="ru-RU" xmlns="http://www.w3.org/1999/xhtml">
  <!-- This file was converted to xhtml by Writer2xhtml ver. 1.0.2. See http://writer2latex.sourceforge.net for more info. -->
  <head>
    <title></title>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type" />
    <meta content="" name="description" />
    <meta content="" name="keywords" />
    <style media="all" type="text/css">
      body {font-family:'Noto Sans',sans-serif;font-size:16.0px}
      span.StrongEmphasis {font-weight:bold}
      a:link {color:#000080;text-decoration:underline}
      a:visited {color:#800000;text-decoration:underline}
      p.Quotations {margin-left:75.59055px;margin-right:75.59055px;margin-top:1.5496062px;margin-bottom:3.817323px;border:none;padding:0;background-color:#f3f3f3;text-indent:18.859844px;text-align:justify;font-family:Calibri,sans-serif;font-style:normal;font-weight:normal;font-size:13.333334px;color:#000000;text-decoration:none}
      p.Standard {margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;border:none;padding:0;background-color:#ffffff;text-indent:18.859844px;text-align:justify;font-family:Cambria,sans-serif;font-style:normal;font-weight:normal;font-size:16.0px;color:#000000;text-decoration:none}
      p. {margin-left:0;margin-right:0;margin-top:7.5212603px;margin-bottom:7.5212603px;border:none;padding:0;background-color:#ffffff;text-indent:0;text-align:center;font-family:'Noto Sans',sans-serif;font-style:normal;font-weight:bold;font-size:21.333334px;color:#000080;text-decoration:none}
      p.Subtitle {margin-left:0;margin-right:0;margin-top:7.5212603px;margin-bottom:7.5212603px;border:none;padding:0;background-color:#ffffff;text-indent:0;text-align:center;font-family:Arial,sans-serif;font-style:normal;font-weight:bold;font-size:18.666668px;color:#000080;text-decoration:none}
      p.Title {margin-left:0;margin-right:0;margin-top:15.987401px;margin-bottom:18.859844px;border:none;padding:0;background-color:#ffffff;text-indent:18.859844px;text-align:center;font-family:'Noto Sans',sans-serif;font-style:normal;font-weight:bold;font-size:37.333336px;color:#000000;text-decoration:none}
      p.Contents4 {margin-left:56.617325px;margin-right:0;margin-top:0;margin-bottom:0;border:none;padding:0;background-color:#ffffff;text-indent:0;text-align:justify;font-family:'Noto Sans',sans-serif;font-style:normal;font-weight:normal;font-size:16.0px;color:#000000;text-decoration:none}
      p.Contents3 {margin-left:37.71969px;margin-right:0;margin-top:0;margin-bottom:0;border:none;padding:0;background-color:#ffffff;text-indent:0;text-align:justify;font-family:'Noto Sans',sans-serif;font-style:normal;font-weight:normal;font-size:16.0px;color:#000000;text-decoration:none}
      p.ContentsHeading {margin-left:0;margin-right:0;margin-top:15.987401px;margin-bottom:18.859844px;border:none;padding:0;background-color:#ffffff;text-indent:0;text-align:justify;font-family:Albany,sans-serif;font-style:normal;font-weight:bold;font-size:21.333334px;color:#000000;text-decoration:none}
      p.Textbody {margin-left:0;margin-right:0;margin-top:0;margin-bottom:18.859844px;border:none;padding:0;background-color:#ffffff;text-indent:18.859844px;text-align:justify;font-family:Cambria,sans-serif;font-style:normal;font-weight:normal;font-size:16.0px;color:#000000;text-decoration:none}
      p.Contents2 {margin-left:18.859844px;margin-right:0;margin-top:0;margin-bottom:0;border:none;padding:0;background-color:#ffffff;text-indent:0;text-align:justify;font-family:'Noto Sans',sans-serif;font-style:normal;font-weight:normal;font-size:16.0px;color:#000000;text-decoration:none}
      h2 {margin-left:0;margin-right:0;margin-top:7.5212603px;margin-bottom:7.5212603px;border:none;padding:0;background-color:#ffffff;text-indent:0;text-align:left;font-family:Arial,serif;font-style:normal;font-weight:bold;font-size:20.0px;color:#000080;text-decoration:none;clear:left}
      h3 {margin-left:0;margin-right:0;margin-top:7.5212603px;margin-bottom:7.5212603px;border:none;padding:0;background-color:#ffffff;text-indent:0;text-align:left;font-family:Arial,serif;font-style:normal;font-weight:bold;font-size:18.666668px;color:#000080;text-decoration:none;clear:left}
      h4 {margin-left:0;margin-right:0;margin-top:7.5212603px;margin-bottom:7.5212603px;border:none;padding:0;background-color:#ffffff;text-indent:0;text-align:left;font-family:Arial,serif;font-style:normal;font-weight:bold;font-size:17.333334px;color:#000080;text-decoration:none;clear:left}
      .frameGraphics {margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;border:none;padding:0;font-size:16.0px}
      .frameGraphics p {margin-left:0;margin-right:0;margin-top:0;margin-bottom:0;font-size:16.0px}
    </style>
  </head>
  <body dir="ltr">
    <p class="Title">Linux Mint и его Cinnamon</p>
    <p class="Subtitle">Очерки применителя</p>
    <p class="">Алексей Alv Федорчук</p>
    <h2 id="toc0"><a id="RefHeading14421713816058"></a><a id="bkmRefHeading14421713816058"></a><span class="StrongEmphasis">Аннотация</span> </h2>
    <p class="Textbody">Эта книга посвящена дистрибутиву Linux Mint и одной из его главных рабочих сред рабочих сред — десктопу Cinnamon. В ней рассмотрены их особенности, средства настройки дистрибутива и среды, системы управления пакетами, некоторые прикладные программы. Затронут также ряд более специальных вопросов, имеющих отношение не только к Linux Mint, такие, как командная оболочка Zsh, использование программных RAID, технологии LVM и системы размещения данных ZFS. Заключительным аккордом в ней прозвучит рассказ о создании собственных индивидуализированных сборок на базе Linux Mint и Cinnamon.</p>
    <p class="Textbody">Книга не является систематическим руководством по данному дистрибутиву и, тем более, по Linux вообще. Она ориентирована исключительно на любопытствующих применителей любого уровня подготовки, имеющих склонность к экспериментам, с одной стороны, и к изящной словесности — с другой.</p>
    <h2 id="toc1"><a id="RefHeading14441713816058"></a><a id="bkmRefHeading14441713816058"></a><a id="toc0"></a><a id="bkmtoc0"></a><a id="RefHeading12381136957987"></a><a id="bkmRefHeading12381136957987"></a><a id="bkmRefHeading12381136957987"></a><a id="bkmbkmRefHeading12381136957987"></a>Об этой книге</h2>
    <p class="Textbody">В основу этой книги легли заметки, посвящённые дистрибутиву Linux Mint и десктопу Cinnamon, которые на протяжении последнего года размещались на нашем <a href="http://alv.me/" target="_blank"><span style="font-weight:normal">Блогосайте</span></a>. В ней использованы также фрагменты цикла статей на ту же тему, публиковавшиеся на сайте <a href="http://www.ibm.com/developerworks/ru/" target="_blank">IBM developerWorks</a> (правда, цикл этот по не зависящим от меня обстоятельствам не был закончен). При подготовке книги эти статьи и заметки были систематизированы, структурированы, отредактированы и актуализированы в соответствии с текущими реалиями, а также дополнены новыми материалами.</p>
    <p class="Textbody">Автор не ставил себе целью написать последовательное и законченное руководство по Linux Mint и Cinnamon. Это — именно очерки, посвящённые тем аспектам устройства и применения данного тандема, которые а) не очень подробно освещёны в имеющихся источниках и б) интересны лично автору. И вследствие последнего обстоятельства носят вполне субъективный характер.</p>
    <p class="Textbody">Дистрибутив Mint, по моему мнению, пригоден для применителей любого уровня начальной подготовки. Соответственно и книга о нём не предполагает у читателя наличия каких-то особенных познаний, кроме самого обычного любопытства. А также понимания того, что это — именно очерки, а не сборник документации.</p>
    <p class="Textbody">При этом читатель книги не обязан быть применителем именно Linux Mint. Дистрибутив этот является дериватом Ubuntu и сохраняет с ней практически полную бинарную совместимость. Так что ряд описанных в книге вещёй (например, про управление пакетами) — общие для всего семейства Ubuntu'идов, а отчасти и для всех deb based дистрибутивов, включая даже прародительский Debian. Кое-что же, скажем, включение поддержки LVM, softRAID, ZFS, имеет силу для всех дистрибутивов Linux вообще.</p>
    <p class="Textbody">Ну а сведения, содержащиеся в очерках про Cinnamon, приложимы к любому дистрибутиве, в котором этот десктоп может быть установлен, и в котором обеспечивается его корректная работа — список их постоянно расширяется, и нынче включает в себя и не только Linux-, но и BSD-системы.</p>
    <p class="Textbody">Во время работы над книгой затронутые в ней вопросы обсуждались с моими товарищами и коллегами: <a href="http://by-popov-vn.blogspot.com/" target="_blank">Владимиром Поповым</a>, <a href="http://foss-blog.ru/" target="_blank">Сергеем Голубевым</a>, <a href="http://rwpbb.ru/" target="_blank">Владимиром Родионовым</a>, <a href="http://dinexi.livejournal.com/" target="_blank">Станиславом Шрамко</a>, а также многочисленными участниками социальной сети <a href="http://juick.com/" target="_blank">Juick</a>, форумов <a href="http://rosinka.rosix.ru/" target="_blank">Linux Mint Росинка</a> и <a href="http://matuntu.ru/" target="_blank">Matuntu</a>, для поимённого перечисления которых не хватит никаких ресурсов. Всем именованным и подразумеваемых лицам автор выражает свою признательность.</p>
    <p class="Textbody">Отдельная благодарность — поэту-линуксоиду <a href="http://humourist.ru/" target="_blank">Ирине Киттель aka Алиса Деева</a>, вдохновлявшей меня на трудовые свершения своими стихами, и моим детям — Ольге и Виктору, ставшими применителями Linux'а по собственной инициативе.</p>
    <p class="Textbody">Наконец, автор искренне признателен команде разработчиков дистрибутива Mint и интегрированной среды Cinnamon, и лично Клементу Лефевру aka Clem за создание прекрасного дистрибутива и его рабочего окружения.</p>
    <p class="Textbody">Примечание: книга в основных форматах для чтения в оффлайне доступна в <a href="http://alv.me/?page_id=1627" target="_blank">Библиотеке Блогосайта</a>. Для неё, как и всех остальных книг <span style="font-weight:bold">Библиотеки</span>, разрешается свободное использование и некоммерческое распространение в электронной форме при условии указания авторства и активной индексируемой ссылки на <a href="http://alv.me/" target="_blank">первоисточник</a>. Все книги <span style="font-weight:bold">Библиотеки</span> доступны бесплатно, хотя автор не отказывается от аморального (то есть финансового) содействия своим проектам, оказать которое можно, заглянув на <a href="http://alv.me/?page_id=1618" target="_blank">эту страницу</a>. </p>
    <h2 id="toc2"><a id="RefHeading14461713816058"></a><a id="bkmRefHeading14461713816058"></a><a id="toc1"></a><a id="bkmtoc1"></a><a id="RefHeading12401136957987"></a><a id="bkmRefHeading12401136957987"></a><a id="bkmRefHeading12401136957987"></a><a id="bkmbkmRefHeading12401136957987"></a>Введение в Linux Mint</h2>
    <p class="Textbody">Разговор о Mint и его Cinnamon логично начать с рассказа о том, что же такое, товарищи, Mint, и что такое, братья, Cinnamon. Начну с этого и я.</p>
    <h3 id="toc3"><a id="RefHeading14481713816058"></a><a id="bkmRefHeading14481713816058"></a><a id="toc2"></a><a id="bkmtoc2"></a><a id="RefHeading3181136957987"></a><a id="bkmRefHeading3181136957987"></a><a id="bkmRefHeading3181136957987"></a><a id="bkmbkmRefHeading3181136957987"></a>Лирическое вступление</h3>
    <p class="Quotations">Ведь в науке, в основном, происходят вещи посредственные — и я приучил себя к посредственному.<br /><span style="font-style:italic">Владимир Савченко, </span><span style="font-style:italic;font-weight:bold">Открытие себя</span></p>
    <p class="Textbody">В долгой истории дистрибутивов Linux до сего дня было два знаковых события (если не считать самого факта начала Linux-дистрибуции). Был период «бури и натиска» — рубеж тысячелетий, когда, вслед за первой версией Mandrake (имевшей, как ни странно, номер 5.1), поднялась волна так называемых «дистрибутивов, дружественных к пользователю» (они же — «с человеческим лицом»). И был «год великого перелома» — 2005, когда Ubuntu 5.10 Breezy Badger, став пригодной для применения, в одночасье обрела невероятную популярность среди применителей всех стран и народов, заставив разработчиков всех остальных популярных дистрибутивов пересмотреть свою политику в отношении этих самых применителей.</p>
    <p class="Textbody">С тех пор в мире Linux-дистрибуции происходили события более или менее заурядные. Новостные ленты заполнились сообщениями: вышел релиз W.W дистрибутива Имя рек с ядром X.XX, KDE Y.Y.Y и GNOME Z.Z.Z, со списком прочих изменений — длинным, но мало чего дающим применителю. Конечно, каждый такой релиз содержал усовершенствования. Хотя в последние годы первое действие при знакомстве со многими из них было: посмотреть — а чего они на этот раз поломали?</p>
    <p class="Textbody">Началось привыкание к заурядности происходящих событий. Настолько сильное, что, когда в последний день весны 2014 года, произошло событие действительно незаурядное — оно имело все шансы остаться практически незамеченным. А, между тем, по своей значимости оно вполне сопоставимо с выходом Mandrake 5.1 и Ubuntu 5.10. Это событие — релиз Mint 17 Qiana в сборке с рабочей средой Cinnamon 2.2. О которых и пойдёт речь в дальнейшем — но уже в актуализованном тандеме, появившемся в ноябре 2014 года и включающем Mint 17.1 Rebecca и Cinnamon 2.4.</p>
    <h3 id="toc4"><a id="RefHeading14501713816058"></a><a id="bkmRefHeading14501713816058"></a><a id="toc3"></a><a id="bkmtoc3"></a><a id="RefHeading3201136957987"></a><a id="bkmRefHeading3201136957987"></a><a id="bkmRefHeading3201136957987"></a><a id="bkmbkmRefHeading3201136957987"></a>Что такое Mint</h3>
    <p class="Textbody">Полное имя первого из героев этого цикла — <a href="http://linuxmint.com/" target="_blank">Linux Mint</a>. Однако, поскольку ясно, о дистрибутиве какой операционной системы идёт речь, первый компонент я в дальнейшем буду опускать.</p>
    <p class="Textbody">Дистрибутив Mint, начиная с 2011 года, стабильно занимает первое место в рейтинге <a href="http://distrowatch.com/" target="_blank">Distrowatch</a>. Конечно, это не значит, что он является самым распространённым или самым популярным — рейтинг этот, как и все подобные измерители… животов, вещь достаточно условная. Но безусловно свидетельствует о широкой известности дистрибутива в узких кругах применителей Linux. Так что я могу ограничиться очень краткой его характеристикой.</p>
    <p class="Textbody">Дистрибутив Mint был создан в 2006 году Клементом Лефевром (Clement Lefebvre), который поставил своей целью создание идеального десктопа «для народа» — домашних пользователей и малого бизнеса. Он представлял собой дериват Ubuntu — термины клон или форк в данном случае не применимы. То есть Mint в базовой своей части, вплоть до Xorg, основан на кодовой базе Ubuntu, и все соответствующие пакеты берутся из её репозиториев без всяких изменений. Однако он имеет и собственный небольшой репозиторий (около 500 пакетов), содержащий дистрибутив-специфические компоненты.</p>
    <div id="attachment7437regionregion">
      <p class="Textbody" style="text-align:center"><a href="http://alv.me/wp-content/img/2014/12/clemet-lefebvre.jpg"><img alt="Изображение1" class="frameGraphics" id="1graphic" src="http://alv.me/wp-content/img/2014/12/clemet-lefebvre-572x321.jpg" style="border:1.0px solid #000080;padding:0;width:572.0236px;height:321.0251px" /></a> </p>
      <p class="Textbody" style="text-align:center;font-weight:bold;font-size:14.0px">Клемент Лефевр</p>
    </div>
    <p class="Textbody">В сентябре 2010 года было объявлено о выходе другого дистрибутива проекта Mint — Linux Mint Debian Edition (LMDE). Как можно догадаться из его имени, он был основан на кодовой базе не Ubuntu, а Debian. В качестве таковой выступала его ветка testing, и потому релиз-цикла у LMDE нет — его «плавающие» версии маркировались годом и месяцем. Впрочем, в этом цикле речи о них не будет — этот дистрибутив заслуживает отдельного рассказа, время для которого ещё не наступило.</p>
    <h3 id="toc5"><a id="RefHeading14521713816058"></a><a id="bkmRefHeading14521713816058"></a><a id="toc4"></a><a id="bkmtoc4"></a><a id="RefHeading3221136957987"></a><a id="bkmRefHeading3221136957987"></a><a id="bkmRefHeading3221136957987"></a><a id="bkmbkmRefHeading3221136957987"></a>Немного истории</h3>
    <p class="Textbody">Завязка сюжета относится к 2011 году. До этого момента в качестве рабочего окружения в Mint использовался GNOME текущей версии — той же, что в базовой Ubuntu. Правда, GNOME был в нём главным, но не единственным десктопом. Чуть ли не со дня основания Mint существовала и его сборка с KDE, позднее к ней присоединились варианты с рабочими средами Xfce (2007 год) и LXDE (2010 год), на протяжении 2008-2010 годов существовал даже вариант с оконным менеджером Fluxbox. Однако они имели не вполне официальный статус, и появлялись, как правило, несколько позже сборок «генеральной линии». И иногда пропадали с горизонта вообще, как случилось с редакциями LXDE и Fluxbox.</p>
    <p class="Textbody">Но весной 2011 года, с одной стороны, Ubuntu переходит на среду Unity, с другой — появляется релиз GNOME 3 с оболочкой GNOME Shell, поддержка же GNOME 2 разработчиками этого десктопа официально прекращается.</p>
    <p class="Textbody">Оба новых десктопа, по ряду причин, оказались для разработчиков Mint неприемлемыми. И потому они, с одной стороны, включили в свой дистрибутив десктоп MATE, а с другой — занялись разработкой новой оболочки для GNOME 3, которая в декабре 2011 года была анонсирована под именем Cinnamon. И это — второй герой настоящего цикла.</p>
    <h3 id="toc6"><a id="RefHeading14541713816058"></a><a id="bkmRefHeading14541713816058"></a><a id="toc5"></a><a id="bkmtoc5"></a><a id="RefHeading3241136957987"></a><a id="bkmRefHeading3241136957987"></a><a id="bkmRefHeading3241136957987"></a><a id="bkmbkmRefHeading3241136957987"></a>Возвращаясь к современности</h3>
    <p class="Textbody">Однако надо возвратиться к первому герою и обрисовать современное положение дел. Вышедший 31 мая релиз 17 Qiana был представлен, как уже говорилось, основными десктопными редакциями с Cinnamon и MATE в качестве рабочих сред, в сборках для 32- 64-разрядных архитектур.</p>
    <p class="Textbody">Постепенно к ним присоединялись другие варианты дистрибутива. Так, обе базовые редакции получили так называемые образы nocodecs и oem. Как нетрудно догадаться, первые предназначены для стран, признающих патенты на алгоритмы, вторые — для предустановки на новые компьютеры. А затем к базовым редакциям присоединились редакции с рабочими средами KDE и Xfce.</p>
    <p class="Textbody">С появлением в ноябре 2014 года релиза 17.1 Rebecca перечисленные образы сменились одноимёнными редакциями с актуальными на данный момент рабочими средами Cinnamon и MATE, к которым опять-таки чуть позже присоединились KDE- и Xfce-сборки. Выход же второй версии дистрибутива LMDE запланирован на март 2015 года.</p>
    <p class="Textbody">Все перечисленные варианты представляют Live-образы, которые могут быть записаны либо на DVD-диски (объём их 1,3-1,4 ГБ), либо на твердотельные носители типа USB Flash или SD-карт. Во втором случае это можно сделать и специализированными утилитами типа UNetbootin, и прямой командой dd. Программа инсталляции запускается из Live-режима любого диска, альтернативных, то есть «чисто установочных», вариантов ни для одной редакции Mint не предусмотрено.</p>
    <p class="Textbody">Скачать образы можно по ссылкам с <a href="http://www.linuxmint.com/download.php" target="_blank">официального сайта проекта</a>, где приведён список многочисленных зеркал, физически находящихся в разных странах. В российских условиях целесообразно обратиться на <a href="http://mirror.yandex.ru/linuxmint/stable/17/" target="_blank">зеркало Яндекса</a>.</p>
    <p class="Textbody">На этом мы временно попрощаемся с дистрибутивом Mint. Следующий очерк будет посвящён общему знакомству со второй героиней нашего повествования — одной из двух основных его рабочих сред, которая носит имя Cinnamon.</p>
    <h2 id="toc7"><a id="RefHeading14561713816058"></a><a id="bkmRefHeading14561713816058"></a><a id="toc6"></a><a id="bkmtoc6"></a><a id="RefHeading12421136957987"></a><a id="bkmRefHeading12421136957987"></a><a id="bkmRefHeading12421136957987"></a><a id="bkmbkmRefHeading12421136957987"></a>Введение в Cinnamon</h2>
    <p class="Textbody">Здесь будет рассказано о интегрированной рабочей среде Cinnamon — её истории, особенностях, распространении и поддержке в других дистрибутивах.</p>
    <h3 id="toc8"><a id="RefHeading14581713816058"></a><a id="bkmRefHeading14581713816058"></a><a id="toc7"></a><a id="bkmtoc7"></a><a id="RefHeading3261136957987"></a><a id="bkmRefHeading3261136957987"></a><a id="bkmRefHeading3261136957987"></a><a id="bkmbkmRefHeading3261136957987"></a>История</h3>
    <p class="Textbody">Cinnamon — самая молодая из «уже действующих» интегрированных рабочих сред (иначе — декстопов): проект был анонсирован 20 декабря 2011 года, а уже 23 декабря он стал доступен для скачивания, и сразу в виде релиза 1.1.2 — версии с меньшими номерами предназначались только для тестирования.</p>
    <p class="Textbody">Далее развитие проекта происходило стремительно: 23 января следующего года появляется релиз 1.3, в середине марта — 1.4, а затем, в сентябре — релиз 1.6. После чего устанавливается полугодовой релиз-цикл — релиз 1.8 выходит в свет 5 мая 2013 года, после серии релизов корректирующих. В октябре того же года появляется релиз 2.0, в апреле 2014 года — релиз 2.2. И, наконец, герой нашего рассказа, релиз 2.4, увидел свет 1 ноября 2014 года.</p>
    <p class="Textbody">Все релизы среды опережали версии Mint, для которых они предназначались, примерно на месяц — для дополнительного тестирования среды силами энтузиастов и притирки её к целевому дистрибутиву. Что, как показала практика, давало весьма положительный результат. О чём могу свидетельствовать по собственному опыту для версий Cinnamon 2.2 и 2.4: в релизы Mint 17 и 17.1, соответственно, они были включены в существенно доработанном виде по сравнению с первоначально представленными сборками.</p>
    <p class="Textbody">Смена версий Cinnamon отражает специфичность его судьбы. Что же происходило при этом? В предыдущем очерке упоминалось, что история этого десктопа началась с появлением GNOME 3. Говорить о кипении страстей, связанных с этим событием, здесь не уместно. Достаточно сказать, что для многих применителей ряда дистрибутивов, включавших GNOME 2 в качестве штатного десктопа, его «осовремененная» версия, в частности, «очень прогрессивная» оболочка GNOME Shell, оказалась неприемлемой.</p>
    <p class="Textbody">В частности, Mint был очень крепко связан с десктопом GNOME 2. Однако GNOME 3, особенно в своём первозданном виде, в концепцию его развития не вписывался, а основа его предшественника, библиотека Gtk 2, перестала поддерживаться разработчиками. Ситуация требовала кардинального решения.</p>
    <p class="Textbody">Первое решение носило косметический характер. Это был набор MGSE (Mint GNOME Shell Extensions), объединяющий дополнения к GNOME Shell, которые могли обеспечить не только его традиционный интерфейс, но и восполнить недостающий функционал за счёт внешних модулей, таких, как панель Bottompanel, система переключения между окнами Windowlist и меню приложений Menu. Результатом стал выход в ноябре 2011 года релиза Mint 12 Lisa, включавшего в качестве десктопа по умолчанию GNOME 3 с MGSE.</p>
    <p class="Textbody">Однако, видимо, майнтайнерам Mint изначально было ясно, что MGSE — не более, чем паллиатив, и потому, с одной стороны, включили в свой дистрибутив альтернативный десктоп — MATE (первыми среди майнтайнеров распространённых дистрибутивов). А с другой стороны, можно догадаться, что где-то за кадром Клемент Лефевр (Clement Lefebvre), основатель и основной майнтайнер дистрибутива, уже ковал основу совершенно новой оболочки для GNOME 3. Которая стала доступной буквально через месяц после выхода Mint 12 Lisa и получила имя Cinnamon.</p>
    <p class="Textbody">Отступление. Словом cinnamon, восходящим к латыни, в английском языке называют, во-первых, коричное дерево, коричник цейлонский (Cinnamomum zeylanicum) — вечнозелёное растение семейства лавровых. Второе его значение — корица, название пряности, изготовляемой из коры этого дерева. Наконец, слово cinnamon применяется и для именования коричного масла, добываемого из листьев коричника, и используемого в медицине, парфюмерии и косметике. </p>
    <p class="Textbody">Основу Cinnamon'а составил оконный менеджер Muffin — форк аналогичной программы Mutter из GNOME 3. Главное отличие новой оболочки от связки GNOME 3 и MGSE состояло в том, функционал внешних расширений последнего был включён непосредственно в её состав. Это предоставило средства управления взаимодействием между дополнительными функциями и определения порядка их загрузки. В результате были реализованы добавление пиктограмм в область уведомлений, система уведомлений в стиле GNOME 2, возможность изменения позиции панели и и её автоматического скрытия.</p>
    <p class="Textbody">После серии основных и корректирующих релизов, стремительно следующих друг за другим, Cinnamon 1.4 UP1, появившийся 14 мая 2012 года, был включён в качестве штатного десктопа в Mint 13 Maya, анонсированный десять дней спустя. С тех пор выход его версий и стал привязан к релиз-циклу этого дистрибутива.</p>
    <p class="Textbody">Всё это время Cinnamon представлял собой просто оболочку к GNOME 3, надстраивающую «форкнутый» менеджер окон и замещающую собой его штатный GNOME Shell. Он включал все базовые приложения GNOME 3 — терминал, файловый менеджер, текстовый редактор — в неизменном виде. Однако во время подготовки релиза GNOME 3.6, в котором предполагалось существенное ограничение функционала файлового менеджера Nautilus, разработчики Cinnamon начали работы над форком его версии 3.4, назвав её Nemo. Который и попал в релиз Mint 14 Nadia, хотя сначала в качестве альтернативного. Но уже в версии Cinnamon 1.8.X он был интегрирован с этой средой. Кроме того, в этой версии отказались от Центра управления GNOME 3.</p>
    <p class="Textbody">Версии Cinnamon 1.8 суждено было стать последним «чистым» форком GNOME 3 — в это же время полным ходом шла подготовка релиза 2.0. Суть её заключалась в полной замене базовых компонентов GNOME 3 собственными аналогами. То есть — в создании полностью обособленного окружения, не пересекающегося с GNOME 3 и не связанного с ним внешними зависимостями. В результате чего Cinnamon из оболочки для GNOME, вроде GNOME Shell и Unity, превращался в полноценное рабочее окружение. Итог этой деятельности был вынесен на суд общественности 10 октября 2013 года, в виде релиза 2.0.</p>
    <h3 id="toc9"><a id="RefHeading14601713816058"></a><a id="bkmRefHeading14601713816058"></a><a id="toc8"></a><a id="bkmtoc8"></a><a id="RefHeading3281136957987"></a><a id="bkmRefHeading3281136957987"></a><a id="bkmRefHeading3281136957987"></a><a id="bkmbkmRefHeading3281136957987"></a>Особенности</h3>
    <p class="Textbody">Так каковы же особенности нового десктопа, приобретённые им в версии 2.0 и получившие дальнейшее развитие в версиях последующих? Важнейших — три.</p>
    <p class="Textbody">Первая — в Cinnamon гармонично сочетаются старые добрые элементы управления, такие, как главное меню в стиле кнопки Пуск, и элементы модерна, столь привлекающие в Unity, такие, как строка поиска, подобная Dash — но без излишеств последнего, то есть без средств поиска в Интернете всякого рода «парнухи».</p>
    <p class="Textbody">Вторая особенность — достигнутая в Cinnamon гармония между простотой конфигурирования и богатством возможностей последнего. Если настройки в KDE, при их изобилии, приобретают всё более необозримый вид, а в GNOME 3, напротив разубоживаются, в нашем десктопе они почти столь же просты, как в Xfce, и почти столь же изобильны, как в KDE. И, в отличие от Ubuntu, выполняются исключительно штатными средствами, а не бесчисленными твикерами с полуофициальным и вообще неофициальным статусом.</p>
    <p class="Textbody">Третья особенность — аскетизм Cinnamon в отношении штатных приложений. В существующем виде к таковым можно отнести только файловый менеджер Nemo. Обычно богатство приложений считается достоинством интегрированных сред (на то они и зовутся интегрированными). И бедность Cinnamon в этом плане можно было бы отнести к числу её недостатков. Если бы не оборотная сторона медали — отсутствие приложений в штате среды позволяет легко и без избыточности подобрать оптимальный набор рабочих инструментов «для себя».</p>
    <p class="Textbody">Наконец, весь традиционализм Cinnamon'а покоится на весьма современном базисе в виде библиотек Gtk+ 3, что должно обеспечить спокойное развитие этого десктопа в обозримом будущем. При этом сохраняется и совместимость с приложениями на основе Gtk+ 2, до сих пор широко распространёнными и не имеющими адекватных аналогов.</p>
    <h3 id="toc10"><a id="RefHeading14621713816058"></a><a id="bkmRefHeading14621713816058"></a><a id="toc9"></a><a id="bkmtoc9"></a><a id="RefHeading3301136957987"></a><a id="bkmRefHeading3301136957987"></a><a id="bkmRefHeading3301136957987"></a><a id="bkmbkmRefHeading3301136957987"></a>Распространение</h3>
    <p class="Textbody">Тем не менее, несмотря на многочисленные достоинства, десктоп Cinnamon долго не получал широкого распространения в дистрибутивах Linux. И после знакомства с его историей легко понять, почему. В сущности, модель разработки его оказалась противоположно направленной по сравнению со всеми остальными интегрированными средами. Если KDE, Xfce, GNOME, а позднее LXDE и Razot-qt создавались командами разработчиков, более или менее независимыми от майнтайнеров отдельных дистрибутивов, и лишь потом начинали использоваться последними в своих сборках, если MATE представлял собой попытку сохранить наработки GNOME 2, то Cinnamon с первых дней своего существования выглядел «привязанным» к прародительскому Mint. Почти так же, как это имеет место для Ubuntu и Unity — или, по крайней мере, как это воспринимается для последней пары так называемой общественностью.</p>
    <p class="Textbody">На самом деле эта «привязка» была кажущейся, хотя команды разработчиков Mint и Cinnamon действительно были множествами сильно пересекающимися. И политика разработчиков этого десктопа не требует от сторонних разработчиков, скажем, передачи им имущественных прав на свою продукцию, как это практикует фирма Canonical при приёме патчей для Ubuntu и Unity. Однако можно предполагать, что майнтайнеры большинства дистрибутивов отнеслись к Cinnamon настороженно. Тем не менее, некоторые из них поддержали нашу героиню.</p>
    <h3 id="toc11"><a id="RefHeading14641713816058"></a><a id="bkmRefHeading14641713816058"></a><a id="toc10"></a><a id="bkmtoc10"></a><a id="RefHeading3321136957987"></a><a id="bkmRefHeading3321136957987"></a><a id="bkmRefHeading3321136957987"></a><a id="bkmbkmRefHeading3321136957987"></a>Поддержка</h3>
    <p class="Textbody">Если через поиск Distrowatch попытаться найти дистрибутивы, <a href="http://distrowatch.com/search.php?ostype=All&amp;category=All&amp;origin=All&amp;basedon=All&amp;notbasedon=None&amp;desktop=Cinnamon&amp;architecture=All&amp;status=Active" target="_blank">поддерживающие Cinnamon</a>, получится список из 16, на момент сочинения этих строк, позиций. Он не вполне соответствует действительности — с одной стороны, на официальных сайтах некоторых проектов явных упоминаний о поддержке этого десктопа не обнаруживается, с другой — некоторые дистрибутивы, в которых он есть заведомо (например, openSUSE), в нём отсутствуют. Однако, с учётом этого и с исключением явной экзотики из Южной Африки, Андалузии или Непала, оказывается, что Cinnamon поддерживается в десятке распространённых дисрибутивов, среди которых:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Fedora и её клон — Korora; </p>
      </li>
      <li>
        <p class="Textbody">Sabayon — дружественный к пользователю клон Gentoo; </p>
      </li>
      <li>
        <p class="Textbody">Archlinux и его клон Manjaro; </p>
      </li>
      <li>
        <p class="Textbody">openSUSE, где он присутствует в полуофициальном (Semi official) репозитории; </p>
      </li>
      <li>
        <p class="Textbody">siduction — дистрибутив, основанный на unstable-ветке Debian; </p>
      </li>
      <li>
        <p class="Textbody">PC-BSD, которая, конечно, не Linux, но Cinnamon поддерживает на стадии установки. </p>
      </li>
    </ul>
    <p class="Textbody">Я перечислил только те дистрибутивы, в которых поддержка Cinnamon может быть задействована на стадии их установки, и реализацию её проверял лично. Кроме того, Cinnamon нынче можно найти в портах FreeBSD и пакетах DragonFly, в тестовоой ветке Debian, а главное — в ppa-репозиториях Ubuntu. До недавнего времени в последних она поддерживалась Гвендалем Ле Бианном (Gwendal Le Bihan). И, хотя весной 2014 года он отказался от сборки стабильной ветки этой среды, ограничившись экспериментальными «ночными», эстафета была немедленно подхвачена другими майнтайнерами.</p>
    <p class="Textbody">Как я уже сказал, большая часть перечисленных выше систем проверялась мной на предмет поддержки Cinnamon собственноручно. И этот личный опыт показывал, что до недавнего времени качество таковой у всех представителей списка (кроме Ubuntu) оставляло желать лучшего. Это касалось мелких, но часто существенных для применителях деталей, таких, как настройка раскладок клавиатуры и их переключателей.</p>
    <p class="Textbody">Однако буквально в последние месяцы, после выхода Cinnamon 2.4, ситуация изменилась кардинальным образом. И теперь этот десктоп безукоризненно поддерживается в большинстве дистрибутивов первого эшелона — в Archlinux'е и Manjaro, в openSUSE и Fedora, по прежнему хорошо — в Ubuntu, с оговорками на счёт отставания версии — в Debian testing (опять же, говорю только о тех, в которых проверял сам).</p>
    <p class="Textbody">Однако по прежнему наиболее эффективно Cinnamon поддерживается в Mint — за счёт интеграции его с дистрибутив-специфическим системным инструментарием последнего. Подобно тому, как испокон веков KDE было лучше всего интегрировано с openSUSE, GNOME органично срастался с Fedora, а Xfce был «роднее» лёгким клонам Slackware (таким, как Zenwalk и Salix). Так что самый простой способ ознакомиться со средой Cinnamon во всёй её красе — установка соответствующей редакции Mint 17.1 Rebecca, о чём и пойдёт речь в следующем очерке.</p>
    <h2 id="toc12"><a id="RefHeading14661713816058"></a><a id="bkmRefHeading14661713816058"></a><a id="toc11"></a><a id="bkmtoc11"></a><a id="RefHeading12441136957987"></a><a id="bkmRefHeading12441136957987"></a><a id="bkmRefHeading12441136957987"></a><a id="bkmbkmRefHeading12441136957987"></a>Linux Mint: установка</h2>
    <p class="Textbody">Сравнение инсталлятора дистрибутива с театральной вешалкой настолько старо, что никто уже не помнит автора (вашему покорному слуге почему-то кажется, что это был именно он). И за минувшие пятнадцать лет оно не столько даже затёрлось, сколько потеряло силу. В наши дни любой дистрибутив, претендующий на внимание так называемых конечных пользователей, располагает удобной, более или менее функциональной программой установки самого себя, иногда даже красивой. Тем более что удачные решения в этой области имеют обыкновение расползаться по всяким клонам и ремиксам.</p>
    <p class="Textbody">Именно так случилось некогда с инсталлятором Ubuntu — десять лет назад его установка в пять кликов сыграла не последнюю роль и в распространении этого дистрибутива по пользовательским десктопам, и в образовании многочисленных прямых, косвенных и откровенно примазавшихся родственников, вплоть до «дистрибутивов с нескучными обоями».</p>
    <p class="Textbody">В числе родственников... нет, не примазавшихся, а настоящих, но пошедших другим путём, был и дистрибутив Mint. Сейчас не время обсуждать его взаимоотношения с прародительской Ububtu, но программу установки он унаследовал от неё практически без изменений. По крайней мере, до недавнего времени макроскопических различий в инсталляторах этих систем не наблюдалось.</p>
    <p class="Textbody">Честно говоря, их не наблюдается и сейчас, с выходом версии Mint 17, а затем и Mint 17.1 — формально отличий в установке с Ubuntu 14.04 нет. Так что о чём тут говорить, спросите вы меня? Отвечу: говорить действительно не о чем — это нужно видеть. Точнее, делать своими руками — и наблюдать за результатом. Ибо даже скриншоты, которыми я на этой странице практически и ограничусь, не в силах передать того ощущения лёгкости и плавности, которое испытывает истинный применитель при установке этого дистрибутива.</p>
    <p class="Textbody">Итак, установка Mint'а запускается из Live-режима его работы, являющегося следствием загрузки с соответствующего носителя — DVD или, что предпочтительно, флешки (или SD-карты). Кстати, не обязательно слушать того, кто будет убеждать вас закатать iso-образ на твердотельный носитель с помощью всяких специальных утилит. С этой задачей прекрасно справляется такая команда:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># dd if=path3/linuxmint-17.1-cinnamon-64bit.iso</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">of=/dev/sd? bs=8M</span> </p>
    <p class="Textbody">Символ решётки тут символизирует, что она должна быть дана от имени администратора (то есть в Ubuntu и её клонах — в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo dd...</span> </p>
    <p class="Textbody">и так далее. Имя входящего файла образа выбрано так потому, что дальнейший рассказ у меня пойдёт исключительно о Cinnamon-редакции соответствующего релиза. Хотя, надо отметить, что установка MATE- и Xfce-редакций ничем не отличается, только инсталлятор редакции с KDE имеет некоторую специфику,</p>
    <p class="Textbody">Вместо знака вопроса следует подставить литеру своего твердотельного устройства — подчёркиваю, именно устройства целиком, а не раздела на нём. Ну а значение bs (размер блока записи) взято с потолка: если не задать этот параметр, запись будет идти блоками по 512 байт, и это будет очень медленно и печально.</p>
    <p class="Textbody">Конечно, использование для записи iso-образа на флешку/карточку всякого рода графических утилит тоже не возбраняется. Важно только помнить, что многие из них — дистрибутив-специфичны. Этому вопросу на Блогосайте посвящена специальная статья: <a href="http://alv.me/?p=7245">Дистро в твёрдом теле</a>.</p>
    <p class="Textbody">Так или иначе, но флешка будет записана и с неё произойдёт загрузка системы — автоматически, если в ходе её ничего не делать, или, если в течении 10 секунд нажать любую клавишу, из такого меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_001.png">
        <img alt="Изображение2" class="frameGraphics" id="2graphic" src="http://alv.me/wp-content/img/im_cin_img/install_001-572x483.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:484.82898px" />
      </a>
      <a id="a2graphic"></a>
      <a id="bkm2graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/install_001.png"> </a>
    </p>
    <p class="Textbody">После чего мы оказываемся в live-среде Cinnamon — пора бросить на неё взгляд, пока беглый:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_002.png">
        <img alt="Изображение3" class="frameGraphics" id="3graphic" src="http://alv.me/wp-content/img/im_cin_img/install_002-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a3graphic"></a>
      <a id="bkm3graphic"></a>
    </p>
    <p class="Textbody">Вдаваться в её рассмотрение сейчас не стоит — для этого у нас будет много времени после установки, к которой и приступаем. Как нетрудно догадаться, запуск инсталлятора осуществляется щелчком на пиктограмме с соответствующей подписью — Install Linux Mint. И начинается процесс с предложения выбрать язык установки — по умолчанию английский:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_003.png">
        <img alt="Изображение4" class="frameGraphics" id="4graphic" src="http://alv.me/wp-content/img/im_cin_img/install_003-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a4graphic"></a>
      <a id="bkm4graphic"></a>
    </p>
    <p class="Textbody">Однако, если у вас нет непреодолимого отвращения к языку родных осин, но есть желание без лишних трудозатрат иметь корректно локализованную систему, выбирайте русский, не пожалеете. Это будет язык не только интерфейса инсталлятора, но и грядущей инсталлированной системы:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_004.png">
        <img alt="Изображение5" class="frameGraphics" id="5graphic" src="http://alv.me/wp-content/img/im_cin_img/install_004-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a5graphic"></a>
      <a id="bkm5graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/install_004.png"> </a>
    </p>
    <p class="Textbody">Русификация Cinnamon до недавнего времени была далека от идеала, и со смесью нижегородского с оксфордским приходилось сталкиваться сталкиваться довольно часто. Однако в версии 2.4 ситуация резко улучшилась, и языковый микст можно увидеть только в единичных случаях.</p>
    <p class="Textbody">Далее выдвигаются претензии к объёму свободного места и подключению к Интернету — приведённой цифрой первого и потребностью во втором нынче испугать трудно:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_006.png">
        <img alt="Изображение6" class="frameGraphics" id="6graphic" src="http://alv.me/wp-content/img/im_cin_img/install_006-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a6graphic"></a>
      <a id="bkm6graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/install_006.png"> </a>
    </p>
    <p class="Textbody">Следующий этап — разметка диска. Здесь надо действовать по амбициям и амунициям, так что просто прокомментирую пукты соответствующего меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_007.png">
        <img alt="Изображение7" class="frameGraphics" id="7graphic" src="http://alv.me/wp-content/img/im_cin_img/install_007-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a7graphic"></a>
      <a id="bkm7graphic"></a>
    </p>
    <p class="Textbody">Очевидно, что отмеченный по умолчанию пункт Стереть диск и установить Linux Mint подходит только для установки на «чистый» носитель или такой, содержимым которого можно безболезненно пожертвовать. Причём именно всего устройства, а не какого-либо его раздела, ибо в этом варианте диск будет переразмечен полностью, начиная с таблицы разделов.</p>
    <p class="Textbody">Об установке системы на шифрованный раздел (пункт второй) сказать ничего не могу, так как никогда не пробовал (и сомневаюсь в необходимости в обычных «настольных» условиях). Установка с использованием LVM (Logical Volume Manager) показалась мне не очень прозрачной, и я её тоже не опробовал. Но со временем расскажу, как задействовать LVM в уже инсталлированной системе. И потому я всегда выбираю Другой вариант: он подразумевает разметку диска вручную. Как её выполнить — говорено и переговорено на бесчисленных ресурсах в Сети: тут всё зависит от ситуации, потребностей и возможностей. Так что просто приведу несколько скриншотов, иллюстрирующих самый простой случай — разметку одиночного «чистого» на два раздела — корневой и под будущий домашний каталог (каковой, кстати, в умолчальном первом варианте не создаётся).</p>
    <p class="Textbody">Итак, перед нами чистый, неразмеченный диск:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_008.png">
        <img alt="Изображение8" class="frameGraphics" id="8graphic" src="http://alv.me/wp-content/img/im_cin_img/install_008-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a8graphic"></a>
      <a id="bkm8graphic"></a>
    </p>
    <p class="Textbody">Можно видеть, что ни одна из кнопок манипуляции разделами (+, -, Change) не активизирована, ибо диск наш лишён таблицы разделов. Которую и надо в первую очередь создать, нажав соответствующую кнопку. Ответом будет предупреждение о том, что все ранее существовавшие разделы будут уничтожены. Поскольку их всё равно нет, соглашаемся на это:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_009.png">
        <img alt="Изображение9" class="frameGraphics" id="9graphic" src="http://alv.me/wp-content/img/im_cin_img/install_009-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a9graphic"></a>
      <a id="bkm9graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/install_009.png"> </a>
    </p>
    <p class="Textbody">В результате будет создана таблица разделов в стиле MSDOS. Создание GPT-разметки не предусмотрено, но если диск был предварительно размечен в этом стиле — он прекрасно воспримется инсталлятором.</p>
    <p class="Textbody">Теперь активизируется кнопка с плюсиком — очевидно, что она служит для создания разделов. Однако, прежде чем заняться этим делом, бросим взгляд на строку Устройство для установки системного загрузчика, каковым на скриншоте выступает /dev/sda. То есть загрузчик будет установлен в MBR первого диска, что для «чистой» однодисковой (и к тому же виртуальной) конфигурации вполне естественно. А вот в случае какой-либо уже установленной системы, особенно при наличии двух и более дисков, этот момент требует внимания.</p>
    <p class="Textbody">Дело, однако, в том, что первый диск (то есть устройство /dev/sda) будет по умолчанию целевым для установки загрузчика вне зависимости от того, на какой диск и или раздел устанавливается Mint, что в большинстве таких случаев не только не нужно, но и прямо вредит здоровью сосуществующих систем. И потому надо ни в коем случае не забыть выбрать из выпадающего меню нужное устройство — MBR диска или PBR раздела, целевых при установке Mint.</p>
    <p class="Textbody">К сожалению, вообще отказаться от установки загрузчика нельзя, даже когда он заведомо лишний, и Mint предполагается загружать через загрузчик какой-либо иной системы. Эта багофича унаследована от Ubuntu, где существует испокон веков. Но можно обмануть установщик, подсунув ему в качестве целевого MBR какого-либо «левого» устройства, например, старой ненужной флешки или SD-карты, каковые потом просто извлекаются, как-будто так и было.</p>
    <p class="Textbody">Вот теперь со спокойной душой можно приступать к созданию разделов, нажав кнопку с плюсиком. Проделываем эту процедуру сначала для корневого раздела:</p>
    <p class="Textbody"><a href="http://alv.me/wp-content/img/2014/12/install_010.png"><img alt="Изображение10" class="frameGraphics" id="10graphic" src="http://alv.me/wp-content/img/im_cin_img/install_010-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" /></a><a id="a10graphic"></a><a id="bkm10graphic"></a>А затем для раздела под будущий каталог /home:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_012.png">
        <img alt="Изображение11" class="frameGraphics" id="11graphic" src="http://alv.me/wp-content/img/im_cin_img/install_012-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a11graphic"></a>
      <a id="bkm11graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/install_012.png"> </a>
    </p>
    <p class="Textbody">И в результате получаем вот такую картину:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_013.png">
        <img alt="Изображение12" class="frameGraphics" id="12graphic" src="http://alv.me/wp-content/img/im_cin_img/install_013-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a12graphic"></a>
      <a id="bkm12graphic"></a>
    </p>
    <p class="Textbody">По умолчанию в обоих случаях предлагается файловая система Ext4. Если она почему-либо не устраивает — можно ознакомиться со списком доступных, он включает все нативные файловые системы Linux'а, кроме ReiserFS:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_011.png">
        <img alt="Изображение13" class="frameGraphics" id="13graphic" src="http://alv.me/wp-content/img/im_cin_img/install_011-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a13graphic"></a>
      <a id="bkm13graphic"></a>
    </p>
    <p class="Textbody">Должен заметить, что на стадии установки в Mint не только нельзя создать, скажем, программный RAID (в отличие от Ubuntu, в которой это уже предусмотрено): нельзя даже установить систему на softRAID, созданный заблаговременно, инсталлятор его просто не увидит. Впрочем, в дальнейшем, после установки, ни подключить существующий RAID, ни слздать его заново труда не составит, о чём будет говориться в соответствующем очерке.</p>
    <p class="Textbody">Как можно было видеть, в приведённой схеме разметки отсутствует раздел подкачки. О чём и будет сообщено на следующей стадии:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_014.png">
        <img alt="Изображение14" class="frameGraphics" id="14graphic" src="http://alv.me/wp-content/img/im_cin_img/install_014-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a14graphic"></a>
      <a id="bkm14graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/install_014.png"> </a>
    </p>
    <p class="Textbody">Нужен такой или нет — вопрос спорный и многократно обсуждавшийся. На мой взгляд, при памяти от 4 ГБ в большинстве случаев, кроме некоторых специальных, не нужен. Так что можно продолжать — это действие вызовет последнее китайское предупреждение:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_015.png">
        <img alt="Изображение15" class="frameGraphics" id="15graphic" src="http://alv.me/wp-content/img/im_cin_img/install_015-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a15graphic"></a>
      <a id="bkm15graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/install_015.png"> </a>
    </p>
    <p class="Textbody">Смысл его в русском переводе может показаться не вполне внятым. Он сводится к тому, что все действия по разметке диска будут выполнены только сейчас, но после этого возврат к прошлому станет невозможным — до сих пор установку можно было в любой момент прервать, сохранив исходное состояние диска.</p>
    <p class="Textbody">Поскольку бояться нам нечего, нажимаем кнопку Продолжить. И, после некоторого времени, требующегося на разметку и создание файловых систем, совершаем последние манипуляции — настройку часов, клавиатуры и создание пользовательского аккаунта.</p>
    <p class="Textbody">С выбором часового пояса всё понятно без комментариев — при выборе русского языка инсталляции он будет московским и подразумевать установку «железных» часов по UTC:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_016.png">
        <img alt="Изображение16" class="frameGraphics" id="16graphic" src="http://alv.me/wp-content/img/im_cin_img/install_016-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a16graphic"></a>
      <a id="bkm16graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/install_016.png"> </a>
    </p>
    <p class="Textbody">Так что обитателям более иных городов и весей нашей необъятной Родины следует не забыть внести нужные изменения — это можно сделать, просто ткнув курсором мыши в район Петропавловска Камчатского (Улан-Удэ, Новосибирска — нужное дописать).</p>
    <p class="Textbody">А вот вопрос с раскладкой внимания заслуживает: выбранная сейчас, она останется и в инсталлированной системе. Опять же при выборе русского языка инсталлятора по умолчанию и раскладка клавиатуры предлагается русская — в данном случае под этим понимается вариант winkeys:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_017.png">
        <img alt="Изображение17" class="frameGraphics" id="17graphic" src="http://alv.me/wp-content/img/im_cin_img/install_017-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a17graphic"></a>
      <a id="bkm17graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/install_017.png"> </a>
    </p>
    <p class="Textbody">Он устроит большинство применителей — но не таких старых «печатно-машинистов», как автор этих строк. Что же, никто не запрещает выбрать вариант Typewriter Legacy — это раскладка советских пишущих машинок, почему-то объявленная устаревшей. И даже опробовать его в деле, переключаясь с латиницы на кириллицу через Alt+Shift:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_018.png">
        <img alt="Изображение18" class="frameGraphics" id="18graphic" src="http://alv.me/wp-content/img/im_cin_img/install_018-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a18graphic"></a>
      <a id="bkm18graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/install_018.png"> </a>
    </p>
    <p class="Textbody">Смены переключателя раскладок на стадии установки не предусмотрено — её можно будет поменять потом, средствами Cinnamon. Зато установленная сейчас раскладка сохранится после установки не только в Иксах, но и в «голой» консоли. Причём даже такая нетипичная, как при моём выборе. Это чуть ли не уникальный случай — в других дистрибутивах для консоли раскладку Typewriter Legacy мне приходилось изготавливать самому.</p>
    <p class="Textbody">В деле создания пользовательского аккаунта всё очевидно. Замечу только, что раскрывать своё подлинное имя здесь не обязательно — это поле можно просто оставить пустым. А вот задать имя компьютера необходимо — без этого не активизируется кнопка Продолжить. Впрочем, в большинстве случаев оно может быть произвольным. Ну а требовать ли от самого себя пароль для входа в систему или нет — дело чести, подвига и геройства личной паранойи:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_019.png">
        <img alt="Изображение19" class="frameGraphics" id="19graphic" src="http://alv.me/wp-content/img/im_cin_img/install_019-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a19graphic"></a>
      <a id="bkm19graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/install_019.png"> </a>
    </p>
    <p class="Textbody">После этого начинается собственно установка, то есть перенос системы на целевой носитель:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_020.png">
        <img alt="Изображение20" class="frameGraphics" id="20graphic" src="http://alv.me/wp-content/img/im_cin_img/install_020-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a20graphic"></a>
      <a id="bkm20graphic"></a>
    </p>
    <p class="Textbody">В Ubuntu это делается весьма неторопливо. В инсталляторе же Mint едва успеваешь заварить себе кофий или выкурить сигарету, как обнаруживаешь на экране вот такое сообщение:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_021.png">
        <img alt="Изображение21" class="frameGraphics" id="21graphic" src="http://alv.me/wp-content/img/im_cin_img/install_021-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a21graphic"></a>
      <a id="bkm21graphic"></a>
    </p>
    <p class="Textbody">После которого только и остаётся, что перезагрузиться. Правда, после этого будет ещё одно сообщение:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/install_022.png">
        <img alt="Изображение22" class="frameGraphics" id="22graphic" src="http://alv.me/wp-content/img/im_cin_img/install_022-572x366.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:367.85263px" />
      </a>
      <a id="a22graphic"></a>
      <a id="bkm22graphic"></a>
    </p>
    <p class="Textbody">Если установка проводилась с DVD-диска, он будет извлечён из привода автоматически, и Enter можно нажимать сразу. Если с флешки или SD-карты — соответствующее устройство желательно предварительно удалить. Ну а что получилось в результате инсталляции — будет рассказано в следующем очерке.</p>
    <h2 id="toc13"><a id="RefHeading14681713816058"></a><a id="bkmRefHeading14681713816058"></a><a id="toc12"></a><a id="bkmtoc12"></a><a id="RefHeading12461136957987"></a><a id="bkmRefHeading12461136957987"></a><a id="bkmRefHeading12461136957987"></a><a id="bkmbkmRefHeading12461136957987"></a>Mint и Cinnamon: обзор среды</h2>
    <p class="Textbody">Предыдущий очерк мы завершили тем, что после удачной установки отправили машину на перезагрузку. После которой, проскочив меню GRUB'а (в случае одной системы по умолчанию оно не выводится), оказываемся в дисплейном менеджере MDM с предложением авторизоваться:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_001.png">
        <img alt="Изображение23" class="frameGraphics" id="23graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_001-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a23graphic"></a>
      <a id="bkm23graphic"></a>
    </p>
    <p class="Textbody">По принятии этого предложения перед нами предстаёт рабочий стол Cinnamon с экраном приветствия:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_002.png">
        <img alt="Изображение24" class="frameGraphics" id="24graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_002-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a24graphic"></a>
      <a id="bkm24graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_002.png"> </a>
    </p>
    <p class="Textbody">И о дисплейном менеджере, и об экране приветствия случай поговорить ещё будет. Нынешний эе очерк будет посвящён интерфейсу рабочего стола Cinnamon, так как именно там в основном будет проходить деятельность применителя, избравшего соответствующую редакцию дистрибутива Mint.</p>
    <h3 id="toc14"><a id="RefHeading14701713816058"></a><a id="bkmRefHeading14701713816058"></a><a id="toc13"></a><a id="bkmtoc13"></a><a id="RefHeading3341136957987"></a><a id="bkmRefHeading3341136957987"></a><a id="bkmRefHeading3341136957987"></a><a id="bkmbkmRefHeading3341136957987"></a>Cinnamon. Общий вид</h3>
    <p class="Textbody">При первом своём запуске Cinnamon выглядит более чем традиционно – перед нами самый обычный рабочий стол с управляющей панелью, на которой имеется кнопка с подписью Меню (или Menu, в зависимости от локализации):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_003.png">
        <img alt="Изображение25" class="frameGraphics" id="25graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_003-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a25graphic"></a>
      <a id="bkm25graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_003.png"> </a>
    </p>
    <p class="Textbody">В отличие от GNOME Shell'а или Unity, здесь сразу ясно, что делать дальше. Во-первых, можно щёлкнуть правой кнопкой мыши по рабочему столу, чтобы увидеть его контекстное меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_004.png">
        <img alt="Изображение26" class="frameGraphics" id="26graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_004.png" style="border:1.0px solid #000080;padding:0;width:362.82584px;height:386.82584px" />
      </a>
      <a id="a26graphic"></a>
      <a id="bkm26graphic"></a>
    </p>
    <p class="Textbody">Здесь почти всё понятно без комментариев, пару слов можно сказать только про два пункта:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Добавить десклеты – добавление на рабочий стол мини-приложений (подробнее об этом будет сказано в следующем очерке); </p>
      </li>
      <li>
        <p class="Textbody">Открыть как администратор – вызов, после ввода пароля, файлового менеджера Nemo с правами суперпользователя. </p>
      </li>
    </ul>
    <p class="Textbody">Во-вторых, щёлкнув правой же кнопкой мыши по свободному полю управляющей панели, можно заняться её настройками (о чём будет разговор в соответствующем очерке):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_005.png">
        <img alt="Изображение27" class="frameGraphics" id="27graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_005.png" style="border:1.0px solid #000080;padding:0;width:333.83685px;height:295.85257px" />
      </a>
      <a id="a27graphic"></a>
      <a id="bkm27graphic"></a>
    </p>
    <p class="Textbody">Или, уже с помощью левой кнопки, вызвать одно из приложений, пиктограммы запуска которых уже имеются на панели. По умолчанию их не густо – браузер Firefox, унаследованный от GNOME терминал и файловый менеджер Nemo:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_006.png">
        <img alt="Изображение28" class="frameGraphics" id="28graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_006.png" style="border:1.0px solid #000080;padding:0;width:199.85262px;height:53.84945px" />
      </a>
      <a id="a28graphic"></a>
      <a id="bkm28graphic"></a>
    </p>
    <p class="Textbody">Но пополнить панель иконками приложений первой необходимости труда не составит – и со временем я расскажу, как.</p>
    <p class="Textbody">Наконец, в-третьих, можно обратиться к главному меню Cinnamon для знакомства со всем изобилием установленного софта:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_007.png">
        <img alt="Изображение29" class="frameGraphics" id="29graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_007-572x496.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:497.83054px" />
      </a>
      <a id="a29graphic"></a>
      <a id="bkm29graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_007.png"> </a>
    </p>
    <p class="Textbody">Но обзор штатных приложений дистрибутива будет дан в соответствующем очерке.</p>
    <p class="Textbody">Как и во всех современных рабочих средах, в Cinnamon'е можно задействовать несколько виртуальных рабочих столов. В терминах этой среды они называются рабочими областями (Workspaces), и по умолчанию их два. Переключение между рабочими областями – комбинациями клавиш Control+Alt+Right/Left.</p>
    <p class="Textbody">Есть и другие способы переключения между рабочими областями, и количество их можно увеличить до любого разумного предела. Но это относится уже к категории настроек, которым будет посвящён отдельный очерк.</p>
    <h3 id="toc15"><a id="RefHeading14721713816058"></a><a id="bkmRefHeading14721713816058"></a><a id="toc14"></a><a id="bkmtoc14"></a><a id="RefHeading3361136957987"></a><a id="bkmRefHeading3361136957987"></a><a id="bkmRefHeading3361136957987"></a><a id="bkmbkmRefHeading3361136957987"></a>Управляющая панель</h3>
    <p class="Textbody">Если на рабочем столе (точнее, в рабочих его областях) происходят основные события, то управление этими событиями в значительной мере осуществляется с панели – в других средах её часто называют главной, или управляющей. Но в Cinnamon её принято называть без определений, поскольку здесь она обычно имеется в единственном экземпляре. Хотя в принципе в нём может быть включена и вторая панель, о чём речь пойдёт в очерке о настройках.</p>
    <p class="Textbody">Положение панели по умолчанию – вдоль нижней части экрана, хотя её можно переместить и наверх. И разделяется она на следующие части (слева направо):</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody" style="text-align:left">кнопка главного меню (опять же – обычно просто Меню);</p>
      </li>
      <li>
        <p class="Textbody" style="text-align:left">область запуска приложений (Panel Launcher) с пиктограммами – как уже было сказано, по умолчанию их всего три;</p>
      </li>
      <li>
        <p class="Textbody">область открытых приложений (Window list); </p>
      </li>
      <li>
        <p class="Textbody">область системных сообщений (Notifications); </p>
      </li>
      <li>
        <p class="Textbody">системный лоток (System Tray), куда помещаются пиктограммы «перманентно работающих» приложений; </p>
      </li>
      <li>
        <p class="Textbody">несколько пиктограмм разного назначения – список открытых окон (Windows Quick List) и подключаемых накопителей (Removable Drives), модуль сетевых соединений, регулятор громкости, часы, индикатор раскладки клавиатуры, пиктограмма менеджера обновлений. </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_008.png">
        <img alt="Изображение30" class="frameGraphics" id="30graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_008.png" style="border:1.0px solid #000080;padding:0;width:185.83055px;height:44.85417px" />
      </a>
      <a id="a30graphic"></a>
      <a id="bkm30graphic"></a>
    </p>
    <p class="Textbody">Кроме того, имеется «пользовательская кнопка» – она показывает сведения о текущем аккаунте, вызывает системные настройки, через неё блокируется экран и переключаются пользователи, осуществляется вход в так называемый «гостевой» сеанс, а также выполняется завершение сеанса работы, перезагрузка машины и её выключение:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_009.png">
        <img alt="Изображение31" class="frameGraphics" id="31graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_009.png" style="border:1.0px solid #000080;padding:0;width:315.8463px;height:402.85104px" />
      </a>
      <a id="a31graphic"></a>
      <a id="bkm31graphic"></a>
    </p>
    <p class="Textbody">Все области и кнопки панели представляют собой так называемые апплеты – мелкие программки, не способные к самостоятельному функционированию. Некоторые из этих апплетов (Panel Launcher, Window list, System Tray) представляют собой контейнеры для помещёния в них других пиктограмм (запуска, открытых окон, и так далее), другие же существуют как бы сами по себе.</p>
    <p class="Textbody">Апплеты могут добавляться на панель и удаляться с неё. Содержимое апплетов-контейнеров добавляется или автоматически (System Tray, Window list), или вручную (Panel Launcher). Удаление апплетов-контейнеров приводит к исчезновению всего их содержимого. Элементы из лаунчера можно удалять по одному, содержимое лотка и области приложений – вместе с закрытием соответствующих программ.</p>
    <h3 id="toc16"><a id="RefHeading14741713816058"></a><a id="bkmRefHeading14741713816058"></a><a id="toc15"></a><a id="bkmtoc15"></a><a id="RefHeading3381136957987"></a><a id="bkmRefHeading3381136957987"></a><a id="bkmRefHeading3381136957987"></a><a id="bkmbkmRefHeading3381136957987"></a>Главное меню</h3>
    <p class="Textbody">Центральным (хотя и левым крайним) элементом панели является, безусловно, главное меню, с которым и настало время ознакомиться подробнее. На первый взгляд оно ничем не отличается от обычных менюшек «пускового» типа, с их страшной многоступенчатой иерархией. Однако если вглядеться в соответствующий скриншот ещё раз – различия обнаруживаются, и весьма существенные:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_010.png">
        <img alt="Изображение32" class="frameGraphics" id="32graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_010-572x495.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:496.84787px" />
      </a>
      <a id="a32graphic"></a>
      <a id="bkm32graphic"></a>
    </p>
    <p class="Textbody">Перво-наперво, обратим внимание на колонку пиктограмм вдоль левого края поля меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_011.png">
        <img alt="Изображение33" class="frameGraphics" id="33graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_011.png" style="border:1.0px solid #000080;padding:0;width:107.8589px;height:525.83685px" />
      </a>
      <a id="a33graphic"></a>
      <a id="bkm33graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_011.png"> </a>
    </p>
    <p class="Textbody">Набор их в сборке Cinnamon для Mint включает иконки для запуска:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">браузера Firefox; </p>
      </li>
      <li>
        <p class="Textbody">менеджера программ mintinstall; </p>
      </li>
      <li>
        <p class="Textbody">Центра управления (он же – Системные настройки); </p>
      </li>
      <li>
        <p class="Textbody">терминала; </p>
      </li>
      <li>
        <p class="Textbody">файлового менеджера Nemo. </p>
      </li>
    </ul>
    <p class="Textbody">Кроме того, имеются значки блокировки экрана, выхода из сеанса и завершения работы. Конечно, к последним действиям можно получить доступ и через User Applet панели, но там его ещё надо разглядеть и до действий докопаться, а тут они всегда на виду.</p>
    <p class="Textbody">Не менее примечательна поисковая строка в верхней части экрана – она предназначена для поиска приложений. Но не простого, а золотого инкрементного. То есть, введя в ней последовательность символов libre, мы получим список только тех пунктов меню, которые её содержат, то есть компонентов LibreOffice:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_012.png">
        <img alt="Изображение34" class="frameGraphics" id="34graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_012-572x508.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:509.8495px" />
      </a>
      <a id="a34graphic"></a>
      <a id="bkm34graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_012.png"> </a>
    </p>
    <p class="Textbody">То есть строка поиска в меню Cinnamon тихо и скромно, без шума и пыли выполняет ту же функцию, что и пресловутый Dash в Unity (и его аналог в GNOME 3). Правда, с её помощью нельзя устанавливать программы или искать «парнуху» в Интернете – но не больно-то и хотелось.</p>
    <p class="Textbody">А вот искать по русским словам – с некоторыми ограничениями можно. Введя, например, слово редактор, мы увидим приложения, содержащие его в своём имени:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_013.png">
        <img alt="Изображение35" class="frameGraphics" id="35graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_013-572x499.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:500.85416px" />
      </a>
      <a id="a35graphic"></a>
      <a id="bkm35graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_013.png"> </a>
    </p>
    <p class="Textbody">А на слово текст ответом будет список приложений, содержащих его и в описании:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_014.png">
        <img alt="Изображение36" class="frameGraphics" id="36graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_014-572x502.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:503.84003px" />
      </a>
      <a id="a36graphic"></a>
      <a id="bkm36graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_014.png"> </a>
    </p>
    <p class="Textbody">На мой взгляд, сказанного уже достаточно, чтобы проникнуться величием среды Cinnamon. Однако это ещё не всё – оно проявляется и в управлении окнами. Однако прежде чем говорить на эту тему – остановимся на вопросе, как эти окна открывать.</p>
    <h3 id="toc17"><a id="RefHeading14761713816058"></a><a id="bkmRefHeading14761713816058"></a><a id="toc16"></a><a id="bkmtoc16"></a><a id="RefHeading3401136957987"></a><a id="bkmRefHeading3401136957987"></a><a id="bkmRefHeading3401136957987"></a><a id="bkmbkmRefHeading3401136957987"></a>Вызов приложений</h3>
    <p class="Textbody">Открываются окна обычно вместе с запущенными в них приложениями. Способов же запуска последних в Cinnamon, как и во всех современных десктопах, несколько.</p>
    <p class="Textbody">Первый, наиболее универсальный – запуск из командной строки терминала путём ввода соответствующей команды. Однако обычно полноразмерное терминальное окно использовать для этого не целесообразно, его вполне можно заменить панелью мини-терминала – она вызывается обычной для всех десктопов комбинацией клавиш Alt+2:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_015.png">
        <img alt="Изображение37" class="frameGraphics" id="37graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_015.png" style="border:1.0px solid #000080;padding:0;width:455.84px;height:113.83055px" />
      </a>
      <a id="a37graphic"></a>
      <a id="bkm37graphic"></a>
    </p>
    <p class="Textbody">До некоторого времени панель мини-терминала в Cinnamon не блистала функциональностью – в ней не было ни автоподолнения, ни истории команд, имелась только возможность ввести команду руками или вставить её из буфера. Однако в Cinnamon 2.6 все эти прелести появились. Историю команд можно, как и в шелле, просмотреть с помощью стрелок Up и Down. И автодополнение команды происходит после набора первых трёх символов её имени, в случае альтернатив выводя все доступные варианты:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/cinnamon_015a.png">
        <img alt="Изображение38" class="frameGraphics" id="38graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_015a.png" style="border:1.0px solid #000080;padding:0;width:384.8227px;height:183.82741px" />
      </a>
      <a id="a38graphic"></a>
      <a id="bkm38graphic"></a>
    </p>
    <p class="Textbody">Правда, при вызове панели минитерминала блокируются как любые любые действия мышью, так и ввод с клавиатуры. Открывается она всегда по центру, и перемещёнию не поддаётся. Так что пользоваться этой панелью не всегда удобно. Однако её возможности сполна, а то и с лихвой, заменяются функциями строки инкрементного поиска в главном меню, о которой только что говорилось. Именно она становится основным инструментом запуска приложений для тех применителей, которым, как автору этих строк, проще набрать несколько символов из имени программы, нежели, подобно Баяну, «мысью рыскать» в её поисках по менюшному древу. Тем более, что привычные программы, вызываемые давно памятными командами, в меню, тем более русифицированном, могут носить самые неожиданные имена, и потому опознаваться с трудом.</p>
    <p class="Textbody">Сразу по вызове главного меню мышью или хоткеем (в Cinnamon, как и в Unity, для этого по умолчанию зарезервирована левая win-клавиша, она же Super_L), строка поиска находится в фокусе ввода, и можно начинать набор имени приложения. Только нужно помнить про раскладку клавиатуры: как бы ни было настроено её наследование (о чём речь пойдёт в одном из следующих очерков), в этой строке она всегда будет наследоваться от раскладки последнего активного окна, а не от раскладки по умолчанию.</p>
    <p class="Textbody">Разумеется, для запуска приложений можно пользоваться и главным меню непосредственно, тем более что некоторые из них (браузер, терминал, Центр управления, файловый менеджер), как только что говорилось, вынесены в нём на отдельную панель в виде кнопок быстрого запуска. А вот остальные программы в меню уже надо поискать – тем более что, повторяю, там они могут именоваться весьма причудливо.</p>
    <p class="Textbody">Благо, пиктограммы наиболее востребованных приложений из меню можно поместить в Launcher на главной панели, на рабочий стол или в пункт Избранное. Для этого достаточно щёлкнуть правой кнопкой на имени нужной программы и из контекстного меню выбрать требуемый пункт:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_016.png">
        <img alt="Изображение39" class="frameGraphics" id="39graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_016-572x497.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:498.85104px" />
      </a>
      <a id="a39graphic"></a>
      <a id="bkm39graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_016.png"> </a>
    </p>
    <p class="Textbody">Кроме того, иконки приложений можно просто перетаскивать мышью из меню в Launcher. Причём – сразу в желаемое его место, тогда как при автоматическом помещёнии иконок они попадают в его конец, и их перетасовка потребует дополнительных телодвижений.</p>
    <p class="Textbody">Как только что было сказано, пиктограммы запуска приложений можно поместить и на рабочий стол, и запускать их оттуда. Однако я этим способом никогда не пользуюсь — он кажется мне неудобным, и и рабочего стола у меня обычно не видать за распахнутыми окнами.</p>
    <p class="Textbody">Вот теперь, разобравшись с запуском приложений и открытием вмещающих их окон, можно переходить и к управлению последними.</p>
    <h3 id="toc18"><a id="RefHeading14781713816058"></a><a id="bkmRefHeading14781713816058"></a><a id="toc17"></a><a id="bkmtoc17"></a><a id="RefHeading3421136957987"></a><a id="bkmRefHeading3421136957987"></a><a id="bkmRefHeading3421136957987"></a><a id="bkmbkmRefHeading3421136957987"></a>Управление окнами</h3>
    <p class="Textbody">В предыдущем разделе очерка речь шла о способах запуска приложений, в этом же поговорим о способах управления приложениями, которые уже запущены. Поскольку мы (пока ещё) живём в системе, которая официально называется X Window System, то большая часть приложений запускается в её окнах. Так что в основном применителю придётся иметь дело с ними.</p>
    <p class="Textbody">Вид окон с запущенными приложениями зависит от темы рабочего стола, стиля окон и других индивидуальных настроек. Но по умолчанию они выглядят примерно так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_017.png">
        <img alt="Изображение40" class="frameGraphics" id="40graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_017-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a40graphic"></a>
      <a id="bkm40graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_017.png"> </a>
    </p>
    <p class="Textbody">Управление окнами подразумевает в первую очередь переключение между ними. Что можно сделать несколькими способами. Первый, напрашивающийся, щелчком любой кнопкой мыши в области окна. В этом случае окну передаётся фокус и оно, как принято говорить, «поднимается», то есть оказывается на первом плане. Просто перевод курсора мыши на другое окно переводит его в фокус (то есть оно может скроллироваться), но не поднимает.</p>
    <p class="Textbody">Как можно видеть на скриншоте, в одной рабочей области может быть открыто несколько окон, которые могут частично или полностью перекрываться. И тогда универсальный универсальный способ переключения между окнами, существующий во всех графических средах, – комбинация клавиш Alt+Tab. Удержание её в нажатом состоянии выводит ленту значков открытых окон, с миниатюрой для окна активного:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_018.png">
        <img alt="Изображение41" class="frameGraphics" id="41graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_018-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a41graphic"></a>
      <a id="bkm41graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_018.png"> </a>
    </p>
    <p class="Textbody">Третий способ переключения между окнами – область Window List на управляющей панели:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_019.png">
        <img alt="Изображение42" class="frameGraphics" id="42graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_019-572x30.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:31.852598px" />
      </a>
      <a id="a42graphic"></a>
      <a id="bkm42graphic"></a>
    </p>
    <p class="Textbody">Есть ещё переход в режим масштабирования рабочей области, но по умолчанию этот способ отключен, поэтому я вернусь к нему чуть позже.</p>
    <p class="Textbody">Сказанное относится к переключению между окнами, расположенными в одной рабочей области. Но они могут пребывать и в разных областях – как мы помним, по умолчанию их две. И в этом случае один из способов переключения между ними, имеющийся «из коробки» – апплет Windows Quick List (в последних версиях Cinnamon он помещён на панели по умолчанию):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_020.png">
        <img alt="Изображение43" class="frameGraphics" id="43graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_020-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a43graphic"></a>
      <a id="bkm43graphic"></a>
    </p>
    <p class="Textbody">Второй же – переход в режим Expo через один из «горячих углов», о чём также будет говориться вскоре.</p>
    <p class="Textbody">Теперь посмотрим, что можно делать с самими окнами. В строке заголовка каждого окна, кроме самого заголовка, в правой его части можно видеть три управляющие кнопки (слева направо): сворачивания, максимизации/восстановления исходного размера, закрытия – назначение их очевидно.</p>
    <p class="Textbody">Кое-какие манипуляции с окнами можно выполнять и кликами мыши по строке заголовка. Так, двойной щелчок левой её кнопкой вызывает максимизацию окна, повторение его – восстанавливает исходный размер. Тот же двойной клик, но уже правой кнопкой сворачивает окно на панель задач. Для средней кнопки предусмотрен только одинарный клик – он «опускает» окно на задний план.</p>
    <p class="Textbody">Лишь закрыть окно нельзя кликами мыши по строке заголовка. Но это делается (если не обращаться к штатному меню запущенного в окне приложения) комбинацией клавиш Alt+F4 – подобно Alt+Tab, она также универсальна для почти всех графических сред (или вообще всех современных?). Кроме того, закрыть окно можно из его собственного меню – оно вызывается щелчком правой кнопки мыши по строке заголовка, и содержит такие пункты:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_021.png">
        <img alt="Изображение44" class="frameGraphics" id="44graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_021-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a44graphic"></a>
      <a id="bkm44graphic"></a>
    </p>
    <p class="Textbody">Назначение первых четырёх и последних двух пунктов абсолютно понятно. А вот о тёх «средних» пару слов сказать можно. Отметка Закрепить на переднем плане – это запрет перекрытия данного окна другими. А пункты Всегда на видимом рабочем месте и Только на этом рабочем месте (включён по умолчанию) – альтернативны: при включении первого окно будет «кочевать» вслед за перемещёниями пользователя по рабочим областям.</p>
    <h3 id="toc19"><a id="RefHeading14801713816058"></a><a id="bkmRefHeading14801713816058"></a><a id="toc18"></a><a id="bkmtoc18"></a><a id="RefHeading3441136957987"></a><a id="bkmRefHeading3441136957987"></a><a id="bkmRefHeading3441136957987"></a><a id="bkmbkmRefHeading3441136957987"></a>Тайлинг окон</h3>
    <p class="Textbody">Всё, что было только что сказано относительно управления окон, не покажется чем-то необычным применителю любого современного десктопа и приверженцам подавляющего большинства оконных менеджеров. А вот сейчас речь пойдёт о вещи более неожиданной – о тайлинге окон. Это – та самая вторая особенность (после строки поиска в меню), которая столь восхитила меня в Cinnamon'е.</p>
    <p class="Textbody">Для начала – пара слов о том, что такое тайлинг. Он основывается на той же идее, что и консольная утилита screen или двухпанельные файловые менеджеры – потомки командира Norton'а – расщеплении экрана на ряд независимых областей, в каждой из которых локализуется окно с запущенным в нём приложением. Это подобно покрытию пола кафелем (tiling), чем и порождена аллюзия.</p>
    <p class="Textbody">При этом понятие управления окнами как бы лишается смысла – тайлинговые системы управляют не столько окнами, сколько теми самыми областями экрана, в которых окна открываются. Области эти (в чём-то они похожи на фреймы, некогда популярные среди web-дизайнеров) могут быть статическими, с жёстко определёнными размерами, и динамическими, при котором их размеры изменяются при масштабировании окон запущенных в них приложений. В Cinnamon реализована первая модель.</p>
    <p class="Textbody">Конечно, тайлингом удивить пользователей менеджеров окон типа Awesome сотоварищи не легче, чем испугать ежа голой... эээ... спиной. Однако во времена не очень больших экранов я этой идеей не проникса (парадигма «одно приложение – одна рабочая область» была мне ближе). А ко времени мониторов больших и широкоэкранных тайлинг подоспел и в десктопах – в Xfce и KDE. Однако в сравнении с Cinnamon'овским тайлинг в них выглядит что плотник супротив столяра. Ибо предусматривает расщепление экрана только на две области – по горизонтали или по вертикали. В Cinnamon'е же возможности тайлинга намного богаче.</p>
    <p class="Textbody">Начать с того, что в Cinnamon'е окна можно «тайлить» не только на поэкрана – например, по вертикали:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_022.png">
        <img alt="Изображение45" class="frameGraphics" id="45graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_022-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a45graphic"></a>
      <a id="bkm45graphic"></a>
    </p>
    <p class="Textbody">Или, если хочется, по горизонтали:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_023.png">
        <img alt="Изображение46" class="frameGraphics" id="46graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_023-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a46graphic"></a>
      <a id="bkm46graphic"></a>
    </p>
    <p class="Textbody">Но есть и «четвертиночный» вариант разбивки экрана:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_024.png">
        <img alt="Изображение47" class="frameGraphics" id="47graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_024-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a47graphic"></a>
      <a id="bkm47graphic"></a>
    </p>
    <p class="Textbody">А подчас даже</p>
    <p class="Textbody">...получается в ответе<br />Два землекопа и две трети</p>
    <p class="Textbody">Примерно как на этом скриншоте:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_025.png">
        <img alt="Изображение48" class="frameGraphics" id="48graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_025-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a48graphic"></a>
      <a id="bkm48graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_025.png"> </a>
    </p>
    <p class="Textbody">Тайлинг окон не препятствует существованию на его фоне окон обычных:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_026.png">
        <img alt="Изображение49" class="frameGraphics" id="49graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_026-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a49graphic"></a>
      <a id="bkm49graphic"></a>
    </p>
    <p class="Textbody">Вот только, к сожалению, средства «тайлить» окна на произвольные области экрана на предусмотрено. Однако и без этого область его использования достаточно широка, в чём мы убедимся после рассмотрения средств управления тайлингом.</p>
    <h3 id="toc20"><a id="RefHeading14821713816058"></a><a id="bkmRefHeading14821713816058"></a><a id="toc19"></a><a id="bkmtoc19"></a><a id="RefHeading3461136957987"></a><a id="bkmRefHeading3461136957987"></a><a id="bkmRefHeading3461136957987"></a><a id="bkmbkmRefHeading3461136957987"></a>Управление тайлингом</h3>
    <p class="Textbody">Тайлинг окон может выполняться двумя способами – посредством мыши и с клавиатуры. Как обычно, первый – легче, то есть «ленивей», второй – быстрее и эффективней. Замечу в скобках: как обычно, это вовсе не означает оценки в терминах товарища Маяковского. Иногда «хорошо» – это лениво развалясь в кресле, елозить мышью по экрану, а иногда – напрягать пальцы рады быстроты выполнения неких действий.</p>
    <p class="Textbody">Рассмотрим сначала тайлинг мышью, выполняемый над окном с положением и размерами, соответствующими умолчаниям десктопа:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_027.png">
        <img alt="Изображение50" class="frameGraphics" id="50graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_027-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a50graphic"></a>
      <a id="bkm50graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_027.png"> </a>
    </p>
    <p class="Textbody">При подтаскивании окна мышью к верхней границе экрана оно занимает верхнюю же его половину:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_028.png">
        <img alt="Изображение51" class="frameGraphics" id="51graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_028-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a51graphic"></a>
      <a id="bkm51graphic"></a>
    </p>
    <p class="Textbody">Аналогичное движение к нижней границе экрана разворачивает окно на нижнюю его половину:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_029.png">
        <img alt="Изображение52" class="frameGraphics" id="52graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_029-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a52graphic"></a>
      <a id="bkm52graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_029.png"> </a>
    </p>
    <p class="Textbody">Перемещёние окна к боковой стороне экрана «тайлит» его на левую</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_030.png">
        <img alt="Изображение53" class="frameGraphics" id="53graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_030-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a53graphic"></a>
      <a id="bkm53graphic"></a>
    </p>
    <p class="Textbody">или правую половины, в зависимости от стороны «подтаскивания»:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_031.png">
        <img alt="Изображение54" class="frameGraphics" id="54graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_031-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a54graphic"></a>
      <a id="bkm54graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_031.png"> </a>
    </p>
    <p class="Textbody">Если передвинуть окно в любой из углов дисплея, оно займёт соответствующую его «четвертинку»:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/cinnamon_032.png">
        <img alt="Изображение55" class="frameGraphics" id="55graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_032-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a55graphic"></a>
      <a id="bkm55graphic"></a>
    </p>
    <p class="Textbody">То есть всё просто, но... Предположим, что при сочинении текста в текстовом редакторе (или word-процессоре) появилось желание параллельно бросить взгляд на картину, призванную этот текст иллюстрировать: в этом случае тайлинг посредством мыши потребует отрыва руки от клавиатуры и переноса её на спину грызуна. И вот тут-то на помощь и придёт тайлинг с клавиатуры, который осуществляется комбинацией из двух пальцев – клавиши Super (она же – левая Win) и одной из стрелок управления курсором.</p>
    <p class="Textbody">Опять же подвергнем издевательствам исходное окно с умолчальными параметрами. Комбинация Super+Right развернёт её на правую половину экрана, Super+Left – вернёт в исходное состояния. Из которого комбинацией Super+Left оно развернётся на левую половину, а последующий Super+Right – возвратит взад. Из положения «половинка справа» комбинация Super+Up превратит окно в «четвертинку» в правом верхнем углу, Super+Down – «четвертинку» в правом нижнем.</p>
    <p class="Textbody">Принцип, я думаю, понятен: Super плюс стрелка в любую сторону – окно на соответствующую половинку экрана, Super плюс стрелка в обратную – возврат в исходное положение, Super плюс стрелка из «половинного» состояния – перевод в состояние «четвертиночное». Запомнить это не сложно, навык до рефлекторного уровня приобретается очень быстро. А как его можно применить на практике – сейчас увидим.</p>
    <h3 id="toc21"><a id="RefHeading14841713816058"></a><a id="bkmRefHeading14841713816058"></a><a id="toc20"></a><a id="bkmtoc20"></a><a id="RefHeading3481136957987"></a><a id="bkmRefHeading3481136957987"></a><a id="bkmRefHeading3481136957987"></a><a id="bkmbkmRefHeading3481136957987"></a>Тайлинг на практике</h3>
    <p class="Textbody">Всё это очень блаародно – вправе сказать читатель, – но в чём преимущество тайловых окон перед обычными? Долгое время ответа на этот вопрос у меня не было, тем более, что я окнами почти не пользовался: во всё ширь каждого десктопа у меня было открыто одно приложение. Пока не опробовал тайловый режим – сначала в Xfce 4.10, где он незатейлив, а затем и в среде Cinnamon, в которой, как я пытался показать на предыдущих страницах, он куда более изощрён.</p>
    <p class="Textbody">Тем не менее, объяснить преимущества тайловых окон над масштабированными довольно трудно – это надо попробовать самому и оценить. Для меня оно выразилось в возможности мгновенно перейти от сочинения текста в полноэкранном режиме к режиму параллельного просмотра текста, иллюстраций к нему, файловой иерархии и так далее. И сделать это лёгким движением даже не руки, а двух пальцев.</p>
    <p class="Textbody">Причём параллельным просмотром нескольких окон можно не ограничиваться. А, например, перетаскивать мышью или просто копипастить горячими клавишами картинки из файлового менеджера или вьювера изображений в word-процессор. Аналогичным образом можно перетаскивать из теста документации в командную строку терминала примеры командных конструкций. Или, наоборот, команды или исходники сценариев – помещать в сочиняемый текст.</p>
    <p class="Textbody">Конечно, всё это можно сделать и при традиционном расположении окон, но прошу поверить на слово брату незабвенного Голубкова:</p>
    <p class="Textbody">Так лучше, Лёня.</p>
    <p class="Textbody">В общем, обращение с содержимым окон становится похожим на работу с двухпанельными файловыми менеджерами a la Midnight Commander. Или даже с четырёхпанельными: возможно, кое-кому из читателей памятен «пай-мальчик» – Pie Commander, незаконный четырёхглазый отпрыск командира Norton'а...</p>
    <p class="Textbody">Правда, в двух- и тем более в «четырёхплиточной черепице» становится мучительно больно за бесцельно расходуемое экранное пространство, занятое в каждом окне строкой меню. И возникает сожаление об отсутствии возможности встроить его в главную управляющую панель, как это делается по умолчанию в Unity. Но увы – нет в жизни совершенства, ибо нет в Cinnamon такой возможности. Иначе он безусловно достиг бы высшей степени совершенства, а его разработчики имели бы полное право впасть в нирвану.</p>
    <h3 id="toc22"><a id="RefHeading14861713816058"></a><a id="bkmRefHeading14861713816058"></a><a id="toc21"></a><a id="bkmtoc21"></a><a id="RefHeading3501136957987"></a><a id="bkmRefHeading3501136957987"></a><a id="bkmRefHeading3501136957987"></a><a id="bkmbkmRefHeading3501136957987"></a>Интерфейс Cinnamon: краткий итог</h3>
    <p class="Textbody">В этом очерке были описаны особенности интерфейса Cinnamon, которые представляются мне наиболее существенными. Пора подводить итоги.</p>
    <p class="Textbody">В своём современном виде Cinnamon наделён всеми функциями, присущими остальным десктопам. Причём реализованными если не идеально, то близко к тому. А две из них в сочетании оказываются почти уникальными. Это – строка инкрементного поиска в меню и развитый тайлинг. Обе они представлены и в Unity, и Xfce, и в KDE. Но в первой среде пресловутый Dash как раз функционально перегружен, предусматривая поиск в Интернете не только всякой ерунды, типа программ и пакетов, но и весьма важной и разнообразной «парнухи». В Xfce строка поиска по меню как раз зарыта в дебрях её минитерминала. Ну а в KDE эта строка есть только в «меню современного вида», которое само по себе многим (в том числе и автору этих строк) представляется неудобным. Что же до тайлинга – как я уже отметил, его реализация в Cinnamon среди всех десктопов превзойдённа.</p>
    <p class="Textbody">При этом всё сказанное в этой части касалось особенностей Cinnamon'а по умолчанию. Но особенно ярко они заиграют после соответствующих настроек, которым будут посвящены следующие очерки.</p>
    <h2 id="toc23"><a id="RefHeading14881713816058"></a><a id="bkmRefHeading14881713816058"></a><a id="toc22"></a><a id="bkmtoc22"></a><a id="RefHeading12481136957987"></a><a id="bkmRefHeading12481136957987"></a><a id="bkmRefHeading12481136957987"></a><a id="bkmbkmRefHeading12481136957987"></a>Cinnamon и системные настройки</h2>
    <p class="Textbody">Следующая серия очерков посвящена описанию способов, как штатных, так и не очень, которые изменяют те умолчания Mint и Cinnamon, что были рассмотрены в очерке предыдущем.</p>
    <h3 id="toc24"><a id="RefHeading14901713816058"></a><a id="bkmRefHeading14901713816058"></a><a id="toc23"></a><a id="bkmtoc23"></a><a id="RefHeading3521136957987"></a><a id="bkmRefHeading3521136957987"></a><a id="bkmRefHeading3521136957987"></a><a id="bkmbkmRefHeading3521136957987"></a>Системные настройки: вступление</h3>
    <p class="Textbody">Подавляющее большинство настроек в Cinnamon выполняется из панели его Системных настроек (cinnamon-settings), именуемых также Центром управления. С ними тесно интегрированы фирменные утилиты Mint, имеющие отношение к конфигурированию системы. Однако они будут предеметом отдельного очерка.</p>
    <p class="Textbody">Пиктограмма запуска Системных настроек занимает почётное место в левой колонке главного меню управляющей панели. Через один-два клика мышью до них можно добраться и из контекстных меню как самой панели, так и рабочего стола. И при первом запуске выглядит он так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_001.png">
        <img alt="Изображение56" class="frameGraphics" id="56graphic" src="http://alv.me/wp-content/img/im_cin_img/config_001-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a56graphic"></a>
      <a id="bkm56graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/config_001.png"> </a>
    </p>
    <p class="Textbody">Ранее Системные настройки имели два режима — нормальный и расширенный, и реликты такого положения можно найти в сетевых материалах. Однако, начиная с Cinnamon версии 2.2, эта дискриминация ликвидирована, и расширенный режим стал нормой жизни применителя.</p>
    <p class="Textbody">Если пролистать окно Системных настроек до конца, можно увидеть, что отдельные её модули группируются в четыре секции:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Оформление </p>
      </li>
      <li>
        <p class="Textbody">Параметры </p>
      </li>
      <li>
        <p class="Textbody">Оборудование </p>
      </li>
      <li>
        <p class="Textbody">Администрирование </p>
      </li>
    </ul>
    <p class="Textbody">Далее я последовательно рассмотрю возможности каждого модуля примерно в том порядке, в котором они следуют в русскоязычном варианте Cinnamon. Отклоняясь от него, когда когда того потребует логика.</p>
    <h3 id="toc25"><a id="RefHeading14921713816058"></a><a id="bkmRefHeading14921713816058"></a><a id="toc24"></a><a id="bkmtoc24"></a><a id="RefHeading3541136957987"></a><a id="bkmRefHeading3541136957987"></a><a id="bkmRefHeading3541136957987"></a><a id="bkmbkmRefHeading3541136957987"></a>Секция Оформление</h3>
    <p class="Textbody">Секция Оформление включает в себя модули:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Темы; </p>
      </li>
      <li>
        <p class="Textbody">Фоновые рисунки; </p>
      </li>
      <li>
        <p class="Textbody">Шрифты; </p>
      </li>
      <li>
        <p class="Textbody">Эффекты. </p>
      </li>
    </ul>
    <p class="Textbody">Модуль Темы выглядит таким образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_002.png">
        <img alt="Изображение57" class="frameGraphics" id="57graphic" src="http://alv.me/wp-content/img/im_cin_img/config_002-572x476.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:477.83688px" />
      </a>
      <a id="a57graphic"></a>
      <a id="bkm57graphic"></a>
    </p>
    <p class="Textbody">Организация его подчёркивает, что стилевое оформление отдельных элементов интерфейса полностью независимо друг от друга и от темы рабочего стола. Это можно проиллюстрировать серией скриншотов для стилей рамок окон:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_003.png">
        <img alt="Изображение58" class="frameGraphics" id="58graphic" src="http://alv.me/wp-content/img/im_cin_img/config_003-572x385.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:386.82584px" />
      </a>
      <a id="a58graphic"></a>
      <a id="bkm58graphic"></a>
    </p>
    <p class="Textbody">Пиктограмм:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_004.png">
        <img alt="Изображение59" class="frameGraphics" id="59graphic" src="http://alv.me/wp-content/img/im_cin_img/config_004-572x439.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:440.8353px" />
      </a>
      <a id="a59graphic"></a>
      <a id="bkm59graphic"></a>
    </p>
    <p class="Textbody">Управляющих кнопок окна:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_005.png">
        <img alt="Изображение60" class="frameGraphics" id="60graphic" src="http://alv.me/wp-content/img/im_cin_img/config_005-572x422.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:423.82742px" />
      </a>
      <a id="a60graphic"></a>
      <a id="bkm60graphic"></a>
    </p>
    <p class="Textbody">Указателей мыши:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_006.png">
        <img alt="Изображение61" class="frameGraphics" id="61graphic" src="http://alv.me/wp-content/img/im_cin_img/config_006-572x422.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:423.82742px" />
      </a>
      <a id="a61graphic"></a>
      <a id="bkm61graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/config_006.png"> </a>
    </p>
    <p class="Textbody">И, наконец, для собственно тем рабочего стола:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_007.png">
        <img alt="Изображение62" class="frameGraphics" id="62graphic" src="http://alv.me/wp-content/img/im_cin_img/config_007-572x385.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:386.82584px" />
      </a>
      <a id="a62graphic"></a>
      <a id="bkm62graphic"></a>
    </p>
    <p class="Textbody">Обращает на себя внимание изобилие расцветок умолчальной темы Mint-X, с одной стороны, и пиктограмм — с другой. Это позволяют комбинировать элементы оформления интерфейса в очень широких пределах, достигая максимального визуального эффекта. Что, между прочим, сколько бы ни иронизировали на эту тему, имеет практическое значение, особенно для людей с плохим зрением или нарушением цветовосприятия.</p>
    <p class="Textbody">С помощью кнопки Добавить/удалить темы рабочего стола умолчальную тему Mint-X можно заменить на одну из предустановленных:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_008.png">
        <img alt="Изображение63" class="frameGraphics" id="63graphic" src="http://alv.me/wp-content/img/im_cin_img/config_008-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a63graphic"></a>
      <a id="bkm63graphic"></a>
    </p>
    <p class="Textbody">Можно также обратиться к коллекции тем, доступных на <a href="http://linuxmint-art.org/" target="_blank">сайте специального субпроекта</a> — это сначала потребует обновления кеша тем, что может занять немало времени:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_009.png">
        <img alt="Изображение64" class="frameGraphics" id="64graphic" src="http://alv.me/wp-content/img/im_cin_img/config_009-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a64graphic"></a>
      <a id="bkm64graphic"></a>
    </p>
    <p class="Textbody">Но будет вознаграждено обильным уловом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_010.png">
        <img alt="Изображение65" class="frameGraphics" id="65graphic" src="http://alv.me/wp-content/img/im_cin_img/config_010-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a65graphic"></a>
      <a id="bkm65graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/config_010.png"> </a>
    </p>
    <p class="Textbody">Правда, перепробовав немало тем, я в конечном счёте вернулся к умолчальной Mint-X. И даже отказался от её модификации — этому занятию ранее я тоже отдал свою дань, и потому опишу в конце данного очерка.</p>
    <p class="Textbody">Модуль Фоновые рисунки в нынешней Cinnamon — это не просто банальные обои. Нет, конечно, их можно использовать и в этом качестве. Но самый цимес модуля — организация слайд-шоу из нескольких предустановленных наборов картинок, носящих имена былых и нынешних релизов Mint:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_011.png">
        <img alt="Изображение66" class="frameGraphics" id="66graphic" src="http://alv.me/wp-content/img/im_cin_img/config_011-572x403.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:404.85416px" />
      </a>
      <a id="a66graphic"></a>
      <a id="bkm66graphic"></a>
    </p>
    <p class="Textbody">И не только из них — в качестве такого набора можно легко подключить каталог с собственными изображениями, на следующем скриншоте таковым выступает my_backgrounds):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_012.png">
        <img alt="Изображение67" class="frameGraphics" id="67graphic" src="http://alv.me/wp-content/img/im_cin_img/config_012-572x403.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:404.85416px" />
      </a>
      <a id="a67graphic"></a>
      <a id="bkm67graphic"></a>
    </p>
    <p class="Textbody">Модуль Шрифты позволяет определить гарнитуры, шрифтоначертания и кегли для элементов интерфейса, документов и терминальных окон. По умолчанию в качестве интерфейсных (пропорциональных) шрифтов в Cinnamon, начиная с версии 2.4, используется гарнитура Noto Sans собственной выделки:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_013.png">
        <img alt="Изображение68" class="frameGraphics" id="68graphic" src="http://alv.me/wp-content/img/im_cin_img/config_013-572x317.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:318.83212px" />
      </a>
      <a id="a68graphic"></a>
      <a id="bkm68graphic"></a>
    </p>
    <p class="Textbody">Мне эта гарнитура понравилась до чрезвычайности:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_014.png">
        <img alt="Изображение69" class="frameGraphics" id="69graphic" src="http://alv.me/wp-content/img/im_cin_img/config_014-539x572.png" style="border:1.0px solid #000080;padding:0;width:540.8416px;height:573.83685px" />
      </a>
      <a id="a69graphic"></a>
      <a id="bkm69graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/config_014.png"> </a>
    </p>
    <p class="Textbody">Особенно с учётом того, что она не одинока — в дополнение к ней имеется и гарнитура с отсечками, как нетрудно догадаться, именуемая Noto Serif:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_015.png">
        <img alt="Изображение70" class="frameGraphics" id="70graphic" src="http://alv.me/wp-content/img/im_cin_img/config_015-521x572.png" style="border:1.0px solid #000080;padding:0;width:522.8511px;height:573.83685px" />
      </a>
      <a id="a70graphic"></a>
      <a id="bkm70graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/config_015.png"> </a>
    </p>
    <p class="Textbody">То есть семейство гарнитур Noto оказывается почти самодостаточным не только для интерфейса среды и её приложений, но и для оформления документов. Почти — потому что в нём явно не хватает какой-либо моноширинной гарнитуры для использования в текстовых редакторах и терминальных окнах. Впрочем, я это восполняю последнее время за счёт моноширинного представителя семейства Liberation — Liberation Mono. В результате чего мои шрифтовые настройки выглядят следующим образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_016.png">
        <img alt="Изображение71" class="frameGraphics" id="71graphic" src="http://alv.me/wp-content/img/im_cin_img/config_016-572x346.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:347.85892px" />
      </a>
      <a id="a71graphic"></a>
      <a id="bkm71graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/config_016.png"> </a>
    </p>
    <p class="Textbody">Тут нужно оговориться, что настройка шрифтов главного меню управляющей панели, подписей и всплывающих подсказок на ней возможна только путём прямого редактирования стилевого файла выбранной темы рабочего стола, о чём будет говориться в следующем разделе этого очерка.</p>
    <p class="Textbody">А пока — про Эффекты. По умолчанию этот модуль выглядит таким образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_017.png">
        <img alt="Изображение72" class="frameGraphics" id="72graphic" src="http://alv.me/wp-content/img/im_cin_img/config_017-572x330.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:331.8337px" />
      </a>
      <a id="a72graphic"></a>
      <a id="bkm72graphic"></a>
    </p>
    <p class="Textbody">До недавнего времени тут я просто снимал галочку с бокса Включить эффекты рабочего стола и больше на эту тему не думал. Предоставляя разбираться с «красивостями» тем, кто таким образом охмуряет молоденьких вендузятнец. Однако в Cinnamon эффекты мне неожиданно понравились своей плавностью и ненавязчивостью. Так что я затратил некоторое время на приведение к такому виду:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_018.png">
        <img alt="Изображение73" class="frameGraphics" id="73graphic" src="http://alv.me/wp-content/img/im_cin_img/config_018-572x290.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:291.8463px" />
      </a>
      <a id="a73graphic"></a>
      <a id="bkm73graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/config_018.png"> </a>
    </p>
    <p class="Textbody">На этом в данный момент я с оформлением закончил. Однако, как и обещал, под занавес расскажу о том, как редактировать темы рабочего стола. Хотя, как уже было сказано, в конце концов я вернулся к умолчальной Mint-X, но как опыт это было интересно.</p>
    <h3 id="toc26"><a id="RefHeading14941713816058"></a><a id="bkmRefHeading14941713816058"></a><a id="toc25"></a><a id="bkmtoc25"></a><a id="RefHeading3561136957987"></a><a id="bkmRefHeading3561136957987"></a><a id="bkmRefHeading3561136957987"></a><a id="bkmbkmRefHeading3561136957987"></a>Cinnamon и собственные темы</h3>
    <p class="Textbody">В отличие от большинства остальных очерков, в этом разделе я описываю не актуальную версию Cinnamon 2.4, а её предшественниц 2.0 и 2.2. Где ни одна тема, даже самая красивая, не подходила мне целиком и полностью. В текущем же релизе неожиданно оказалось, что тема по умолчанию, Mint-X, устраивает меня во всех отношениях. Тем не менее, я решил включить описание моих тогдашних развлечений в эту книгу — вдруг когда возникнет желание заняться этим делом снова?</p>
    <p class="Textbody">Как только что было сказано, настройка шрифтов Cinnamon действует на все элементы его интерфейса, кроме панели и главного меню. Причём следствие, проведённое в то время, показало, что в панели и меню шрифты зависят от темы оформления: при смене её гарнитура в этих элементах интерфейса менялась, хотя кегль оставался если не неизменным, то обычно маленьким и трудно различимым.</p>
    <p class="Textbody">После отправки дела на доследование оказалось, что так оно и есть: кегли шрифтов для меню и разных элементов панели (а в ряде случаев – даже и гарнитуры) жёстко прописывались в CSS-файле всех тем, которые я просмотрел. А поскольку все они были изготовлены зоркими соколами, кегли эти везде были очень маленькими, от 7 до максимум 11 пунктов.</p>
    <p class="Textbody">Обсуждать вопрос о том, насколько это идеологически правильно, здесь не буду. Конечно, на мой взгляд, неправильно абсолютно – ибо противоречит идее сквозных настроек десктопа, последовательно проводимой в KDE и Xfce. Однако идеология – идеологией, а практика – практикой: поскольку это оказался чуть ли не единственный недостаток Cinnamon'а, его следовало по возможности искоренить, а не рассуждать на тему</p>
    <p class="Textbody">Что делать, блин?<br />И кто, блин, виноват?!</p>
    <p class="Textbody">Что делать – было ясно: редактировать тему, наиболее близкую по всем остальным показателям. А как делать – в принципе стало ясно из прочтения материала Клемента Лефевра, к <a href="http://alv.me/?p=2230">переводу</a> или <a href="http://cinnamon.linuxmint.com/?p=144" target="_blank">оригиналу</a> которого и отсылаю заинтересованного читателя. Здесь же лишь кратко опишу последовательность собственных действий.</p>
    <p class="Textbody">В качестве подопытного кролика я выбрал тему Void, все относящиеся к ней файлы имели место быть у меня в каталоге ~/.themes/Void/cinnamon. В том числе и cinnamon.css, который я отредактировал самым простым способом: без лицемерия явным образом указал гарнитуру:</p>
    <p class="Textbody"><span style="background-color:#dddddd">stage {</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">font-family: "Cantarell";</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">}</span> </p>
    <p class="Textbody">Затем просто добавил один-два пункта к кеглям шрифтов всех интерфейсных элементов. А заодно из темы Canelita потырил пиктограмму для кнопки главного меню – умолчально-зелёная в мою цветовую гамму вписывалась плохо.</p>
    <p class="Textbody">И вот что получилось в итоге:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/config_019.png">
        <img alt="Изображение74" class="frameGraphics" id="74graphic" src="http://alv.me/wp-content/img/im_cin_img/config_019-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a74graphic"></a>
      <a id="bkm74graphic"></a>
    </p>
    <h2 id="toc27"><a id="RefHeading14961713816058"></a><a id="bkmRefHeading14961713816058"></a><a id="toc26"></a><a id="bkmtoc26"></a><a id="RefHeading12501136957987"></a><a id="bkmRefHeading12501136957987"></a><a id="bkmRefHeading12501136957987"></a><a id="bkmbkmRefHeading12501136957987"></a>Секция Параметры</h2>
    <p class="Textbody">Если модули секции Оформление отвечают за внешний вид среды Cinnamon, то в секции Параметры собраны модули, определяющие её поведение. Это — самая обширная секция среди Системных настроек, и в полностью обозримом виде она выглядит так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_001.png">
        <img alt="Изображение75" class="frameGraphics" id="75graphic" src="http://alv.me/wp-content/img/im_cin_img/param_001-559x572.png" style="border:1.0px solid #000080;padding:0;width:560.8353px;height:573.83685px" />
      </a>
      <a id="a75graphic"></a>
      <a id="bkm75graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_001.png"> </a>
    </p>
    <p class="Textbody">Далее в этом очерке модули секции будут рассмотрены не в том порядке, в котором они приведены на скриншоте, то есть алфавитном. А в порядке, диктуемом логикой. Хотя начну рассмотрение я таки по алфавиту.</p>
    <h3 id="toc28"><a id="RefHeading14981713816058"></a><a id="bkmRefHeading14981713816058"></a><a id="toc27"></a><a id="bkmtoc27"></a><a id="RefHeading3581136957987"></a><a id="bkmRefHeading3581136957987"></a><a id="bkmRefHeading3581136957987"></a><a id="bkmbkmRefHeading3581136957987"></a>Автозапуск</h3>
    <p class="Textbody">Модуль Автозапуск предназначен для управления программами, автоматически загружаемыми при старте сеанса Cinnamon, как системными, так и сугубо прикладными. По умолчанию список их выглядит так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_002.png">
        <img alt="Изображение76" class="frameGraphics" id="76graphic" src="http://alv.me/wp-content/img/im_cin_img/param_002-572x465.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:466.83844px" />
      </a>
      <a id="a76graphic"></a>
      <a id="bkm76graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_002.png"> </a>
    </p>
    <p class="Textbody">Способы коррекции списка очевидны: снятие «птицы» с соответствующего бокса отключает загрузку данной программы (например, mintwelcome, выводящей приветственную панель при запуске сеанса), кнопка Удалить исключает её из списка вообще, а с помощью кнопки Добавить список пополняется программами по желанию применителя. Для чего в появившейся панели надо заполнить поля Имя (желательно соответствующее имени программы), Команда (имя запускающего файла, при необходимости — с указанием пути) и, по желанию, Комментарий (в свободной форме). Например, для выпадающего терминала Tilda (использование которого без автозапуска лишено смысла) это выглядит так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_003.png">
        <img alt="Изображение77" class="frameGraphics" id="77graphic" src="http://alv.me/wp-content/img/im_cin_img/param_003.png" style="border:1.0px solid #000080;padding:0;width:413.8495px;height:232.84789px" />
      </a>
      <a id="a77graphic"></a>
      <a id="bkm77graphic"></a>
    </p>
    <p class="Textbody">В результате таких действий у меня панель автозапуска выглядит таким образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_004.png">
        <img alt="Изображение78" class="frameGraphics" id="78graphic" src="http://alv.me/wp-content/img/im_cin_img/param_004-572x534.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:535.85266px" />
      </a>
      <a id="a78graphic"></a>
      <a id="bkm78graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_004.png"> </a>
    </p>
    <p class="Textbody">По умолчанию в панели автозапуска отображаются далеко не все автоматически запускаемые приложения — в ней мы не увидим всякого рода системных служб. Чтобы сделать их видимыми, нужно отредактировать соответствующие конфиги в каталоге /etc/xdg/autostart/, имеющие вид *.desktop. Каждый из них включает в себя параметр NoDisplay, отвечающий за вывод на экран, и значение его по умолчанию true. Которое достаточно заменить на false, чтобы увидеть весь стартовый букет служб и приложений. Сделать это в один присест можно при помощи утилиты sed, запущенной с правами администратора:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo sed -i 's/NoDisplay=true/NoDisplay=false/' /etc/xdg/autostart/*</span> </p>
    <p class="Textbody">Годится для этого и любой развитый текстовый редактор, позволяющий выполнять поиск и замену в серии файлов (Geany, Komodo Edit).</p>
    <p class="Textbody">В предыдущих версиях Cinnamon в панели автозапуска имелся боксик Автоматически запоминать запущенные приложения при выходе из сеанса. Правда, работал он из рук вон плохо, и потому в текущей версии был в Системных настройках ликвидирован как класс. Но возможность включить сохранение сеансов сохранилась в Редакторе dconf, о котором будет говориться своевременно.</p>
    <h3 id="toc29"><a id="RefHeading15001713816058"></a><a id="bkmRefHeading15001713816058"></a><a id="toc28"></a><a id="bkmtoc28"></a><a id="RefHeading3601136957987"></a><a id="bkmRefHeading3601136957987"></a><a id="bkmRefHeading3601136957987"></a><a id="bkmbkmRefHeading3601136957987"></a>Апплеты, десклеты и расширения</h3>
    <p class="Textbody">Апплеты уже мельком упоминались в очерке об интерфейсе Cinnamon, а вот про десклеты и расширения речи ещё не было. Так что для начала скажу пару слов о том, что это такое.</p>
    <p class="Textbody">Название апплеты является уменьшительно-ласкательной формой английского application, то есть по русски — программульки, или маааленькие программы. Однако главное не в их размере, а в том, что они работают только внутри других, «полноценных», программ, и не способны к самостоятельному существованию. В нашем случае апплетами являются пиктограммы управляющей панели Cinnamon'а, которые вне её не то что функционировать — жить не могут.</p>
    <p class="Textbody">Десклеты — это название принято в Cinnamon'е для элементов, которые в других рабочих средах называют виджетами (то есть «штуковинами»). Как и апплеты, самостоятельно роли они не играют. Но, в отличие от тех, встраиваются на рабочий стол (откуда, видимо, и название).</p>
    <p class="Textbody">Что же до расширений (extensions), их назначение понятно из названия: подобно плагинам и прочим add-on'ам, они добавляют к базовой функциональности десктопа дополнительные возможности (например, добавление второй нижней панели плюс к главной управляющей).</p>
    <p class="Textbody">А теперь посмотрим, как эти самые апплеты, десклеты и расширения настраиваются. Начав по алфавиту, с первых.</p>
    <p class="Textbody">Собственно, настройка апплетов сводится к двум моментам. Первый — это добавление на панель уже установленных апплетов или, напротив, удаление с неё добавленных:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_005.png">
        <img alt="Изображение79" class="frameGraphics" id="79graphic" src="http://alv.me/wp-content/img/im_cin_img/param_005-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a79graphic"></a>
      <a id="bkm79graphic"></a>
    </p>
    <p class="Textbody">Второй момент — загрузка списка апплетов не установленных, выбор из них нужных и установка последних:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_006.png">
        <img alt="Изображение80" class="frameGraphics" id="80graphic" src="http://alv.me/wp-content/img/im_cin_img/param_006-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a80graphic"></a>
      <a id="bkm80graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_006.png"> </a>
    </p>
    <p class="Textbody">Я думаю, что обе задачи заинтересованный читатель сможет решить без труда. Как и вопрос с определением нужности или ненужности конкретных апплетов. Попрошу только обратить внимание на апплеты Workspace switcher и Expo в списке предустановленных, но не используемых — они скоро потребуются нам в одном из ближайших разделов этого очерка.</p>
    <p class="Textbody">А при установке подгружаемых апплетов надо учитывать, что при переходе от Cinnamon версии 2.2 к 2.4 произошла смена API. И, по сообщениям в Сети, не все из сторонних апплетов, сочинявшихся ещё для прежних версий, обязаны корректно работать в последнем релизе. Впрочем, со временем эта проблема теряет актуальность.</p>
    <p class="Textbody">С десклетами дело обстоит сходным во всех отношениях образом. Во-первых, их также можно выбрать из числа предустановленных, каковых всего три:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_007.png">
        <img alt="Изображение81" class="frameGraphics" id="81graphic" src="http://alv.me/wp-content/img/im_cin_img/param_007-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a81graphic"></a>
      <a id="bkm81graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_007.png"> </a>
    </p>
    <p class="Textbody">Во-вторых, можно просмотреть список десклетов, доступных в Сети, и включить их в список установленных:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_008.png">
        <img alt="Изображение82" class="frameGraphics" id="82graphic" src="http://alv.me/wp-content/img/im_cin_img/param_008-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a82graphic"></a>
      <a id="bkm82graphic"></a>
    </p>
    <p class="Textbody">В-третьих, можно настроить оформление десклетов (в рамке, с заголовком или без ничего) и их размещёние (привязка к сетке с заданным шагом).:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_009.png">
        <img alt="Изображение83" class="frameGraphics" id="83graphic" src="http://alv.me/wp-content/img/im_cin_img/param_009-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a83graphic"></a>
      <a id="bkm83graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_009.png"> </a>
    </p>
    <p class="Textbody">Для подключения десклетов из списка установленных их остаётся только добавить на рабочий стол — подобно пиктограммам рабочего стола, они появятся во всех рабочих пространствах:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_010.png">
        <img alt="Изображение84" class="frameGraphics" id="84graphic" src="http://alv.me/wp-content/img/im_cin_img/param_010-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a84graphic"></a>
      <a id="bkm84graphic"></a>
    </p>
    <p class="Textbody">Вопрос, нужны ли народу десклеты, остаётся спорным. С одной стороны, болтающиеся на экране дополнительные часы, калькулятор, информатор о занятости дисковых разделов или сводка погоды (а никакого иного полезного функционала я среди них не обнаружил) не особенно и видны в рабочем режиме. Но с другой — и не мешают, а при случае могут и пригодиться.</p>
    <p class="Textbody">Однако тут надо учитывать два момента. Первый — к десклетам относится всё сказанное об апплетах относительно совместимости их с текущей версией Cinnamon.</p>
    <p class="Textbody">Второй момент — более существенный. Как показала практика, даже десклеты, заведомо предназначенные для соответствующей версии Cinnamon, могут работать некорректно и даже приводить всю среду в полностью неработоспособное состояние.</p>
    <p class="Textbody">Правда, лечится это достаточно просто — нажатием кнопки Восстановить стандартные настройки, если не помогло — ручной очисткой каталога ~/.local/share/cinnamon/desklets, но всё равно радости мало. Учитывая сомнительную пользу даже от тех десклетов, которые кажутся подозрительными на полезность.</p>
    <p class="Textbody">С расширениями ситуация ещё менее однозначна. В предустановленном виде их нет ни одного, да и список доступных не так велик:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_011.png">
        <img alt="Изображение85" class="frameGraphics" id="85graphic" src="http://alv.me/wp-content/img/im_cin_img/param_011-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a85graphic"></a>
      <a id="bkm85graphic"></a>
    </p>
    <p class="Textbody">И среди существующих расширений вызывающих подозрения в своей полезности оказалось не мало — например, CinnaDock, похожий, судя по описанию, на Cairo, упомянутый выше 2 Bottom Panels или трёхмерный переключатель задач — 3D App Switcher. Но слова относительно совместимости с Cinnamon 2.4 относятся к расширениям ещё больше, чем к десклетам. В частности, ни одно из заинтересовавших меня в текущей версии этой среды даже не устанавливалось, не говоря уже об активизации. Я понимаю, что со временем это всё устаканится — но вот тогда и вернусь к этому вопросу.</p>
    <h3 id="toc30"><a id="RefHeading15021713816058"></a><a id="bkmRefHeading15021713816058"></a><a id="toc29"></a><a id="bkmtoc29"></a><a id="RefHeading3621136957987"></a><a id="bkmRefHeading3621136957987"></a><a id="bkmRefHeading3621136957987"></a><a id="bkmbkmRefHeading3621136957987"></a>Панель и рабочий стол</h3>
    <p class="Textbody">После рассмотрения апплетов, десклетов и расширений логично будет перейти к конфигурированию элементов, их вмещающих — управляющей Панели и Рабочего стола.</p>
    <p class="Textbody">Правда, про настройки рабочего стола сказать особо нечего. Здесь можно только отметить, какие пиктограммы из заданного списка следует на него выводить:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_012.png">
        <img alt="Изображение86" class="frameGraphics" id="86graphic" src="http://alv.me/wp-content/img/im_cin_img/param_012-572x241.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:242.82585px" />
      </a>
      <a id="a86graphic"></a>
      <a id="bkm86graphic"></a>
    </p>
    <p class="Textbody">Впрочем, модуль всё равно полезный, так как позволяет запретить вывод пиктограмм на рабочий стол вообще, что я обычно и проделываю: в редкие мгновения, когда я вижу рабочий стол вообще, предпочитаю любоваться картинкой на нём, а не пялить глаза в какие-то пиктограммы.</p>
    <p class="Textbody">В модуле Панель по умолчанию всё достаточно стандартно — расположение её «традиционное», то есть внизу экрана:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_013.png">
        <img alt="Изображение87" class="frameGraphics" id="87graphic" src="http://alv.me/wp-content/img/im_cin_img/param_013-572x366.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:367.85263px" />
      </a>
      <a id="a87graphic"></a>
      <a id="bkm87graphic"></a>
    </p>
    <p class="Textbody">Однако есть немало возможностей для видоизменения. Так, панель может располагаться не только внизу, но и вверху экрана. Кроме того, их может быть две — и вверху, и внизу (как было по умолчанию в GNOME 2, и как ныне принято в его форке — MATE). Самое же главное — можно задавать произвольную высоту панели, с масштабированием текста и пиктограмм на ней:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_014.png">
        <img alt="Изображение88" class="frameGraphics" id="88graphic" src="http://alv.me/wp-content/img/im_cin_img/param_014-572x349.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:350.84473px" />
      </a>
      <a id="a88graphic"></a>
      <a id="bkm88graphic"></a>
    </p>
    <p class="Textbody">Относительно автоматического скрытия всё понятно без комментариев — для кого-то это полезно, для иного же (например, для меня) — не удобно. А вот включение режима редактирования панели позволяет перетасовывать отдельные её элементы, в частности, пиктограммы в Launcher'е и в трее. Правда, при этом отключается запуск с помощью кнопок приложений на ней — то есть свои рабочие функции она выполнять перестаёт. Так что включать этот режим следует только на время — действительно при необходимости что-то перетащить.</p>
    <p class="Textbody">Здесь же уместно сказать и о модуле Блокировка экрана. Сама по себе блокировка с параметрами по умолчанию — штука, меня страшно раздражающая. Особенно когда для разблокирования требуется ввод пароля. Так что первым делом я её отключаю напрочь — даже на ноутбуке. Оставляю только включение, через разумный промежуток времени, скринсейвера (который здесь, впрочем, тоже называется блокировкой):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_015.png">
        <img alt="Изображение89" class="frameGraphics" id="89graphic" src="http://alv.me/wp-content/img/im_cin_img/param_015-572x402.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:403.8337px" />
      </a>
      <a id="a89graphic"></a>
      <a id="bkm89graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_015.png"> </a>
    </p>
    <p class="Textbody">А вот сам скринсейвер — предмет гордости разработчиков, и гордости законной. Потому что в нём можно задать вывод времени и даты в период блокировки, причём в собственном формате. Кроме того, вместо времени и/или даты можно указать любой произвольный текст, например</p>
    <p class="Textbody">Руки прочь от моего компа</p>
    <p class="Textbody">Впрочем, текст можно указать и в специально предназначенном для этого поле, например, подобно Кристоферу Робину, вот такой:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_016.png">
        <img alt="Изображение90" class="frameGraphics" id="90graphic" src="http://alv.me/wp-content/img/im_cin_img/param_016-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a90graphic"></a>
      <a id="bkm90graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_016.png"> </a>
    </p>
    <p class="Textbody">Как можно видеть на скриншоте, предшествовавшем этому, настройке поддаются и шрифты вывода времени, даты и текстового сообщения.</p>
    <h3 id="toc31"><a id="RefHeading15041713816058"></a><a id="bkmRefHeading15041713816058"></a><a id="toc30"></a><a id="bkmtoc30"></a><a id="RefHeading3641136957987"></a><a id="bkmRefHeading3641136957987"></a><a id="bkmRefHeading3641136957987"></a><a id="bkmbkmRefHeading3641136957987"></a>Окна и их тайлинг</h3>
    <p class="Textbody">В очерке об интерфейсе Cinnamon говорилось о средствах управления окнами по умолчанию. Настало время посмотреть, как эти умолчания можно изменить. Разумеется, делается это через пункт Окна. Здесь можно настроить стандартные действия при щелчках мышью на строке заголовка и режим передачи фокуса окну, если не устраивают умолчания — и думаю, очевидным способом. Меня умолчания устраивают, так что вдаваться в подробности не буду.</p>
    <p class="Textbody">Самое же интересное здесь — это примирение «правосторонников»» и «левосторонников», то есть приверженцев расположения кнопок управления окном с той или другой стороны строки заголовка:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_017.png">
        <img alt="Изображение91" class="frameGraphics" id="91graphic" src="http://alv.me/wp-content/img/im_cin_img/param_017-572x546.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:547.8337px" />
      </a>
      <a id="a91graphic"></a>
      <a id="bkm91graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_017.png"> </a>
    </p>
    <p class="Textbody">Как известно, в своё время революционная идея «левого уклона» кнопок в Ubuntu вызвала массу нападок со стороны «правых уклонистов» — твёрдых <span style="text-decoration:line-through">искровцев</span> GNOME’вцев. В Cinnamon принято компромиссное решение — любые кнопки можно поместить как с левой стороны титульной строки, так и с правой.</p>
    <p class="Textbody">Что, впрочем, тоже не ново, и испокон времён внедрено в оконных менеджерах KDE и Xfce. И чем я с давних пор пользуюсь — при общем «правом уклоне» делаю для кнопки закрытия окна «отмашку влево»: за долгие годы работы проверено, что это сильно снижает вероятность нажать её случайно, что обычно весьма не желательно.</p>
    <p class="Textbody">В очерке об интерфейсе я много места посвятил описанию тайлинга окон — как одной из особенностей, делающих Cinnamon «лучшим из десктопов». Настраивается же тайлинг в модуле Прикрепление окон и притяжение... Вот только настраивать здесь особенно нечего: для приобщения ко всем прелестям тайлинга достаточно отметить боксик Включить режим прикрепления — а это и так сделано по умолчанию:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_018.png">
        <img alt="Изображение92" class="frameGraphics" id="92graphic" src="http://alv.me/wp-content/img/im_cin_img/param_018-572x231.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:232.84789px" />
      </a>
      <a id="a92graphic"></a>
      <a id="bkm92graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_018.png"> </a>
    </p>
    <p class="Textbody">Что же до возможности изменить переключатель между режимами простого и защищённого прикрепления — мне она оказалась без надобности, умолчальный Control справляется с этой задачей не хуже других.</p>
    <p class="Textbody">Смысл включения притяжения к границам (так называемый Flip) — вовсе не в каком-то притяжении, а, как мне объяснили резонные люди, в самом обычном переключении на соседнюю рабочую область при подведении курсора мыши к границе текущей. Это меня всегда раздражало во всех графических средах — и эту опцию я всегда отключаю.</p>
    <p class="Textbody">На счёт инверсии клавиш со стрелками ничего сказать не могу, ибо не ощутил необходимости. А вот режим, названный традиционным, оказался не вредным. Только означает он, вопреки тому, как можно понять написанное, следующее: при его включении, если вам не хочется, чтобы какое-либо окно «превращалось в черепицу» при перемещёнии его к краю экрана, следует удерживать клавишу Shift.</p>
    <h3 id="toc32"><a id="RefHeading15061713816058"></a><a id="bkmRefHeading15061713816058"></a><a id="toc31"></a><a id="bkmtoc31"></a><a id="RefHeading3661136957987"></a><a id="bkmRefHeading3661136957987"></a><a id="bkmRefHeading3661136957987"></a><a id="bkmbkmRefHeading3661136957987"></a>Рабочие области и Горячие углы</h3>
    <p class="Textbody">Говоря в «интерфейсном» очерке о переключении между окнами, я вскользь упомянул о переключении в режим Expo, при котором на экран выводятся все наличные рабочие области. А уже в этом очерке просил обратить внимание на одноимённый апплет. Настало время поговорить обо всех этих материях подробнее.</p>
    <p class="Textbody">В том же «интерфейсном» очерке говорилось, что рабочих областей в Cinnamon по умолчанию две, и способа изменить это число на поверхности не видно, а переключение между имеющимися возможно только по комбинации клавиш Control+Alt с Right или Left. И всё это правда, чистая правда, но далеко не вся правда.</p>
    <p class="Textbody">Так, найти альтернативный способ переключения между рабочими областями не так уж и сложно даже при слабом знании английского. Это — упомянутый ранее апплет Workspace switcher: будучи включённым, он выводит на панель обычный переключатель рабочих столов, привычный всем пользователям интегрированных сред и многих оконных менеджеров:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_019.png">
        <img alt="Изображение93" class="frameGraphics" id="93graphic" src="http://alv.me/wp-content/img/im_cin_img/param_019.png" style="border:1.0px solid #000080;padding:0;width:270.83212px;height:41.830547px" />
      </a>
      <a id="a93graphic"></a>
      <a id="bkm93graphic"></a>
    </p>
    <p class="Textbody">Далее, логично было бы ожидать, что количество рабочих областей можно задать в модуле, который называется Рабочие области. Однако, открыв его, мы не увидим там и намёка на эту опцию:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_020.png">
        <img alt="Изображение94" class="frameGraphics" id="94graphic" src="http://alv.me/wp-content/img/im_cin_img/param_020-572x255.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:256.8479px" />
      </a>
      <a id="a94graphic"></a>
      <a id="bkm94graphic"></a>
    </p>
    <p class="Textbody">А смысл всех остальных опций этого модуля остаётся не очень понятным — так что рассмотрение его немного отложим.</p>
    <p class="Textbody">Потому что настало время вспомнить об апплете Expo. Ибо он служит для переключения Cinnamon в одноимённый режим — режим вывода на экран всех наличных рабочих областей одновременно:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_021.png">
        <img alt="Изображение95" class="frameGraphics" id="95graphic" src="http://alv.me/wp-content/img/im_cin_img/param_021-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a95graphic"></a>
      <a id="bkm95graphic"></a>
    </p>
    <p class="Textbody">Очевидно, что это ещё один способ переключения между рабочими областями — для чего достаточно кликнуть мышью на нужной. Но главное — это единственный способ увеличить их число, для чего служит большой жирный плюс с правой стороны экрана. А уменьшить количество рабочих областей можно с помощью крестика, появляющегося в правом верхней углу любой области при наведении на неё курсора:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_022.png">
        <img alt="Изображение96" class="frameGraphics" id="96graphic" src="http://alv.me/wp-content/img/im_cin_img/param_022-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a96graphic"></a>
      <a id="bkm96graphic"></a>
    </p>
    <p class="Textbody">Вот теперь, просветлев относительно режима экспонирования, можно вернуться к модулю Рабочие области, дабы осознать смысл его опций. И действительно, можно предполагать, что загадочная опция Гарабиты, которые почему-то измеряются в миллисекундах — это время задержки переключения в режим экспонирования, горизонтальное и вертикальное расположение в процентах — это размеры рабочих областей при представлении в этом режиме, перелистывание — возможность перемещёния между ними, прокручивая колёсико мыши. И радоваться своей солдатской смекалке.</p>
    <p class="Textbody">Радость эта омрачается одним: изменение любой опции не влечёт за собой никаких последствий от слова абсолютно. И в результате оказывается, что единственный рабочий пункт этого модуля — Показывать экспозицию как сетку. По умолчанию он включён. Снятие же с него отметки приводит к тому, что рабочие области в Expo-режиме выстраиваются в одну линию:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_023.png">
        <img alt="Изображение97" class="frameGraphics" id="97graphic" src="http://alv.me/wp-content/img/im_cin_img/param_023-572x463.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:464.8353px" />
      </a>
      <a id="a97graphic"></a>
      <a id="bkm97graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_023.png"> </a>
    </p>
    <p class="Textbody">Кстати, апплет Expo — не единственный способ переключения в одноимённый режим. Согласитесь, что было бы странно, если такая важная функция выполнялась с помощью внешнего апплета, да ещё и не включаемого по умолчанию. Главный, встроенный, способ перехода в режим экспонирования рабочих областей — комбинация клавиш Control+Alt+Up. Задействована и противоположная комбинация — Control+Alt+Down: Она переводит Cinnamon в режим, который можно назвать экспонированием окон (или режимом масштабирования): одновременный вывод всех окон всех открытых приложений текущей рабочей области, в том числе и свёрнутых:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_024.png">
        <img alt="Изображение98" class="frameGraphics" id="98graphic" src="http://alv.me/wp-content/img/im_cin_img/param_024-572x453.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:454.85727px" />
      </a>
      <a id="a98graphic"></a>
      <a id="bkm98graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_024.png"> </a>
    </p>
    <p class="Textbody">Однако и это ещё не всё: существует ещё один способ переключения в оба режима экспонирования. По умолчанию он отключён, а за его настройку его отвечает модуль Горячие углы. Он обеспечивает привязку к любому из углов экрана одного из трёх действий: переключения в режим экспонирования рабочих областей, в режим масштабирования окон или очистку рабочего стола (то есть сворачивания всех окон). Действия эти происходят при подведении курсора мыши к соответствующему углу. Повторное перемещёние курсора в тот же угол возвращает Cinnamon в нормальный рабочий режим.</p>
    <p class="Textbody">На следующем скриншоте в качестве «горячего» выступает правый нижний угол — к нему привязано экспонирование рабочих областей:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_025.png">
        <img alt="Изображение99" class="frameGraphics" id="99graphic" src="http://alv.me/wp-content/img/im_cin_img/param_025-572x247.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:248.83528px" />
      </a>
      <a id="a99graphic"></a>
      <a id="bkm99graphic"></a>
    </p>
    <p class="Textbody">Кроме того, потенциально через «горячий угол» можно выполнить произвольную команду. Так, на следующем скриншоте приведена попытка настроить правый верхний угол на вызов выпадающего терминала Tilda:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_026.png">
        <img alt="Изображение100" class="frameGraphics" id="100graphic" src="http://alv.me/wp-content/img/im_cin_img/param_026-572x247.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:248.83528px" />
      </a>
      <a id="a100graphic"></a>
      <a id="bkm100graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_026.png"> </a>
    </p>
    <p class="Textbody">Однако практика показала, что это неудобно, в том числе и потому, что при каждом наведении на «горячий угол» вызывался новый экземпляр терминала, который для начала желал, чтобы его настроили. А никакого другого применения этой фиче я не придумал. Может, у кого из читателей фантазия окажется богаче?</p>
    <h3 id="toc33"><a id="RefHeading15081713816058"></a><a id="bkmRefHeading15081713816058"></a><a id="toc32"></a><a id="bkmtoc32"></a><a id="RefHeading3681136957987"></a><a id="bkmRefHeading3681136957987"></a><a id="bkmRefHeading3681136957987"></a><a id="bkmbkmRefHeading3681136957987"></a>Конфиденциальность, Общие, Уведомления</h3>
    <p class="Textbody">Общего между этими тремя модулями, пожалуй, только то, что они были переработаны при переходе на Cinnamon версии 2.4.</p>
    <p class="Textbody">Вся настройка конфиденциальности сводится к решению вопроса, запоминать ли открываемые файлы, и если запоминать — навсегда или на какой-то определённый срок:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_027.png">
        <img alt="Изображение101" class="frameGraphics" id="101graphic" src="http://alv.me/wp-content/img/im_cin_img/param_027-572x158.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:159.8274px" />
      </a>
      <a id="a101graphic"></a>
      <a id="bkm101graphic"></a>
    </p>
    <p class="Textbody">Я остановился на варианте «вечного хранения».</p>
    <p class="Textbody">В модуле Общие обнаружилась интересная функция — возможность масштабирования рабочего стола. Для этого надо значение по умолчанию, Автоматически</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_028.png">
        <img alt="Изображение102" class="frameGraphics" id="102graphic" src="http://alv.me/wp-content/img/im_cin_img/param_028-572x232.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:233.83054px" />
      </a>
      <a id="a102graphic"></a>
      <a id="bkm102graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_028.png"> </a>
    </p>
    <p class="Textbody">заменить на Двукратный (HiDPI):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_029.png">
        <img alt="Изображение103" class="frameGraphics" id="103graphic" src="http://alv.me/wp-content/img/im_cin_img/param_029-572x230.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:231.82741px" />
      </a>
      <a id="a103graphic"></a>
      <a id="bkm103graphic"></a>
    </p>
    <p class="Textbody">Правда, после этого рабочий стол приобретает устрашающий вид даже для моего зрения:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_030.png">
        <img alt="Изображение104" class="frameGraphics" id="104graphic" src="http://alv.me/wp-content/img/im_cin_img/param_030-572x503.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:504.8227px" />
      </a>
      <a id="a104graphic"></a>
      <a id="bkm104graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_030.png"> </a>
    </p>
    <p class="Textbody">Но возможно, что в некоторых случаях это будет менее плохо, чем не видеть никакого вида вообще. Ну а пока я поспешил вернуться к виду нормальному (он оказался идентичным автоматическому).</p>
    <p class="Textbody">В модуле Уведомления можно, во-первых, отказаться от их вывода (по умолчанию он, разумеется, включён). Они часто раздражают — например, сообщения IM-клиента о том, что гражданин Имя Рек вошёл в сеть, а гражданин Некто из неё, напротив, вышел. Однако совсем отключать уведомления неправильно, потому что временами они несут разумное, хотя обычно как раз не доброе. А вот удалять сообщения по истечении тайм-аута — как раз разумно, что и проделано на скриншоте:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_031.png">
        <img alt="Изображение105" class="frameGraphics" id="105graphic" src="http://alv.me/wp-content/img/im_cin_img/param_031-572x258.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:259.8337px" />
      </a>
      <a id="a105graphic"></a>
      <a id="bkm105graphic"></a>
    </p>
    <p class="Textbody">Кроме того, здесь же можно отрегулировать прозрачность уведомления, и немедленно протестировать это дело нажатием на соответствующую кнопку:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_032.png">
        <img alt="Изображение106" class="frameGraphics" id="106graphic" src="http://alv.me/wp-content/img/im_cin_img/param_032-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a106graphic"></a>
      <a id="bkm106graphic"></a>
    </p>
    <p class="Textbody">Я уменьшил прозрачность практически до минимума, так как иначе ничего не видел. А ведь уведомления — для того, чтобы их читать, не так ли?</p>
    <h3 id="toc34"><a id="RefHeading15101713816058"></a><a id="bkmRefHeading15101713816058"></a><a id="toc33"></a><a id="bkmtoc33"></a><a id="RefHeading3701136957987"></a><a id="bkmRefHeading3701136957987"></a><a id="bkmRefHeading3701136957987"></a><a id="bkmbkmRefHeading3701136957987"></a>Детали учётной записи</h3>
    <p class="Textbody">Не смотря на название модуля, Детали учётной записи, никаких особых деталей там нет:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_033.png">
        <img alt="Изображение107" class="frameGraphics" id="107graphic" src="http://alv.me/wp-content/img/im_cin_img/param_033-572x188.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:189.83685px" />
      </a>
      <a id="a107graphic"></a>
      <a id="bkm107graphic"></a>
    </p>
    <p class="Textbody">А есть возможность поменять пароль (к чему в некоторых случаях время от времени прибегать приходится) и изменить логин. Хотя вот последнего как раз делать не следует: численный идентификатор пользователя (так называемый UID) при этом не меняется, так что, скажем, на правах доступа к файлам это сказаться не должно. Но в каких-то случаях программы могут обращаться не к UID'у, а именно к названию аккаунта, и ничего, кроме путаницы, это не даст. Зато можно приклеить собственную аватарку, как это видно на скриншоте.</p>
    <h3 id="toc35"><a id="RefHeading15121713816058"></a><a id="bkmRefHeading15121713816058"></a><a id="toc34"></a><a id="bkmtoc34"></a><a id="RefHeading3721136957987"></a><a id="bkmRefHeading3721136957987"></a><a id="bkmRefHeading3721136957987"></a><a id="bkmbkmRefHeading3721136957987"></a>Прочие параметры</h3>
    <p class="Textbody">По остальным пунктам секции Параметры я позволю себе пробежаться галопом — они или не очень существенны (с моей точки зрения), или тривиальны. Неохваченными у нас остались (слева направо и сверху вниз):</p>
    <p class="Textbody">Дата и время, смысл которого очевиден:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_034.png">
        <img alt="Изображение108" class="frameGraphics" id="108graphic" src="http://alv.me/wp-content/img/im_cin_img/param_034-572x288.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:289.84314px" />
      </a>
      <a id="a108graphic"></a>
      <a id="bkm108graphic"></a>
    </p>
    <p class="Textbody">Приложения и съёмные носители — аналогично:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_035.png">
        <img alt="Изображение109" class="frameGraphics" id="109graphic" src="http://alv.me/wp-content/img/im_cin_img/param_035-572x343.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:344.8353px" />
      </a>
      <a id="a109graphic"></a>
      <a id="bkm109graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_036.png">
        <img alt="Изображение110" class="frameGraphics" id="110graphic" src="http://alv.me/wp-content/img/im_cin_img/param_036-572x343.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:344.8353px" />
      </a>
      <a id="a110graphic"></a>
      <a id="bkm110graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_036.png"> </a>
    </p>
    <p class="Textbody">Ну а Специальные возможности — они и есть специальные:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_037.png">
        <img alt="Изображение111" class="frameGraphics" id="111graphic" src="http://alv.me/wp-content/img/im_cin_img/param_037-572x427.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:428.8542px" />
      </a>
      <a id="a111graphic"></a>
      <a id="bkm111graphic"></a>
    </p>
    <p class="Textbody">Не смотря на то, что они предусмотрены во всех рабочих средах и вроде бы предназначены как раз для таких как я (в частности, плохо видящих), прибегнуть к ним мне не приходилось: они либо не нужны, либо бесполезны.</p>
    <p class="Textbody">Я умышленно не сказал ничего о модуле Языки. Потому что на самом деле это не модуль Системных настроек Cinnamon, а одна из фирменных утилит Mint, в ряду которых и будет рассмотрена в одном из последующих очерков.</p>
    <h2 id="toc36"><a id="RefHeading15141713816058"></a><a id="bkmRefHeading15141713816058"></a><a id="toc35"></a><a id="bkmtoc35"></a><a id="RefHeading12521136957987"></a><a id="bkmRefHeading12521136957987"></a><a id="bkmRefHeading12521136957987"></a><a id="bkmbkmRefHeading12521136957987"></a>Секция Оборудование</h2>
    <p class="Textbody">В секции Оборудование собраны модули, имеющие, как ни странно, отношение именно к оборудованию. И обозреть их все единым взглядом можно здесь:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_038.png">
        <img alt="Изображение112" class="frameGraphics" id="112graphic" src="http://alv.me/wp-content/img/im_cin_img/param_038-572x348.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:349.82428px" />
      </a>
      <a id="a112graphic"></a>
      <a id="bkm112graphic"></a>
    </p>
    <p class="Textbody">А поскольку внутренней логикой они не особо между собой связаны (за одним исключением), и к тому же кое-какого оборудования у меня просто нет, то рассматривать эти модули я буду в произвольном порядке, руководствуясь собственными соображениями о их важности. Начав, однако, с самого общего — О системе.</p>
    <h3 id="toc37"><a id="RefHeading15161713816058"></a><a id="bkmRefHeading15161713816058"></a><a id="toc36"></a><a id="bkmtoc36"></a><a id="RefHeading3741136957987"></a><a id="bkmRefHeading3741136957987"></a><a id="bkmRefHeading3741136957987"></a><a id="bkmbkmRefHeading3741136957987"></a>О системе и дисплее</h3>
    <p class="Textbody">Модуль О системе не предусматривает никаких настроек, а просто выводит сведения о ней, родимой, в простой и наглядной форме:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_039.png">
        <img alt="Изображение113" class="frameGraphics" id="113graphic" src="http://alv.me/wp-content/img/im_cin_img/param_039-572x192.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:193.84315px" />
      </a>
      <a id="a113graphic"></a>
      <a id="bkm113graphic"></a>
    </p>
    <p class="Textbody">Думаю, тому, кто знает такие слова, как операционная система или процессор, не составит очень большого труда догадаться о том, что означают и соответствующие им значения.</p>
    <p class="Textbody">Модуль Дисплей я приплюсовал сюда же, так как в случае одномониторной конфигурации, да ещё и не с поворачивающимся экраном, он тоже просто выводит самые общие сведения о мониторе и его разрешении:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_040.png">
        <img alt="Изображение114" class="frameGraphics" id="114graphic" src="http://alv.me/wp-content/img/im_cin_img/param_040-572x298.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:299.85892px" />
      </a>
      <a id="a114graphic"></a>
      <a id="bkm114graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_040.png"> </a>
    </p>
    <p class="Textbody">Во всех же прочих пунктах секции предполагается совершение некоторых настроечных действий. Из них для нас важнейшим является настройка клавиатуры — с неё-то и начнём.</p>
    <h3 id="toc38"><a id="RefHeading15181713816058"></a><a id="bkmRefHeading15181713816058"></a><a id="toc37"></a><a id="bkmtoc37"></a><a id="RefHeading3761136957987"></a><a id="bkmRefHeading3761136957987"></a><a id="bkmRefHeading3761136957987"></a><a id="bkmbkmRefHeading3761136957987"></a>Клавиатура</h3>
    <p class="Textbody">В модуле Клавиатура для начала можно настроить поведение при нажатии клавиш и реакцию курсора:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_041.png">
        <img alt="Изображение115" class="frameGraphics" id="115graphic" src="http://alv.me/wp-content/img/im_cin_img/param_041-572x376.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:377.83057px" />
      </a>
      <a id="a115graphic"></a>
      <a id="bkm115graphic"></a>
    </p>
    <p class="Textbody">А во второй вкладке, Комбинации клавиш, определить хоткеи на очень многие случаи жизни:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_042.png">
        <img alt="Изображение116" class="frameGraphics" id="116graphic" src="http://alv.me/wp-content/img/im_cin_img/param_042-572x294.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:295.85257px" />
      </a>
      <a id="a116graphic"></a>
      <a id="bkm116graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_042.png"> </a>
    </p>
    <p class="Textbody">В частности, здесь я в обязательном порядке устанавливаю клавишные комбинации для переключения между рабочими областями — Alt+1, Alt+2 и так далее (пункт Рабочие области):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_043.png">
        <img alt="Изображение117" class="frameGraphics" id="117graphic" src="http://alv.me/wp-content/img/im_cin_img/param_043-572x253.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:254.84474px" />
      </a>
      <a id="a117graphic"></a>
      <a id="bkm117graphic"></a>
    </p>
    <p class="Textbody">В некоторых случаях может быть полезным назначение хоткеев для перемещёния окон в подпункте Размещёние пункта Окна — в правый верхний угол, левый верхний угол, и так далее (по умолчанию не включены):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_044.png">
        <img alt="Изображение118" class="frameGraphics" id="118graphic" src="http://alv.me/wp-content/img/im_cin_img/param_044-572x253.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:254.84474px" />
      </a>
      <a id="a118graphic"></a>
      <a id="bkm118graphic"></a>
    </p>
    <p class="Textbody">Такие перемещёния не следует путать с управлением тайлингом — размер окна при этом не меняется. А собственно настройки управления тайлингом выполняются в том же пункте Окна — соответствующий подпункт так и называется, Tiling and Snapping. Именно здесь можно изменить умолчальные комбинации типа Super плюс стрелки, описанные в предыдущем очерке:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_045.png">
        <img alt="Изображение119" class="frameGraphics" id="119graphic" src="http://alv.me/wp-content/img/im_cin_img/param_045-572x253.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:254.84474px" />
      </a>
      <a id="a119graphic"></a>
      <a id="bkm119graphic"></a>
    </p>
    <p class="Textbody">В пункте Общие (он идёт первым в списке) можно перенастроить переходы в режим Expo и масштабирования:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_046.png">
        <img alt="Изображение120" class="frameGraphics" id="120graphic" src="http://alv.me/wp-content/img/im_cin_img/param_046-572x253.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:254.84474px" />
      </a>
      <a id="a120graphic"></a>
      <a id="bkm120graphic"></a>
    </p>
    <p class="Textbody">Раньше здесь же можно было лишить клавишу Super_L (она же — левая win-клавиша) её сакрального значения — вызова меню. В версии 2.4 эта возможность пропала, но кто знает? Может, появится снова. Ведь Cinnamon — не Unity, где всё на супер-клавишу завязано, так что нет смысла трястись над этой священной коровой.</p>
    <p class="Textbody">В мои цели не входит описывать все действия, для которых можно определить комбинации. Но думаю, что и сказанного достаточно для иллюстрации факта: перед любителями оперировать хоткеями открывается очень широкое поле деятельности.</p>
    <p class="Textbody">Вкладка Раскладки клавиатуры очень важна для для многих применителей-текстовиков, и потому её рассмотрение выделяется в особое производство.</p>
    <h3 id="toc39"><a id="RefHeading15201713816058"></a><a id="bkmRefHeading15201713816058"></a><a id="toc38"></a><a id="bkmtoc38"></a><a id="RefHeading3781136957987"></a><a id="bkmRefHeading3781136957987"></a><a id="bkmRefHeading3781136957987"></a><a id="bkmbkmRefHeading3781136957987"></a>Раскладки и переключатели</h3>
    <p class="Textbody">Настройка раскладок клавиатуры и переключателей между ними может быть не актуальной для тех применителей, которых устраивают умолчания инсталлятора — вариант winkeys для русской раскладки и комбинация Alt+Shift в качестве переключателя раскладок:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_047.png">
        <img alt="Изображение121" class="frameGraphics" id="121graphic" src="http://alv.me/wp-content/img/im_cin_img/param_047-572x388.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:389.84946px" />
      </a>
      <a id="a121graphic"></a>
      <a id="bkm121graphic"></a>
    </p>
    <p class="Textbody">Но для требовательных применителей-текстовиков здесь есть все возможности не изменять своим привычкам, а заодно и приобрести новые, полезные.</p>
    <p class="Textbody">Перво-наперво следует определиться, использовать ли одинаковую раскладку во всех окнах, или в каждом — свою, что делается отметкой одной из соответствующих радиокнопок (см. предыдущий скриншот). А во втором случае — решить, будет ли раскладка нового окна наследоваться от таковой окна предыдущего, или же от умолчальной раскладки, той, что стоит в списке первой (на самом деле это тоже раскладка окна — так называемого корневого окна Иксов).</p>
    <p class="Textbody">До некоторого времени наследование раскладки в Cinnamonm работало произвольным образом. В версии 2.4 это изжито, и при включении последней опции раскладка в новом окне действительно будет умолчальной. За единственным, отмеченным ранее, исключением: в строке инкременетного поиска главного меню среды раскладка почему-то всегда наследуется от текущей.</p>
    <p class="Textbody">Далее переходим к выбору варианта русской раскладки. Список их включает все обычные варианты, немало экзотических и несколько национальных:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_048.png">
        <img alt="Изображение122" class="frameGraphics" id="122graphic" src="http://alv.me/wp-content/img/im_cin_img/param_048-572x564.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:565.8243px" />
      </a>
      <a id="a122graphic"></a>
      <a id="bkm122graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_048.png"> </a>
    </p>
    <p class="Textbody">В случае сомнений раскладку можно, с помощью кнопки Предпросмотр, поглядеть на экране:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_049.png">
        <img alt="Изображение123" class="frameGraphics" id="123graphic" src="http://alv.me/wp-content/img/im_cin_img/param_049-572x243.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:244.82898px" />
      </a>
      <a id="a123graphic"></a>
      <a id="bkm123graphic"></a>
    </p>
    <p class="Textbody">Я, ввиду большого стажа ремингтониста (это — мужской вариант професси машинистки), предпочитаю вариант Typewriter Legacy, обзываемый по русски печатная машинка, устаревшая. Вдаваться в обоснования этого выбора и тем более агитировать за него здесь неуместно. Заинтересованных отсылаю к <a href="http://alv.me/?p=615" target="_blank">специальному материалу</a>.</p>
    <p class="Textbody">Из прочих вариантов интересен вот этот: Русский (Польша, фонетический Дворак). Чего там осталось от раскладки профессора Дворака — разве что то, что это и близко не QWERTY. Но расположение алфавитно-цифровых символов и знаков препинания на ней выглядит вполне разумным:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/cinnamon_049a.png">
        <img alt="Изображение124" class="frameGraphics" id="124graphic" src="http://alv.me/wp-content/img/im_cin_img/cinnamon_049a-572x243.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:244.82898px" />
      </a>
      <a id="a124graphic"></a>
      <a id="bkm124graphic"></a>
    </p>
    <p class="Textbody">Правда, есть большие сомнения в том, что эта разумность стоит полного переучивания.</p>
    <p class="Textbody">Нет напряга и с переключателями раскладок — они входят в число параметров, вызываемых, как ни странно, кнопкой Параметры:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_050.png">
        <img alt="Изображение125" class="frameGraphics" id="125graphic" src="http://alv.me/wp-content/img/im_cin_img/param_050.png" style="border:1.0px solid #000080;padding:0;width:551.84px;height:401.83054px" />
      </a>
      <a id="a125graphic"></a>
      <a id="bkm125graphic"></a>
    </p>
    <p class="Textbody">Легко догадаться, что переключение настраивается в пункте Переключение на другую раскладку, и в нём можно найти переключатель на любой вкус:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_051.png">
        <img alt="Изображение126" class="frameGraphics" id="126graphic" src="http://alv.me/wp-content/img/im_cin_img/param_051.png" style="border:1.0px solid #000080;padding:0;width:551.84px;height:401.83054px" />
      </a>
      <a id="a126graphic"></a>
      <a id="bkm126graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_051.png"> </a>
    </p>
    <p class="Textbody">Имеются и немодальные переключатели — это своего рода заменители корректоров ввода при «неправильной» раскладке, примером которых в Linux'е выступает программа X Neural Switcher (точнее, в Иксах, ибо работает также и в любых BSD-системах). Ибо из применителей может сказать, положа руку на сердце и поклявшись на своём Священном Писании, что он никогда, никогда, никогда... не забывал переключать раскладку клавиатуры с латиницы на кириллицу (или наоборот)?</p>
    <p class="Textbody">Достоинства и недостатки XNeur обсуждались многократно, поэтому повторю только главный из последних: эта утилита принадлежит к тем, которые полагают себя умнее своих создателей (и, тем более, применителей), и потому часто автоматика его срабатывает прозвольным образом. Конечно, он имеет и «ручной» режим работы, но его использрвание очень узко: если вовремя заметить, что в «не той» раскладке набрано одно слово или его кусок, обычно проще и быстрей тут же перенабрать его, нежели выделять кусок текста и заказывать для него перекодирование.</p>
    <p class="Textbody">Тем более, что «проблему забывчивости» применительно к переключению раскладок можно попытаться решить другим способом — я бы назвал его «кембриджским». Как известно, в Оксфордском университете, воспитывавшем английских джентльменов, учили мыть руки после туалета. А в более прагматичном Кембридже, давшем миру немало естествоиспытателей, учили не справлять малую нужду на руки. Первому алгоритму следует программа XNeur, второй же можно реализовать, сведя к минимуму вероятность забывчивости при наборе. Чему очень поспособствуют те самые немодальные (или нециклические) переключатели раскладок.</p>
    <p class="Textbody">Суть немодальных переключателей в том, что они ничего не переключают, а включают. То есть одна определённая клавиша (или их комбинация) всегда включает английскую раскладку, а другая делает то же самое для раскладки русской. И в использовании их есть только одна проблема — привыкание. То есть нужно отучиться смотреть на индикаторы раскладки. Нужно забыть о том:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">какая раскладка является текущей; </p>
      </li>
      <li>
        <p class="Textbody">какая раскладка является умолчальной; </p>
      </li>
      <li>
        <p class="Textbody">от кого наследуется раскладка нового окна — от корневого окна (то есть повторяет умолчальную) или от окна текущего. </p>
      </li>
    </ul>
    <p class="Textbody">А помнить нужно только одно: перед вводом любого кириллического текста нажать, скажем, комбинацию Shift+CapsLock, а переходя к вводу латиницы — клавишу CapsLock. Подобно тому, как при вводе прописной буквы мы автоматически нажимаем Shift, не задумываясь особо о причинах этого.</p>
    <p class="Textbody">Немодальных переключателей предлагается довольно много:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/nomod-sw_001.png">
        <img alt="Изображение127" class="frameGraphics" id="127graphic" src="http://alv.me/wp-content/img/im_cin_img/nomod-sw_001-535x572.png" style="border:1.0px solid #000080;padding:0;width:536.83527px;height:573.83685px" />
      </a>
      <a id="a127graphic"></a>
      <a id="bkm127graphic"></a>
    </p>
    <p class="Textbody">Далее, чтобы побороть забывчивость при переключении раскладок, надо переключать их как можно реже. И на сей предмет придуманы временные переключатели, действующие, пока нажата определённая клавиша — в частности, они совершенно незаменимы при вводе типографских символов с использованием клавиши Compose, о чём я скажу чуть позже. Причём они не исключают использования любых постоянных переключателей, как модальных, так и немодальных.</p>
    <p class="Textbody">Традиционно в качестве временного переключателя используется правая клавиша Control, но и тут выбор достаточно велик:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/nomod-sw_003.png">
        <img alt="Изображение128" class="frameGraphics" id="128graphic" src="http://alv.me/wp-content/img/im_cin_img/nomod-sw_003-435x572.png" style="border:1.0px solid #000080;padding:0;width:436.829px;height:573.83685px" />
      </a>
      <a id="a128graphic"></a>
      <a id="bkm128graphic"></a>
    </p>
    <p class="Textbody">А вообще все возможные переключатели раскладок, модальные, немодальные и временные, можно посмотреть в файле /usr/share/X11/xkb/rules/evdev.lst — в секции ! option, где они перечислены в строках, начинающихся с grp:</p>
    <p class="Textbody"><span style="background-color:#dddddd">! option</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp                  Switching to another layout</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:switch           Right Alt (while pressed)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:lswitch          Left Alt (while pressed)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:lwin_switch      Left Win (while pressed)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:rwin_switch      Right Win (while pressed)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:win_switch       Any Win key (while pressed)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:caps_switch      Caps Lock (while pressed), Alt+Caps Lock does the original capslock action</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:rctrl_switch     Right Ctrl (while pressed)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:toggle           Right Alt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:lalt_toggle      Left Alt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:caps_toggle      Caps Lock</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:shift_caps_toggle Shift+Caps Lock</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:shift_caps_switch Caps Lock (to first layout), Shift+Caps Lock (to last layout)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:win_menu_switch  Left Win (to first layout), Right Win/Menu (to last layout)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:lctrl_rctrl_switch Left Ctrl (to first layout), Right Ctrl (to last layout)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:alt_caps_toggle  Alt+Caps Lock</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:shifts_toggle    Both Shift keys together</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:alts_toggle      Both Alt keys together</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:ctrls_toggle     Both Ctrl keys together</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:ctrl_shift_toggle Ctrl+Shift</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:lctrl_lshift_toggle Left Ctrl+Left Shift</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:rctrl_rshift_toggle Right Ctrl+Right Shift</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:ctrl_alt_toggle  Alt+Ctrl</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:alt_shift_toggle Alt+Shift</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:lalt_lshift_toggle Left Alt+Left Shift</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:alt_space_toggle Alt+Space</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:menu_toggle      Menu</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:lwin_toggle      Left Win</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:rwin_toggle      Right Win</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:lshift_toggle    Left Shift</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:rshift_toggle    Right Shift</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:lctrl_toggle     Left Ctrl</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:rctrl_toggle     Right Ctrl</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  grp:sclk_toggle      Scroll Lock</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">  grp:lctrl_lwin_rctrl_menu LeftCtrl+LeftWin (to first layout), RightCtrl+Menu (to second layout)</span> </p>
    <p class="Textbody">Руководствуясь этим списком, переключатели раскладок (в числе прочих параметров) можно изменить и через Редактор dconf, о котором со временем пойдёт речь.</p>
    <p class="Textbody">Кроме того, настройкой переключателей параметры клавиатуры не исчерпываются. Например, на десктопах резонно Использовать клавиатурные индикаторы для отображения дополнительных раскладок:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_053.png">
        <img alt="Изображение129" class="frameGraphics" id="129graphic" src="http://alv.me/wp-content/img/im_cin_img/param_053-572x278.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:279.82742px" />
      </a>
      <a id="a129graphic"></a>
      <a id="bkm129graphic"></a>
    </p>
    <p class="Textbody">В ряде случаев полезно в Разных параметрах совместимости установить опцию С клавиш цифровой клавиатуры всегда вводятся цифры — вне зависимости от настроек BIOS и общесистемных:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_054.png">
        <img alt="Изображение130" class="frameGraphics" id="130graphic" src="http://alv.me/wp-content/img/im_cin_img/param_054-572x397.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:398.8448px" />
      </a>
      <a id="a130graphic"></a>
      <a id="bkm130graphic"></a>
    </p>
    <p class="Textbody">И, наконец, сакраментальный вопрос о вводе типографских символов. Хотя уже давно, как <a href="http://mintmem.com/page/lm-16-cinnamon-compose-key" target="_blank">заметил Brego</a>,</p>
    <p class="Textbody">...данная задача решается не просто и даже не очень просто, а примитивно.</p>
    <p class="Textbody">А именно — так. Для начала поддержку ввода типографских символов следует включить — это делается в тех же Разных параметрах совместимости (см. предыдущий скриншот).</p>
    <p class="Textbody">Далее нужно определить Положение клавиши Compose — она служит для переключения в режим ввода единичного типографского символа. Список вариантов тут более чем обширен:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_055.png">
        <img alt="Изображение131" class="frameGraphics" id="131graphic" src="http://alv.me/wp-content/img/im_cin_img/param_055-572x545.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:546.851px" />
      </a>
      <a id="a131graphic"></a>
      <a id="bkm131graphic"></a>
    </p>
    <p class="Textbody">И последнее, но самое главное: затвердить, как символ веры (своей, разумеется) список кейбиндов для типографских символов. Если и не полный, который можно найти в файле /usr/share/X11/locale/en_US.UTF-8/Compose, то хотя бы суперминималистический, образуемый с помощью Compose плюс:</p>
    <p class="Textbody"><span style="background-color:#dddddd">--.         —       en dash</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">---         —       em dash</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">spb spb     nbsp    неразрывный пробел</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">&lt;&lt;          «       открывающая кавычка &gt;&gt;          »       закрывающая кавычка</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">..          …       многоточие</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">oo          °       градус</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">+-          ±       плюс-минус</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">oc          ©       копирайт</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">^2          ²       в квадрате</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">12          ½       одна вторая</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Набор любой степени — Compose ^ #</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">где # — нужная степень</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Набор (почти) любой дроби — Compose  x y</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">где x — числитель, y — знаменатель</span> </p>
    <p class="Textbody">Правда, правила для набора дробей имеют исключения. Так, в моей системе не выводятся все дроби, содержащие цифру 7, что в числителе, что в знаменателе. За единственным исключением — дробь ⅞ почему-то пропечатывалась. Не печатаются также и дроби с цифрой 9, в том числе и бессмысленные, тип 3/9 и 9/3. Причём девятка не проходит ни в каких сочетаниях, и ни в какой позиции, без всяких, в отличие от семёрки, исключений.</p>
    <p class="Textbody">Да, ещё самое распоследнее: следует помнить, что ввод типографики после Compose работает только при латинской раскладке клавиатуры. И вот тут-то самое время вспомнить о временных, или «удержальных», переключателях — при некотором навыке они здорово упрощают ввод типографики.</p>
    <h3 id="toc40"><a id="RefHeading15221713816058"></a><a id="bkmRefHeading15221713816058"></a><a id="toc39"></a><a id="bkmtoc39"></a><a id="RefHeading3801136957987"></a><a id="bkmRefHeading3801136957987"></a><a id="bkmRefHeading3801136957987"></a><a id="bkmbkmRefHeading3801136957987"></a>Мышь и сенсорная панель</h3>
    <p class="Textbody">О настройках мыши мало что можно сказать. Разве что рассмотреть скриншот и решить, что следует здесь поменять — и следует ли что-то менять вообще. Для меня оказалась полезной опция Показывать позицию указателя при нажатии клавиши Ctrl — способствует отысканию курсора, если он затерялся в океане безбрежного широкоформатного монитора:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_056.png">
        <img alt="Изображение132" class="frameGraphics" id="132graphic" src="http://alv.me/wp-content/img/im_cin_img/param_056-572x476.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:477.83688px" />
      </a>
      <a id="a132graphic"></a>
      <a id="bkm132graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_056.png"> </a>
    </p>
    <p class="Textbody">А вот настройка сенсорной панели — очень существенный момент при работе на ноутбуке. Хотя на своей Ноутбучке я ограничился переключением режима прокрутки — водить по ней двумя пальцами мне удобней, чем елозить одним по краю:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_057.png">
        <img alt="Изображение133" class="frameGraphics" id="133graphic" src="http://alv.me/wp-content/img/im_cin_img/param_057-572x431.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:432.82272px" />
      </a>
      <a id="a133graphic"></a>
      <a id="bkm133graphic"></a>
    </p>
    <p class="Textbody">Но, как хвастаются разработчики (и как видно на скриншоте), в Cinnamon 2.4 появилась поддержка «однокнопочных» тачпадов — от Macbook'ов этой модой заразились и производители некоторых «обычных» ноутбуков. Действительно, опции, имеющие к этому отношение, присутствуют. Но что они делают и как работают — проверить не смог, ибо моя Ноутбучка имеет две натуральные, традиционно ориентированные, кнопки.</p>
    <p class="Textbody">Раз уж речь зашла о ноутбуках, добавлю тут же пару слов про модуль Управление питанием. Я этим вопросом особенно не заморачиваюсь, ограничиваясь отключением всего того энергосбережения, которое можно отключить:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_058.png">
        <img alt="Изображение134" class="frameGraphics" id="134graphic" src="http://alv.me/wp-content/img/im_cin_img/param_058-572x411.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:412.82895px" />
      </a>
      <a id="a134graphic"></a>
      <a id="bkm134graphic"></a>
    </p>
    <p class="Textbody">А с прочими опциями предлагаю разбираться заинтересованным лицам. Как и с модулем Bluetooth, поскольку соответствующие устройства я не использую.</p>
    <h3 id="toc41"><a id="RefHeading15241713816058"></a><a id="bkmRefHeading15241713816058"></a><a id="toc40"></a><a id="bkmtoc40"></a><a id="RefHeading3821136957987"></a><a id="bkmRefHeading3821136957987"></a><a id="bkmRefHeading3821136957987"></a><a id="bkmbkmRefHeading3821136957987"></a>Звук</h3>
    <p class="Textbody">С настройками звука дело теоретически обстоит так: запустив соответствующий модуль, можно для начала определить устройство воспроизведения оного. У меня таковым по умолчанию выставляется HDMI, по которому подключён монитор со встроенными колонками. Ни малейшего звука при этом не воспроизводится — он начинает звучать только при переключении на аналоговый выход (S/PDIF у меня нет):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_059.png">
        <img alt="Изображение135" class="frameGraphics" id="135graphic" src="http://alv.me/wp-content/img/im_cin_img/param_059-572x489.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:490.83844px" />
      </a>
      <a id="a135graphic"></a>
      <a id="bkm135graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_059.png"> </a>
    </p>
    <p class="Textbody">После чего остаётся проверить звучание — с неизменно превосходным результатом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_060.png">
        <img alt="Изображение136" class="frameGraphics" id="136graphic" src="http://alv.me/wp-content/img/im_cin_img/param_060-572x269.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:270.83212px" />
      </a>
      <a id="a136graphic"></a>
      <a id="bkm136graphic"></a>
    </p>
    <p class="Textbody">И слушать музыку или смотреть кино со звуковым сопровождением — штатными ли средствами Mint (Banshee и Totem, соответственно) или через более привычный мне Mplayer.</p>
    <h3 id="toc42"><a id="RefHeading15261713816058"></a><a id="bkmRefHeading15261713816058"></a><a id="toc41"></a><a id="bkmtoc41"></a><a id="RefHeading3841136957987"></a><a id="bkmRefHeading3841136957987"></a><a id="bkmRefHeading3841136957987"></a><a id="bkmbkmRefHeading3841136957987"></a>Принтеры и цвет</h3>
    <p class="Textbody">В секции Оборудование остались неохваченными вниманием два модуля — и описание обоих вполне уместится на одну страницу. Обратившись у пункту Принтеры, я увидел, что у меня нет настроенных принтеров:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_061.png">
        <img alt="Изображение137" class="frameGraphics" id="137graphic" src="http://alv.me/wp-content/img/im_cin_img/param_061.png" style="border:1.0px solid #000080;padding:0;width:451.83374px;height:266.82584px" />
      </a>
      <a id="a137graphic"></a>
      <a id="bkm137graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_061.png"> </a>
    </p>
    <p class="Textbody">Поскольку физически у меня имелось МФУ DeskJet 2050, я нажал кнопку Добавить — и увидел, что такое действительно имеет место быть:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_062.png">
        <img alt="Изображение138" class="frameGraphics" id="138graphic" src="http://alv.me/wp-content/img/im_cin_img/param_062-572x361.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:362.82584px" />
      </a>
      <a id="a138graphic"></a>
      <a id="bkm138graphic"></a>
    </p>
    <p class="Textbody">Оставалось его настроить — для чего была нажата кнопка Вперёд, после чего было выведено некое умолчальное описание принтера:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_063.png">
        <img alt="Изображение139" class="frameGraphics" id="139graphic" src="http://alv.me/wp-content/img/im_cin_img/param_063-572x361.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:362.82584px" />
      </a>
      <a id="a139graphic"></a>
      <a id="bkm139graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_063.png"> </a>
    </p>
    <p class="Textbody">Его можно подкорректировать, но я этого делать не стал. А нажал кнопку Применить, через несколько секунд, ушедших на поиск драйверов, получил предложение напечатать пробную страницу:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_064.png">
        <img alt="Изображение140" class="frameGraphics" id="140graphic" src="http://alv.me/wp-content/img/im_cin_img/param_064.png" style="border:1.0px solid #000080;padding:0;width:509.8495px;height:132.84158px" />
      </a>
      <a id="a140graphic"></a>
      <a id="bkm140graphic"></a>
    </p>
    <p class="Textbody">Вслед за чем оказалось, что принтер волшебным образом у меня появился:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_065.png">
        <img alt="Изображение141" class="frameGraphics" id="141graphic" src="http://alv.me/wp-content/img/im_cin_img/param_065.png" style="border:1.0px solid #000080;padding:0;width:451.83374px;height:266.82584px" />
      </a>
      <a id="a141graphic"></a>
      <a id="bkm141graphic"></a>
    </p>
    <p class="Textbody">И свойства его оказались таковы:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_066.png">
        <img alt="Изображение142" class="frameGraphics" id="142graphic" src="http://alv.me/wp-content/img/im_cin_img/param_066-572x323.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:324.84158px" />
      </a>
      <a id="a142graphic"></a>
      <a id="bkm142graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_066.png"> </a>
    </p>
    <p class="Textbody">Надо сказать, что всё это потребовалось только потому, что при инсталляции Mint 17.1 Rebecca с нуля я не включил принтер. Иначе всё было бы автоматически установлено посредством HPLIP (HP Linux Imaging and Printing). Именно так было у меня при установке Mint 17 Qiana — ни малейших усилий по настройке принтера я тогда не прикладывал. Но, когда он мне понадобился впервые (а принтер мне требуется максимум раз в квартал), обнаружил, что он есть и готов к работе.</p>
    <p class="Textbody">Кстати, в обоих случаях моё МФУ, в соответствие со своим многофункциональным титулом, способно и сканировать — причём опять-таки без всяких настроечных действий. Что, впрочем, к нынешней теме не относится. Да и ставить это надо в заслугу не Cinnamon, и даже не Mint, а фирме HP и разработчикам системы HPLIP. Вот уже в который раз и на котором дистрибутиве я убеждаюсь, что HPLIP полностью избавил применителя от забот о настройке печати и сканирования. Правда, только счастливого обладателя продукции HP.</p>
    <p class="Textbody">И, наконец, последний модуль секции носит имя Цвет, а суть его заключается в калибровке цветов монитора и принтера. Поскольку я в этом ничего не понимаю и ни малейшей потребности понимать не испытываю, ограничусь скриншотом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_067.png">
        <img alt="Изображение143" class="frameGraphics" id="143graphic" src="http://alv.me/wp-content/img/im_cin_img/param_067-572x277.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:278.84473px" />
      </a>
      <a id="a143graphic"></a>
      <a id="bkm143graphic"></a>
    </p>
    <p class="Textbody">А уж кому нужно или интересно — делайте с ним что хотите.</p>
    <h2 id="toc43"><a id="RefHeading15281713816058"></a><a id="bkmRefHeading15281713816058"></a><a id="toc42"></a><a id="bkmtoc42"></a><a id="RefHeading12541136957987"></a><a id="bkmRefHeading12541136957987"></a><a id="bkmRefHeading12541136957987"></a><a id="bkmbkmRefHeading12541136957987"></a>Секция Администрирование</h2>
    <p class="Textbody">Наступает волнующий момент — среди штатных настроек Cinnamon'а осталась одна секция --Администрирование, а в ней — четыре модуля:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Источники приложений; </p>
      </li>
      <li>
        <p class="Textbody">Менеджер драйверов; </p>
      </li>
      <li>
        <p class="Textbody">Окно входа в систему; </p>
      </li>
      <li>
        <p class="Textbody">Пользователи и группы. </p>
      </li>
    </ul>
    <p class="Textbody">Первые два модуля прямого отношения к Cinnamon не имеют, а принадлежат к кругу фирменных утилит Mint, которые будут предметом соответствующего очерка. Так что в очерке этом будут рассмотрены два последних.</p>
    <h3 id="toc44"><a id="RefHeading15301713816058"></a><a id="bkmRefHeading15301713816058"></a><a id="toc43"></a><a id="bkmtoc43"></a><a id="RefHeading3861136957987"></a><a id="bkmRefHeading3861136957987"></a><a id="bkmRefHeading3861136957987"></a><a id="bkmbkmRefHeading3861136957987"></a>Окно входа в систему</h3>
    <p class="Textbody">Строго говоря этот модуль тоже не часть среды Cinnamon, а является инструментом настройки дисплейного менеджера MDM (изначально аббревиатура Mint Display Manager, ныне превратившаяся в рекурсивное MDM Display Manager), обеспечивающего во всех редакциях дистрибутива Mint авторизацию в системе. Однако он очень тесно интегрирован в Системные настройки, в том числе и в отношении внешнего вида, и потому его целесообразно рассмотреть здесь.</p>
    <p class="Textbody">Поскольку авторизация в системе выходит за пределы компетенции отдельного пользователя, при запуске этого модуля (из CLI его можно запустить командой sudo mdmsetup) для начала запрашивается пароль, после ввода которого появляется такая панель:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_068.png">
        <img alt="Изображение144" class="frameGraphics" id="144graphic" src="http://alv.me/wp-content/img/im_cin_img/param_068-572x386.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:387.8463px" />
      </a>
      <a id="a144graphic"></a>
      <a id="bkm144graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/param_068.png"> </a>
    </p>
    <p class="Textbody">С пунктом Тема всё понятно — это выбор заставки, на фоне которой выводится окно авторизации, а также, при желании, определение собственного приветствия:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_069.png">
        <img alt="Изображение145" class="frameGraphics" id="145graphic" src="http://alv.me/wp-content/img/im_cin_img/param_069-572x481.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:482.82584px" />
      </a>
      <a id="a145graphic"></a>
      <a id="bkm145graphic"></a>
    </p>
    <p class="Textbody">Далее можно задать автоматический вход в систему для определённого пользователя, и установить задержку перед входом, позволяющую выбрать сеанс:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_070.png">
        <img alt="Изображение146" class="frameGraphics" id="146graphic" src="http://alv.me/wp-content/img/im_cin_img/param_070-572x386.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:387.8463px" />
      </a>
      <a id="a146graphic"></a>
      <a id="bkm146graphic"></a>
    </p>
    <p class="Textbody">Сеанс по умолчанию задаётся в пункте Настройки:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_071.png">
        <img alt="Изображение147" class="frameGraphics" id="147graphic" src="http://alv.me/wp-content/img/im_cin_img/param_071-572x386.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:387.8463px" />
      </a>
      <a id="a147graphic"></a>
      <a id="bkm147graphic"></a>
    </p>
    <p class="Textbody">Здесь же есть вожделенная для начинающих линуксоидов опция — разрешение авторизоваться в иксовом сеансе в качестве суперпользователя. Что, конечно, круто, но делать не рекомендуется, за исключением единичных ну очень специальных случаев.</p>
    <h3 id="toc45"><a id="RefHeading15321713816058"></a><a id="bkmRefHeading15321713816058"></a><a id="toc44"></a><a id="bkmtoc44"></a><a id="RefHeading3881136957987"></a><a id="bkmRefHeading3881136957987"></a><a id="bkmRefHeading3881136957987"></a><a id="bkmbkmRefHeading3881136957987"></a>Пользователи и группы</h3>
    <p class="Textbody">А вот модуль Пользователи и группы — родной для Cinnamon, из CLI его можно запустить командой cinnamon-settings-users. Очевидно, что и здесь потребуется пароль, ввод которого даст доступ к святая святых — списку пользователей и групп:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_072.png">
        <img alt="Изображение148" class="frameGraphics" id="148graphic" src="http://alv.me/wp-content/img/im_cin_img/param_072-572x406.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:407.84003px" />
      </a>
      <a id="a148graphic"></a>
      <a id="bkm148graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_073.png">
        <img alt="Изображение149" class="frameGraphics" id="149graphic" src="http://alv.me/wp-content/img/im_cin_img/param_073-572x406.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:407.84003px" />
      </a>
      <a id="a149graphic"></a>
      <a id="bkm149graphic"></a>
    </p>
    <p class="Textbody">От описания возможных тут действий в каждом аккаунте позволю себе воздержаться — они почти очевидны из скриншота и становятся более чем очевидными после пары щелчков мышью. А вот о том, как создаётся новый пользовательский аккаунт, скажу чуть подробнее.</p>
    <p class="Textbody">Собственно, для создания аккаунта достаточно заполнить простую форму, выбрав в ней тип учётной записи:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_074.png">
        <img alt="Изображение150" class="frameGraphics" id="150graphic" src="http://alv.me/wp-content/img/im_cin_img/param_074.png" style="border:1.0px solid #000080;padding:0;width:365.84946px;height:197.84943px" />
      </a>
      <a id="a150graphic"></a>
      <a id="bkm150graphic"></a>
    </p>
    <p class="Textbody">Тут возможно два варианта — Администратор и Стандартный. Второй выводится по умолчанию — и пусть таковым остаётся (почему — скажу чуть позже). Так что теперь достаточно нажать кнопку Добавить, чтобы новый пользователь появился в списке оных:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_075.png">
        <img alt="Изображение151" class="frameGraphics" id="151graphic" src="http://alv.me/wp-content/img/im_cin_img/param_075-572x382.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:383.84px" />
      </a>
      <a id="a151graphic"></a>
      <a id="bkm151graphic"></a>
    </p>
    <p class="Textbody">Обращаю внимание, что пароль в ходе создания нового аккаунта не запрашивается. Его можно установить здесь же, щёлкнув на поле Пароль:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_076.png">
        <img alt="Изображение152" class="frameGraphics" id="152graphic" src="http://alv.me/wp-content/img/im_cin_img/param_076.png" style="border:1.0px solid #000080;padding:0;width:414.83212px;height:253.82425px" />
      </a>
      <a id="a152graphic"></a>
      <a id="bkm152graphic"></a>
    </p>
    <p class="Textbody">Впрочем, я по ряду причин предпочитаю делать это из CLI командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo passwd username</span> </p>
    <p class="Textbody">Только после этого надо не забыть исключить пользователя из группы nopasswdlogin, членство в которой даёт возможность беспарольного входа в систему, что не есть правильно. Для этого достаточно щёлкнуть мышью на поле Группы и снять отметку с соответствующего боксика:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_077.png">
        <img alt="Изображение153" class="frameGraphics" id="153graphic" src="http://alv.me/wp-content/img/im_cin_img/param_077.png" style="border:1.0px solid #000080;padding:0;width:245.84944px;height:481.84317px" />
      </a>
      <a id="a153graphic"></a>
      <a id="bkm153graphic"></a>
    </p>
    <p class="Textbody">Здесь, во-первых, надо подчеркнуть, что беспарольный вход в систему — это совсем не то же самое, что автоматический вход, о котором говорилось выше: во-втором случае пароль пользователя существует, просто его не нужно вводить в окошке MDM (это, в соответствие с названием, делается автоматически, за кадром). А вот при авторизации в консоли этому самому «автоматическому» пользователю пароль вводить придётся. Как и при запуске программ, требующих прав администратора. И, чтобы ни говорили записные параноики, с точки зрения безопасности на локальной машине, находящейся в индивидуальном пользовании, автоматический вход ничем не отличается от парольного.</p>
    <p class="Textbody">Во-вторых, поясняю, в чём отличие административного типа учётной записи от стандартного: только пользователь с аккаунтом первого типа имеет возможность получить доступ к административным привилегиям с помощью команды sudo. Административный статус автоматически присваивается тому пользователю, чей аккаунт был создан при инсталляции системы. Так что для всех остальных аккаунтов достаточно статуса стандартного. Ибо зачем нам два генеральных секретаря? — резонно говорил незабвенный Леонид Ильич (правда, не в жизни, а в анекдоте)</p>
    <p class="Textbody">И в-третьих, может возникнуть вопрос, зачем на индивидуальной машине несколько аккаунтов? Причины могут быть разные, скажу только за себя. Мой первый и главный аккаунт, alv, предназначен для меня, любимого, когда он занят выполнением своей непосредственной работы. Например, сочинением этой книжки.</p>
    <p class="Textbody">Никаких потенциально опасных действий я под основным аккаунтом не делаю (или стараюсь не делать). Для всякого рода экспериментов предназначен аккаунт exp, пользователь которого не имеет доступа к правам администратора и потому напортачить на системном уровне не может — в его власти только развалить собственные пользовательские настройки. Поскольку такое рано или поздно случается — на помощь приходит аккаунт def, в котором сохраняются все настройки по умолчанию. И из которого настройки несчастного exp можно восстановить до исходного состояния простым копированием конфигов.</p>
    <p class="Textbody">На этом разговор о настройках Mint совместно с Cinnamon можно считать законченным. Следующий очерк имеет отношение только к Mint, так как посвящён «фирменному» иснтсрументарию этого дистрибутива — и не только имеющему отношение к настройкам.</p>
    <h2 id="toc46"><a id="RefHeading15341713816058"></a><a id="bkmRefHeading15341713816058"></a><a id="toc45"></a><a id="bkmtoc45"></a><a id="RefHeading12561136957987"></a><a id="bkmRefHeading12561136957987"></a><a id="bkmRefHeading12561136957987"></a><a id="bkmbkmRefHeading12561136957987"></a>Mint: фирменный инструментарий</h2>
    <p class="Textbody">Редкий дистрибутив из числа тех, что носят это гордое имя по праву, не обзаводится более или менее полным набором системного инструментария, специфичного только для него (в дальнейшем я буду называть такие инструменты фирменными). Не исключение в этом отношении и Mint — он имеет набор фирменных инструментов для решения весьма широкого круга задач, от управления программным обеспечением до настройки WiFi и блокировки доменов. Они и будут предметом данного очерка.</p>
    <h3 id="toc47"><a id="RefHeading15361713816058"></a><a id="bkmRefHeading15361713816058"></a><a id="toc46"></a><a id="bkmtoc46"></a><a id="RefHeading3901136957987"></a><a id="bkmRefHeading3901136957987"></a><a id="bkmRefHeading3901136957987"></a><a id="bkmbkmRefHeading3901136957987"></a>Вступление</h3>
    <p class="Textbody">Как уже было сказано, фирменный инструментарий дистрибутива Mint охватывает весьма широкий круг задач и потому представлен большим количеством отдельных утилит, которые обнаруживаются в любой из его редакций, располагаясь в каталоге /usr/bin. Полный их список включает более 20 исполняемых файлов вида mint*. Большинству из них соответствует пункт в разделе Администрирование главного меню Cinnamon:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_001.png">
        <img alt="Изображение154" class="frameGraphics" id="154graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_001-572x484.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:485.84946px" />
      </a>
      <a id="a154graphic"></a>
      <a id="bkm154graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_001.png"> </a>
    </p>
    <p class="Textbody">Фирменные инструменты Mint будут рассмотрены на примере среды Cinnamon. Однако десктопная специфика касается только способа их запуска из главного меню. Сами же инструменты идентичны во всех редакциях дистрибутива Mint.</p>
    <p class="Textbody">Рассмотрение фирменного инструментария целесообразно начать с менеджера программ, как наиболее востребованного его компонента.</p>
    <h3 id="toc48"><a id="RefHeading15381713816058"></a><a id="bkmRefHeading15381713816058"></a><a id="toc47"></a><a id="bkmtoc47"></a><a id="RefHeading3921136957987"></a><a id="bkmRefHeading3921136957987"></a><a id="bkmRefHeading3921136957987"></a><a id="bkmbkmRefHeading3921136957987"></a>Менеджер программ mintinstall</h3>
    <p class="Textbody">Менеджер программ mintinstall занимает центральное положение в наборе фирменного инструментария дистрибутива Mint. Он принадлежит к классу самых «высокоуровневых» инструментов для управления пакетами, которые можно назвать интегрированными центрами приложений, о чём подробнее будет сказано в одном из последующих очерков.</p>
    <p class="Textbody">Как только что было сказано, mintinstall можно запустить одноимённой командой из терминального окна или строки минитерминала. А можно обратиться к главному меню Cinnamon, где он обнаруживается в разделе Администрирование. Однако залезать в него не обязательно — пиктограмма запуска Менеджера приложений вынесена в левую колонку быстрого запуска второй сверху:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_002.png">
        <img alt="Изображение155" class="frameGraphics" id="155graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_002.png" style="border:1.0px solid #000080;padding:0;width:98.82583px;height:513.8558px" />
      </a>
      <a id="a155graphic"></a>
      <a id="bkm155graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_002.png"> </a>
    </p>
    <p class="Textbody">Будучи запущенным тем или иным способом, mintinstall для начала запрашивает пароль пользователя, после чего предстаёт перед его взором в следующем виде:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_003.png">
        <img alt="Изображение156" class="frameGraphics" id="156graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_003-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a156graphic"></a>
      <a id="bkm156graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_003.png"> </a>
    </p>
    <p class="Textbody">Первое, что обращает на себя внимание — минималистичный дизайн: никаких баннеров, новинок, рекомендаций. Только поле поискового запроса, пиктограммы категорий софта и строка состояния текущих действий (сразу после запуска, разумеется, пустая). И потому mintinstall не вызывает визуального отторжения.</p>
    <p class="Textbody">В обращении mintinstall столь же прост, как и внешне. А обращение с ним, разумеется, начинается с поиска нужного пакета. Сделать это можно, во-первых, просматривая категории, например Офис:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_004.png">
        <img alt="Изображение157" class="frameGraphics" id="157graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_004-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a157graphic"></a>
      <a id="bkm157graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_004.png"> </a>
    </p>
    <p class="Textbody">Однако это не самый простой путь. Во-первых, просматривать списки категорий (а они включают в себя от пары сотен до 4-5 тысяч позиций) — не самое весёлое занятие. Во-вторых, оно осложняется ещё и тем, что пакеты в этих списках отсортированы не по алфавиту, а по количеству полученных отзывов. В-третьих, критерии отнесения пакета к той или иной категории не всегда понятны. Так, категория Офис включает в себя не только собственно офисные пакеты, но и, скажем, текстовые редакторы, в том числе и такие, которые обычно относятся к классу системных приложений, например, vim и nano, и даже к инструментам программирования, вроде текстового редактора Geany, в некоторых кругах именуемого интегрированной средой разработки (IDE).</p>
    <p class="Textbody">Впрочем, Geany мы не увидим ни в категории Офис , ни в категории Программирование. Ибо, и это в четвёртых, есть ещё и категория Избранное, куда попадают пакеты с наибольшим количеством отзывов в своих «законных» категориях. Именно к этой категории и удостоился чести быть причисленным Geany, имеющий на момент сочинения этих строк 473 отзыва:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_005.png">
        <img alt="Изображение158" class="frameGraphics" id="158graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_005-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a158graphic"></a>
      <a id="bkm158graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_005.png"> </a>
    </p>
    <p class="Textbody">Поэтому, если известно имя пакета (или хотя бы фрагмент имени), проще воспользоваться полем поискового запроса. Таким образом пакет Geany находится мгновенно — а если после его нахождения нажать кнопку Показать все результаты, то будет выведен и список всех его плагинов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_006.png">
        <img alt="Изображение159" class="frameGraphics" id="159graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_006-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a159graphic"></a>
      <a id="bkm159graphic"></a>
    </p>
    <p class="Textbody">По умолчанию поиск в mintinstall простой, но его легко сделать инкрементным (как — скажу чуть позже). И тогда с каждым набранным символом список соответствий сокращается. Например, при поиске пакета Shutter, предназначенного для изготовления скриншотов (иллюстрации ко всем заметкам сделаны именно им), это выглядит так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_007.png">
        <img alt="Изображение160" class="frameGraphics" id="160graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_007-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a160graphic"></a>
      <a id="bkm160graphic"></a>
    </p>
    <p class="Textbody">Нужно только учитывать, что порядок вывода пакетов — не по соответствию имени введённым в поле поиска символам, а опять же по количеству отзывов.</p>
    <p class="Textbody">Впрочем, по умолчанию поиск осуществляется по соответствию не только имени пакета, но также и кратким описаниям, которые могут быть даже на русском языке. Это можно видеть на примере поиска пакета aisleriot, представляющего собой коллекцию пасьянсов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_008.png">
        <img alt="Изображение161" class="frameGraphics" id="161graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_008-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a161graphic"></a>
      <a id="bkm161graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_008.png"> </a>
    </p>
    <p class="Textbody">Следует помнить, что поиск — регистро-зависимый. Это можно продемонстрировать на примере поиска пакетов выпадающих терминалов. Если в поле поиска ввести слово Выпадающий, мы увидим пакет выпадающего терминала Guake:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_009.png">
        <img alt="Изображение162" class="frameGraphics" id="162graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_009-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a162graphic"></a>
      <a id="bkm162graphic"></a>
    </p>
    <p class="Textbody">А по ключевому слову выпадающий обнаружится совсем другой выпадающий терминал, Tilda:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_010.png">
        <img alt="Изображение163" class="frameGraphics" id="163graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_010-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a163graphic"></a>
      <a id="bkm163graphic"></a>
    </p>
    <p class="Textbody">Если дважды кликнуть на строке с именем найденного пакета, появится страница с его описанием. Нередко оно будет на русском языке, и может содержать картинки:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_011.png">
        <img alt="Изображение164" class="frameGraphics" id="164graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_011-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a164graphic"></a>
      <a id="bkm164graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_011.png"> </a>
    </p>
    <p class="Textbody">Картинки кликабельны, так что их можно вывести «крупным планом»:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_012.png">
        <img alt="Изображение165" class="frameGraphics" id="165graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_012-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a165graphic"></a>
      <a id="bkm165graphic"></a>
    </p>
    <p class="Textbody">Здесь же можно прочитать и отзывы о пакете, если таковые имеются:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_013.png">
        <img alt="Изображение166" class="frameGraphics" id="166graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_013-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a166graphic"></a>
      <a id="bkm166graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_013.png"> </a>
    </p>
    <p class="Textbody">А можно также и оставить свой отзыв. Правда, для этого надо предварительно зарегистрироваться в сообществе пользователей (как — расскажу позже).</p>
    <p class="Textbody">Определившись, путём чтения описания и, возможно, отзывов (хотя они очень редко несут какую-либо информацию кроме эмоций), с нужностью найденного пакета, его остаётся только установить. Для чего требуется нажать соответствующую экранную кнопку — и процесс начнётся без единого вопроса.</p>
    <p class="Textbody">Столь же молчаливо будут установлены и все необходимые зависимости, поэтому с их списком лучше ознакомиться заранее. Например, для игры blockout2 он выглядит так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_014.png">
        <img alt="Изображение167" class="frameGraphics" id="167graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_014-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a167graphic"></a>
      <a id="bkm167graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_014.png"> </a>
    </p>
    <p class="Textbody">После установки пакета на его странице появляется кнопка Удалить очевидного назначения, которое также претворяется в жизнь без всяких вопросов. Нужно только учитывать, что пакеты, установленные как зависимости удаляемого, удалены не будут, их придётся вычищать или по списку по списку из раздела Подробности, или другими средствами. Первый вариант — рискованный, так как при этом можно затронуть зависимости других пакетов. Второй же лежит вне темы данного очерка — о нём будет говориться в своё время. Так что для удаления пакетов Менеджером программ лучше просто не пользоваться, за исключением очень простых или хорошо известных применителю случаев.</p>
    <p class="Textbody">Кроме строки поиска, mintinstall имеет ещё и меню. Где в пункте Вид определяется, выводить ли Доступные приложения, Установленные приложения, или, как по умолчанию, те и другие:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_015.png">
        <img alt="Изображение168" class="frameGraphics" id="168graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_015.png" style="border:1.0px solid #000080;padding:0;width:252.84157px;height:63.8274px" />
      </a>
      <a id="a168graphic"></a>
      <a id="bkm168graphic"></a>
    </p>
    <p class="Textbody">В пункте Правка — три подпункта: Настройки поиска, Доступ к аккаунту в сообществе и Источники приложений:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_016.png">
        <img alt="Изображение169" class="frameGraphics" id="169graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_016.png" style="border:1.0px solid #000080;padding:0;width:226.83846px;height:93.83685px" />
      </a>
      <a id="a169graphic"></a>
      <a id="bkm169graphic"></a>
    </p>
    <p class="Textbody">В первом из них, во-первых, определяется, искать ли только в кратких описаниях пакетов (отмечено по умолчанию) или также в подробных, а во-вторых — включить инкрементный поиск (Поиск при вводе):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_017.png">
        <img alt="Изображение170" class="frameGraphics" id="170graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_017-572x70.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:71.84px" />
      </a>
      <a id="a170graphic"></a>
      <a id="bkm170graphic"></a>
    </p>
    <p class="Textbody">Про аккаунт в сообществе Linuxmint я расскажу в маленькой интермедии. А пункт Источники приложений вызывает отдельную утилиту software-sources, которая будет рассмотрена последующем за ней очерке.</p>
    <h3 id="toc49"><a id="RefHeading15401713816058"></a><a id="bkmRefHeading15401713816058"></a><a id="toc48"></a><a id="bkmtoc48"></a><a id="RefHeading3941136957987"></a><a id="bkmRefHeading3941136957987"></a><a id="bkmRefHeading3941136957987"></a><a id="bkmbkmRefHeading3941136957987"></a>Интермедия об аккаунте в сообществе</h3>
    <p class="Textbody">Как мы только что видели, для того, чтобы оставить отзыв о пакете в Менеджере программ, необходимо открыть аккаунт в сообществе Linux Mint. Для этого надо пройти к пункту меню Правка -&gt; Ваш аккаунт, который вызовет панель с предложением к авторизации:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_018.png">
        <img alt="Изображение171" class="frameGraphics" id="171graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_018.png" style="border:1.0px solid #000080;padding:0;width:372.8416px;height:251.85892px" />
      </a>
      <a id="a171graphic"></a>
      <a id="bkm171graphic"></a>
    </p>
    <p class="Textbody">Нетрудно догадаться, что если аккаунта ещё нет — следует пойти по указанному там <a href="http://community.linuxmint.com/" target="_blank">адресу</a>. После чего приглашение к авторизации откроется уже в браузере:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_019.png">
        <img alt="Изображение172" class="frameGraphics" id="172graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_019-572x313.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:314.8258px" />
      </a>
      <a id="a172graphic"></a>
      <a id="bkm172graphic"></a>
    </p>
    <p class="Textbody">Кнопка Register находится на видном месте. Нажав её, можно видеть регистрационную форму:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_020.png">
        <img alt="Изображение173" class="frameGraphics" id="173graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_020-572x313.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:314.8258px" />
      </a>
      <a id="a173graphic"></a>
      <a id="bkm173graphic"></a>
    </p>
    <p class="Textbody">Заполнение полей — очевидно, кроме последнего, Registration Code. Чтобы получить его, нужно открыть тот самый экран приветствия, который был виден при первом запуске свежеинсталлированного Mint'а. И показ которого, скорее всего, был тогда же и отключён. Однако его можно вызвать в любой момент — это такой же компонент фирменного инструментария, как и все остальные из рассматриваемых в этом очерке. Делается это либо из терминала вводом команды</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mintwelcome</span> </p>
    <p class="Textbody">либо через главное меню Параметры -&gt; Экран приветствия:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_021.png">
        <img alt="Изображение174" class="frameGraphics" id="174graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_021-572x481.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:482.82584px" />
      </a>
      <a id="a174graphic"></a>
      <a id="bkm174graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_021.png"> </a>
    </p>
    <p class="Textbody">Теперь остаётся только найти пиктограмму с подписью Чат-комната, в эту самую комнату войти и в свободной (но желательно вежливой) форме на английском языке запросить код для регистрации. Практически мгновенно от пользователя mintbotd придёт ответ, гласящий, что код выслан в личном сообщении. Откуда он и вставляется в регистрационную форму, после чего регистрация мгновенно совершается.</p>
    <p class="Textbody">Теперь можно вернуться к форме, вызванной из Менеджера программ, авторизоваться там и оставлять отзывы в своё удовольствие. Причём устанавливать программу, на которую даётся отзыв, совсем не обязательно. А вот оценку ей надо дать непременно.</p>
    <p class="Textbody">Разумеется, аккаунт в сообществе нужен не только для того, чтобы оставлять отзывы на пакетах. Будучи членом сообщества, можно получать доступ к тому, что создаёт его мозг (Клемент Лефевр) на ранних стадиях разработки. И даже поучаствовать в тестировании.</p>
    <h3 id="toc50"><a id="RefHeading15421713816058"></a><a id="bkmRefHeading15421713816058"></a><a id="toc49"></a><a id="bkmtoc49"></a><a id="RefHeading3961136957987"></a><a id="bkmRefHeading3961136957987"></a><a id="bkmRefHeading3961136957987"></a><a id="bkmbkmRefHeading3961136957987"></a>Менеджер репозиториев software-sources</h3>
    <p class="Textbody">А теперь вернёмся в Менеджер программ с другой целью — проследовать в пункт его меню Правка -&gt; Источники приложений. Через него вызывается самостоятельная утилита фирменного набора, mintsources, она же software-sources (первое имя — символическая ссылка на второе). В разделе Администрирование главного меню ей соответствует пункт Источники приложений (это и есть официальное название программы, менеджер репозиториев — моя отсебятина, придуманная единообразия ради). Наконец, плюс к упомянутой возможности вызова software-sources из Менеджера программ, пиктограмма запуска её есть и в секции Администрирование Системных настроек Cinnamon.</p>
    <p class="Textbody">Вне зависимости от способа запуска, после ввода пароля открывается окно software-sources с пятью страницами, переключение между которыми осуществляется экранными кнопками. На первой странице, именуемой Официальные репозитории, выбираются зеркала двух основных репозиториев — собственного и репозитория Ubuntu (вся базовая часть Mint берётся из последнего). Здесь же отмечается, следует ли использовать бэкпорты, нестабильные пакеты, а также исходники:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_022.png">
        <img alt="Изображение175" class="frameGraphics" id="175graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_022-572x241.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:242.82585px" />
      </a>
      <a id="a175graphic"></a>
      <a id="bkm175graphic"></a>
    </p>
    <p class="Textbody">В списке зеркал обоих из основных репозиториев указываются их URL'ы, флажок страны размещёния, а также реальная скорость соединения — последняя колонка появляется по прошествии некоторого времени, необходимого для получения соответствующих данных. Именно по скорости соединения список и сортируется, так что в обоих случаях следует просто выбрать верхнюю строку (в списке зеркал нет ни одного российского, так что выбор по «географическому» принципу смысла не имеет):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_023_rebecca.png">
        <img alt="Изображение176" class="frameGraphics" id="176graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_023_rebecca-572x289.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:290.8258px" />
      </a>
      <a id="a176graphic"></a>
      <a id="bkm176graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_023_trusty.png">
        <img alt="Изображение177" class="frameGraphics" id="177graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_023_trusty-572x289.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:290.8258px" />
      </a>
      <a id="a177graphic"></a>
      <a id="bkm177graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_023_trusty.png"> </a>
    </p>
    <p class="Textbody">Использование «обратно портированных» (backport) и нестабильных (romeo) пакетов разработчиками настоятельно не рекомендуется, и по умолчанию эти ветви репозиториев отключены. Попытка активировать любую из них вызывает предупреждение, для бэкпортов такое:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_024.png">
        <img alt="Изображение178" class="frameGraphics" id="178graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_024.png" style="border:1.0px solid #000080;padding:0;width:545.83057px;height:316.82898px" />
      </a>
      <a id="a178graphic"></a>
      <a id="bkm178graphic"></a>
    </p>
    <p class="Textbody">А для нестабильных пакетов — такое:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_025.png">
        <img alt="Изображение179" class="frameGraphics" id="179graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_025.png" style="border:1.0px solid #000080;padding:0;width:498.85104px;height:247.85262px" />
      </a>
      <a id="a179graphic"></a>
      <a id="bkm179graphic"></a>
    </p>
    <p class="Textbody">Не вижу оснований не прислушаться к этим предупреждениям — в любом случае, и к бэкпортам, и к нестабильным пакетам следует подходить индивидуально, а не устанавливать их все гуртом.</p>
    <p class="Textbody">Отключено также использование ветки репозитория, содержащей исходные тексты пакетов. Активация её не несёт никакой опасности, и потому не сопровождается предупреждением. Просто доступ к исходникам нужен далеко не всем применителям, а лишь тем, кто пересобирает пакеты с каким-либо своими специфическими опциями.</p>
    <p class="Textbody">Вторая страница — PPA-репозитории, то есть дополнительные PPA-репозитории из централизованного хранилища всех пакетов, собранных независимыми разработчиками и майнтайнерами:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_026.png">
        <img alt="Изображение180" class="frameGraphics" id="180graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_026-572x241.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:242.82585px" />
      </a>
      <a id="a180graphic"></a>
      <a id="bkm180graphic"></a>
    </p>
    <p class="Textbody">PPA-репозитории предназначены для Ubuntu и её прямых родственников (вроде Kubuntu и Xubuntu). Но, поскольку Mint с Ubuntu полностью обратно совместим, пакеты эти обычно (если не вообще всегда) можно использовать и в нём. По крайней мере, я не только не сталкивался с какими-либо проблемами, но и не слышал о таковых. Для доступа к PPA-репозиториям фирма Canonical разработала специальную систему с web-интерфейсом — <a href="https://launchpad.net/" target="_blank">Launchpad</a>.</p>
    <p class="Textbody">Для подключения дополнительного репозитория его сначала нужно отыскать на Launchpad'е и определить его ppa-имя. Например, для <a href="https://launchpad.net/%7Ezfs-native/+archive/ubuntu/stable" target="_blank">PPA-репозитория с пакетами поддержки файловой системы ZFS</a> оно будет таким: ppa:zfs-native/stable. Затем кнопкой Добавить новый... вызывается панель, в соответствующее поле которой это имя вписывается:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_027.png">
        <img alt="Изображение181" class="frameGraphics" id="181graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_027.png" style="border:1.0px solid #000080;padding:0;width:386.82584px;height:205.82425px" />
      </a>
      <a id="a181graphic"></a>
      <a id="bkm181graphic"></a>
    </p>
    <p class="Textbody">Нажатие кнопки OK вызывает панель с информацией о репозитории:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_028.png">
        <img alt="Изображение182" class="frameGraphics" id="182graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_028-352x572.png" style="border:1.0px solid #000080;padding:0;width:353.83057px;height:573.83685px" />
      </a>
      <a id="a182graphic"></a>
      <a id="bkm182graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_028.png"> </a>
    </p>
    <p class="Textbody">И после подтверждения своих намерений новый репозиторий появляется в общем списке.</p>
    <p class="Textbody">В большинстве случаев при подключении PPA-репозиториев автоматически подключаются и их ветки с исходниками (в русском переводе почему-то называемые Источниками) .</p>
    <p class="Textbody">На странице Дополнительные репозитории аналогичную процедуру можно выполнить для репозиториев произвольных, в том числе и локальных:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_029.png">
        <img alt="Изображение183" class="frameGraphics" id="183graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_029-572x241.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:242.82585px" />
      </a>
      <a id="a183graphic"></a>
      <a id="bkm183graphic"></a>
    </p>
    <p class="Textbody">Страница Проверка подлинности ключей предназначена для хранения ключей к подключённым репозиториям — в большинстве случаев они вносятся в список автоматически:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_030.png">
        <img alt="Изображение184" class="frameGraphics" id="184graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_030-572x241.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:242.82585px" />
      </a>
      <a id="a184graphic"></a>
      <a id="bkm184graphic"></a>
    </p>
    <p class="Textbody">Наконец, на странице Maintenance можно произвести исправление проблем с локальными кешами пакетов, буде таковые возникнут (у меня пока не возникало) и их очистку от продуктов жизнедеятельности при установке пакетов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_031.png">
        <img alt="Изображение185" class="frameGraphics" id="185graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_031-572x241.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:242.82585px" />
      </a>
      <a id="a185graphic"></a>
      <a id="bkm185graphic"></a>
    </p>
    <p class="Textbody">В правом верхнем углу окна программы можно видеть кнопку Обновить кэш. К ней следует обращаться после любых действий с репозиториями — это приведёт локальный кэш пакетов в актуальное состояние.</p>
    <p class="Textbody">Впрочем, не будет большого вреда нажать эту кнопку и в том случае, если никаких изменений в составе репозиториев не выполнялась — на всякий пожарный случай.</p>
    <h3 id="toc51"><a id="RefHeading15441713816058"></a><a id="bkmRefHeading15441713816058"></a><a id="toc50"></a><a id="bkmtoc50"></a><a id="RefHeading3981136957987"></a><a id="bkmRefHeading3981136957987"></a><a id="bkmRefHeading3981136957987"></a><a id="bkmbkmRefHeading3981136957987"></a>Менеджер обновлений mintupdate</h3>
    <p class="Textbody">После рассмотрения Менеджера программ и Менеджера репозиториев резонно перейти к средствам, обеспечивающим обновление системы. Таковым в фирменном наборе инструментов Mint является Менеджер обновлений — mintupdate. По умолчанию он включается в автозапуск, и потому применителю не нужно беспокоиться о его запуске: пиктограмма его сидит в трее, изменяя свой вид в зависимости от доступности обновлений: в виде буковки i на голубом фоне в случае их наличия, и в виде зелёной «галочки» — если система обновлений не требует. Соответствующие подсказки всплывают и при наведении курсора мыши на пиктограмму:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_032.png">
        <img alt="Изображение186" class="frameGraphics" id="186graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_032.png" style="border:1.0px solid #000080;padding:0;width:295.85257px;height:30.832123px" />
      </a>
      <a id="a186graphic"></a>
      <a id="bkm186graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_033.png">
        <img alt="Изображение187" class="frameGraphics" id="187graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_033.png" style="border:1.0px solid #000080;padding:0;width:306.85104px;height:30.832123px" />
      </a>
      <a id="a187graphic"></a>
      <a id="bkm187graphic"></a>
    </p>
    <p class="Textbody">При доступности обновлений получить визуальное представление о них можно, щёлкнув мышью на пиктограмме. После этого будет выведен список пакетов, которые могут быть обновлены в данный момент времени:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_034.png">
        <img alt="Изображение188" class="frameGraphics" id="188graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_034-572x390.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:391.8526px" />
      </a>
      <a id="a188graphic"></a>
      <a id="bkm188graphic"></a>
    </p>
    <p class="Textbody">Строго говоря, начиная с Mint 17.1, вывод не совсем попакетный: в одной строке списка может быть сгруппировано несколько родственных пакетов, которые друг без друга всё равно не устанавливаются, например — cinnamon и cinnamon-common. Эту группировку не следует путать ни с зависимостями, ни с метапакетами — она делается исключительно для компактности представления и лёгкости восприятия.</p>
    <p class="Textbody">Далее, некоторых пояснений требуют первые две колонки. Первая — тип обновления. Их два — стандартно обновляемые пакеты по выходе их новой сборки или версии (отмечены серой стрелкой) и обновления безопасности, ликвидирующие выявленные «дыры» в них (отмечены красным восклицательным знаком).</p>
    <p class="Textbody">Во второй колонке указывается уровень безопасности обновления пакетов. Здесь под безопасностью понимается не вероятность использования их злодеями, а то, как обновление пакета может повлиять на общую стабильность системы. Уровней безопасности в этом смысле пять:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">сертифицированные пакеты — обычно те, что непосредственно поддерживаются майнтайнерами Mint; </p>
      </li>
      <li>
        <p class="Textbody">рекомендуемые пакеты — проверены и одобрены разработчиками этого дистрибутива; </p>
      </li>
      <li>
        <p class="Textbody">безопасные пакеты — не проверялись разработчиками, но нарушение стабильности системы при их обновлении очень маловероятно; </p>
      </li>
      <li>
        <p class="Textbody">небезопасные пакеты потенциально могут повлиять на стабильность системы; </p>
      </li>
      <li>
        <p class="Textbody">опасные пакеты при некоторых условиях могут привести к нестабильности системы. </p>
      </li>
    </ol>
    <p class="Textbody">Забегая вперёд, приведу скриншот окна настройки параметров Менеджера обновлений, наглядно иллюстрирующий сказанное:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_035.png">
        <img alt="Изображение189" class="frameGraphics" id="189graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_035-572x325.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:326.84476px" />
      </a>
      <a id="a189graphic"></a>
      <a id="bkm189graphic"></a>
    </p>
    <p class="Textbody">По умолчанию для обновления (третья колонка) отмечаются пакеты уровней 1-3. Для пакетов уровней 4-5 это нужно сделать принудительно. Если оно, конечно, нужно. Разработчики Mint считают, что решение об обновлении таких ключевых пакетов, как ядро, главная системная библиотека glibc и так далее, применитель должен принимать осознанно. Характерно, что режима автоматического обновления в Mint не предусмотрено как класса.</p>
    <p class="Textbody">Само по себе обновление выполняется нажатием экранной кнопки Установить обновления и начинается после ввода пользовательского пароля. Развернув пункт Show individual files, можно наблюдать за ходом процесса в деталях (если, конечно, больше заняться нечем):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_036.png">
        <img alt="Изображение190" class="frameGraphics" id="190graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_036-572x515.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:516.8416px" />
      </a>
      <a id="a190graphic"></a>
      <a id="bkm190graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_036.png"> </a>
    </p>
    <p class="Textbody">По завершении процесса окно обновлений предлагается закрыть:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_037.png">
        <img alt="Изображение191" class="frameGraphics" id="191graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_037-572x431.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:432.82272px" />
      </a>
      <a id="a191graphic"></a>
      <a id="bkm191graphic"></a>
    </p>
    <p class="Textbody">Как я уже говорил, Mint не предлагает автоматического обновления пакетов — Менеджер обновлений нужно запустить руками, или описанным выше способом, или из контекстного меню по щелчку правой кнопкой мыши на его пиктограмме в системной трее:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_038.png">
        <img alt="Изображение192" class="frameGraphics" id="192graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_038.png" style="border:1.0px solid #000080;padding:0;width:155.85889px;height:127.85261px" />
      </a>
      <a id="a192graphic"></a>
      <a id="bkm192graphic"></a>
    </p>
    <p class="Textbody">Из него же можно получить доступ к настройкам mintupdate (пункт Параметры), о которых я скажу чуть позже, и к журналу обновлений (пункт Информация):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_039.png">
        <img alt="Изображение193" class="frameGraphics" id="193graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_039-572x353.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:354.851px" />
      </a>
      <a id="a193graphic"></a>
      <a id="bkm193graphic"></a>
    </p>
    <p class="Textbody">Меню менеджера обновлений не дублирует кнопки на его панели инструментов. Через пункт меню Файл можно выйти из программы. Пункт Правка содержит подпункты Параметры — это настройка политики обновлений, до чего я скоро доберусь, и Источники приложений — это вызов того самого software-sources, о котором шла речь в предыдущем разделе. А в пункте Вид можно, во-первых, включить или отключить вывод каких-то колонок:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_040.png">
        <img alt="Изображение194" class="frameGraphics" id="194graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_040.png" style="border:1.0px solid #000080;padding:0;width:383.84px;height:189.83685px" />
      </a>
      <a id="a194graphic"></a>
      <a id="bkm194graphic"></a>
    </p>
    <p class="Textbody">Во-вторых, можно просмотреть историю обновлений:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_041.png">
        <img alt="Изображение195" class="frameGraphics" id="195graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_041-572x286.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:287.84px" />
      </a>
      <a id="a195graphic"></a>
      <a id="bkm195graphic"></a>
    </p>
    <p class="Textbody">И в-третьих, можно получить информацию об установленном ядре и доступных для обновления версиях:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_042.png">
        <img alt="Изображение196" class="frameGraphics" id="196graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_042-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a196graphic"></a>
      <a id="bkm196graphic"></a>
    </p>
    <p class="Textbody">Что такое Информация — я только что говорил. Так что можно вернуться в пункт Правка, где обратиться к подпункту Параметры. Скриншот первой вкладки вызываемого при этом окна я уже приводил, когда говорил об уровнях безопасности. Осталось только добавить, что здесь для пакетов 4-го и 5-го уровней можно включить отметку к обновлению «на постоянной основе». А можно сделать это для всех пакетов, обновляемых по типу обновления безопасности (другой, той, которая от злодеев).</p>
    <p class="Textbody">Во вкладке Автообновление задаётся время, через которое обновляется список пакетов. Подчеркну — именно их список сами по себе пакеты обновляться не будут, если не заказать это явным образом, как было сказано выше:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_043.png">
        <img alt="Изображение197" class="frameGraphics" id="197graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_043-572x325.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:326.84476px" />
      </a>
      <a id="a197graphic"></a>
      <a id="bkm197graphic"></a>
    </p>
    <p class="Textbody">Со вкладками Метод обновления и Игнорируемые пакеты всё понятно без комментариев:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_044.png">
        <img alt="Изображение198" class="frameGraphics" id="198graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_044-572x325.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:326.84476px" />
      </a>
      <a id="a198graphic"></a>
      <a id="bkm198graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_045.png">
        <img alt="Изображение199" class="frameGraphics" id="199graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_045-572x325.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:326.84476px" />
      </a>
      <a id="a199graphic"></a>
      <a id="bkm199graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_045.png"> </a>
    </p>
    <p class="Textbody">Вкладка Значки — это своего рода легенда (то есть условные обозначения): как выглядит пиктограмма Менеджера обновлений в зависимости от состояния системы и выполняемых им действий:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_047.png">
        <img alt="Изображение200" class="frameGraphics" id="200graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_047-572x335.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:336.8227px" />
      </a>
      <a id="a200graphic"></a>
      <a id="bkm200graphic"></a>
    </p>
    <p class="Textbody">Как и всякие условные обозначения, каждое из представлений пиктограммы можно изменить (только нужно ли?).</p>
    <p class="Textbody">На этом разговор о Менеджере обновлений считаю законченным. Следующим номером нашей программы будет рассказ о визуализаторах вывода.</p>
    <h3 id="toc52"><a id="RefHeading15461713816058"></a><a id="bkmRefHeading15461713816058"></a><a id="toc51"></a><a id="bkmtoc51"></a><a id="RefHeading4001136957987"></a><a id="bkmRefHeading4001136957987"></a><a id="bkmRefHeading4001136957987"></a><a id="bkmbkmRefHeading4001136957987"></a>Средства визуализация пакетов</h3>
    <p class="Textbody">В качестве завершающего штриха в рассказе о mint-инструментах для работы с файлами скажу пару слов об утилитах mint-search-apt и mint-show-apt. Они предназначены для визуального представления результатов поиска пакетов и вывода информации о них. В сущности, это графические фронт-энды для вывода команд CLI apt search и apt show, соответственно (о которых будет в другом очерке). Подчеркну — именно вывода: сами эти утилиты запускаются из командной строки терминала или из минитерминала.</p>
    <p class="Textbody">Команда mint-search-apt в качестве аргумента принимает имя пакета или его фрагмент: поиск введённой последовательности символов осуществляется только в именах пакетов. После чего результат поиска выводится во вновь открывающемся окне. Например, ответ на команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mint-search-apt geany</span> </p>
    <p class="Textbody">будет таким:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_047.png">
        <img alt="Изображение201" class="frameGraphics" id="201graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_047-572x335.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:336.8227px" />
      </a>
      <a id="a201graphic"></a>
      <a id="bkm201graphic"></a>
    </p>
    <p class="Textbody">Теоретически двойной клик на имени найденного пакета должен привести к его инсталляции. Однако в реальности последует лишь сообщение об ошибке:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_048.png">
        <img alt="Изображение202" class="frameGraphics" id="202graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_048.png" style="border:1.0px solid #000080;padding:0;width:326.84476px;height:134.84473px" />
      </a>
      <a id="a202graphic"></a>
      <a id="bkm202graphic"></a>
    </p>
    <p class="Textbody">Утилита apt-cache show в качестве аргумента требует имени пакета, после чего в отдельном окне выводит информацию о нём. Например, после команды</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mint-show-apt geany</span> </p>
    <p class="Textbody">оно будет выглядеть следующим образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_049.png">
        <img alt="Изображение203" class="frameGraphics" id="203graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_049-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a203graphic"></a>
      <a id="bkm203graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_049.png"> </a>
    </p>
    <p class="Textbody">Обе рассматриваемые утилиты входят в пакет mintinstall, который был разработан задолго до появления интегрированной команды apt, о которой будет говориться в очерке про пакетный менеджмент. И в те не столь далёкие времена их применение было оправдано. Ныне же, как мне кажется, использование их большого смысла не имеет. Хотя кому-то, может, и понравится вывод найденных пакетов и информации о них в графическом окне. Почему я и уделил им немного внимания.</p>
    <p class="Textbody">Этой заметкой завершается описание фирменных утилит Mint'а, так или иначе связанных с управлением пакетами. Следующий раздел — о резервном копировании.</p>
    <h3 id="toc53"><a id="RefHeading15481713816058"></a><a id="bkmRefHeading15481713816058"></a><a id="toc52"></a><a id="bkmtoc52"></a><a id="RefHeading4021136957987"></a><a id="bkmRefHeading4021136957987"></a><a id="bkmRefHeading4021136957987"></a><a id="bkmbkmRefHeading4021136957987"></a>Средство резервного копирования mintbackup</h3>
    <p class="Textbody">От средств работы с пакетами плавно переходим к средствам работы с файлами. А тут одно из наипервейших дел — резервное копирование. Для чего в составе фирменного инструментария Mint имеется утилита mintbackup. В разделе Администрирование главного меню она так и называется — Резервное копирование. И, после ввода пароля, предстаёт в таком вот виде:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_050.png">
        <img alt="Изображение204" class="frameGraphics" id="204graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_050-572x211.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:212.85419px" />
      </a>
      <a id="a204graphic"></a>
      <a id="bkm204graphic"></a>
    </p>
    <p class="Textbody">Для начала выполняется резервное копирование, для которого указываются исходный и целевой каталоги, а также дополнительные параметры — простое копирование, архив tar, tar.bz2 или tar.gz, условия перезаписи:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_051.png">
        <img alt="Изображение205" class="frameGraphics" id="205graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_051-572x286.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:287.84px" />
      </a>
      <a id="a205graphic"></a>
      <a id="bkm205graphic"></a>
    </p>
    <p class="Textbody">Далее определяются исключения из исходного каталога, не подлежащие архивированию (если, конечно, они нужны):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_052.png">
        <img alt="Изображение206" class="frameGraphics" id="206graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_052-572x286.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:287.84px" />
      </a>
      <a id="a206graphic"></a>
      <a id="bkm206graphic"></a>
    </p>
    <p class="Textbody">После этого выводится результирующая информация о будущем архиве:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_053.png">
        <img alt="Изображение207" class="frameGraphics" id="207graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_053-572x286.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:287.84px" />
      </a>
      <a id="a207graphic"></a>
      <a id="bkm207graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_053.png"> </a>
    </p>
    <p class="Textbody">А затем нажатие кнопки Применить вызывает начало процесса:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_054.png">
        <img alt="Изображение208" class="frameGraphics" id="208graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_054-572x286.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:287.84px" />
      </a>
      <a id="a208graphic"></a>
      <a id="bkm208graphic"></a>
    </p>
    <p class="Textbody">Завершение которого знаменуется таким сообщением:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_055.png">
        <img alt="Изображение209" class="frameGraphics" id="209graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_055-572x286.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:287.84px" />
      </a>
      <a id="a209graphic"></a>
      <a id="bkm209graphic"></a>
    </p>
    <p class="Textbody">Здесь следует нажать кнопку Закрыть — правда, это приведёт и к закрытию программы, но выбора всё равно нет.</p>
    <p class="Textbody">То есть всё просто до банальности — и ничего такого, чего нельзя было бы сделать с помощью утилиты tar и её опций. Но всё это представлено в наглядной форме, избавляющей от необходимости ломать голову над последними. Иными словами, в этой своей части утилита mintbackup заслуживает рекомендации к применению.</p>
    <p class="Textbody">Не менее проста и полезна утилита mintbackup во второй своей части, сохраняющей список установленных пакетов. Здесь всего-то и требуется, что указать целевой каталог:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_056.png">
        <img alt="Изображение210" class="frameGraphics" id="210graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_056-572x211.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:212.85419px" />
      </a>
      <a id="a210graphic"></a>
      <a id="bkm210graphic"></a>
    </p>
    <p class="Textbody">Затем, при желании, просмотреть список пакетов, установленных в системе:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_057.png">
        <img alt="Изображение211" class="frameGraphics" id="211graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_057-572x211.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:212.85419px" />
      </a>
      <a id="a211graphic"></a>
      <a id="bkm211graphic"></a>
    </p>
    <p class="Textbody">После чего нажать кнопку Применить — и дождаться появления сообщения об успешном завершении процесса:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_058.png">
        <img alt="Изображение212" class="frameGraphics" id="212graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_058-572x211.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:212.85419px" />
      </a>
      <a id="a212graphic"></a>
      <a id="bkm212graphic"></a>
    </p>
    <p class="Textbody">После чего в целевом каталоге обнаруживается файл вида software_selection_alv-desk@2014-12-14-1850-package.list. Каковой является самым обычным текстовым файлом, содержащим список установленных пакетов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">accountsservice install</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">acl     install</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">add-apt-key     install</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">adobe-flashplugin       install</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">aisleriot       install</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">Пакеты по этому списку могут быть установлены на любой другой машине. Так что и от mintbackup нет никакого вреда, окромя пользы.</p>
    <h3 id="toc54"><a id="RefHeading15501713816058"></a><a id="bkmRefHeading15501713816058"></a><a id="toc53"></a><a id="bkmtoc53"></a><a id="RefHeading4041136957987"></a><a id="bkmRefHeading4041136957987"></a><a id="bkmRefHeading4041136957987"></a><a id="bkmbkmRefHeading4041136957987"></a>Программа записи USB mintstick</h3>
    <p class="Textbody">Как известно, оптические приводы постепенно отмирают. И на смену им приходят USB flash и SD-карты. Единственная сфера, где до некоторого времени оптические накопители были не всегда заменимы — это установка системы на чистую машину. Однако ныне все современные дистрибутивы Linux'а или BSD-системы распространяются в виде так называемых гибридных образов, допускающих их запись на твердотельные носители. Что повлекло за собой появление большого числа программ, призванных выполнить эту процедуру.</p>
    <p class="Textbody">Имеется такая утилита и в составе фирменного инвентаря Mint'а. Это mintstick, которая в главном меню находится в разделе Стандартные под именем Создание загрузочного USB-носителя. И после запуска предстаёт перед глазами применителя в таком виде:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_059.png">
        <img alt="Изображение213" class="frameGraphics" id="213graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_059-572x171.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:172.82898px" />
      </a>
      <a id="a213graphic"></a>
      <a id="bkm213graphic"></a>
    </p>
    <p class="Textbody">Дальнейшие действия очевидны: надо выбрать записываемый образ и указать, куда он должен быть записан (воткнутая флешка или SD-карта предлагается по умолчанию):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_060.png">
        <img alt="Изображение214" class="frameGraphics" id="214graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_060-572x129.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:130.83842px" />
      </a>
      <a id="a214graphic"></a>
      <a id="bkm214graphic"></a>
    </p>
    <p class="Textbody">После этого потребуется ввести пароль и подождать завершения процесса, о чем будет сообщено дополнительно:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_061.png">
        <img alt="Изображение215" class="frameGraphics" id="215graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_061-572x144.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:145.84315px" />
      </a>
      <a id="a215graphic"></a>
      <a id="bkm215graphic"></a>
    </p>
    <p class="Textbody">В поле Подробности будут указаны имена файла образа и целевого устройства:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_062.png">
        <img alt="Изображение216" class="frameGraphics" id="216graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_062-572x129.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:130.83842px" />
      </a>
      <a id="a216graphic"></a>
      <a id="bkm216graphic"></a>
    </p>
    <p class="Textbody">Всё. Можно либо повторить процедуру для другого образа или устройства, либо закрыть программу.</p>
    <p class="Textbody">Хотелось бы ещё проще? Не получится — проще уже некуда.</p>
    <h3 id="toc55"><a id="RefHeading15521713816058"></a><a id="bkmRefHeading15521713816058"></a><a id="toc54"></a><a id="bkmtoc54"></a><a id="RefHeading4061136957987"></a><a id="bkmRefHeading4061136957987"></a><a id="bkmRefHeading4061136957987"></a><a id="bkmbkmRefHeading4061136957987"></a>Языковые настройки — mintlocale</h3>
    <p class="Textbody">В очерке о настройках Cinnamon упоминался модуль Языки в секции Параметры его Системных настроек. И, поскольку он, собственно, принадлежит к семейству фирменных утилит Mint (под именем mintlocale), было обещано рассказать о нём в соответствующее время. Время это наступило.</p>
    <p class="Textbody">Модуль Языки можно запустить как из панели Системных настроек, так и из секции Параметры главного меню. Он выполняет двоякую функцию. Во-первых, здесь можно изменить собственно язык интерфейса и прочие параметры, объединяемые понятием locale (формат даты, представление чисел, единицы измерения etc.). При выборе русского в качестве языка инсталляции всё это будет русским Российским (интерфейс, разумеется, русифицируется в меру испорченности перевода):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_063.png">
        <img alt="Изображение217" class="frameGraphics" id="217graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_063.png" style="border:1.0px solid #000080;padding:0;width:545.83057px;height:573.83685px" />
      </a>
      <a id="a217graphic"></a>
      <a id="bkm217graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_063.png"> </a>
    </p>
    <p class="Textbody">При желании или необходимости можно установить и более иные языки — список доступных превышает два десятка:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_064.png">
        <img alt="Изображение218" class="frameGraphics" id="218graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_064.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:494.8448px" />
      </a>
      <a id="a218graphic"></a>
      <a id="bkm218graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_064.png"> </a>
    </p>
    <p class="Textbody">Главная особенность нового языкового модуля (он появился в Mint 17.1) — разделение групп параметров Language и Region (в русском переводе — Язык и Область/Край, соответственно). Первая определяет переменные LANG и LC_TIME, то есть собственно язык интерфейса и местное время. Группа же параметров Region задаёт значения всех остальных локально-зависимых переменных — LC_NUMERIC, LC_MONETARY, LC_PAPER, LC_NAME, LC_ADDRESS, LC_TELEPHONE, LC_MEASUREMENT и LC_IDENTIFICATION (представление чисел, единица бабла, формат бумаги, и так далее).</p>
    <p class="Textbody">Разнесение переменных по группам может показаться спорным, как и его аргументация Клементом (типа специально для отъезжающих за границу). Однако сама по себе идея отделения языка интерфейса от прочего локально-зависимого хозяйства весьма здрава, особенно если язык этот — смесь нижегородского с оксфордским. Что же до местного времени... С каждым очередным самым последним переводом часов оно теряет всё больше смысла. Так что не пора ли жить по Гринвичу? Вполне реализуемо, как можно видеть на следующем скриншоте:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_065.png">
        <img alt="Изображение219" class="frameGraphics" id="219graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_065.png" style="border:1.0px solid #000080;padding:0;width:558.83215px;height:573.83685px" />
      </a>
      <a id="a219graphic"></a>
      <a id="bkm219graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_065.png"> </a>
    </p>
    <p class="Textbody">Вторая функция mintlocale — определение так называемого метода ввода. Поддержка их также впервые появилась в Mint 17.1. Методы ввода (Input Method) — это системы обеспечения ввода символов, отсутствующих на клавиатуре от слова «вааще». Например, китайских иероглифов и символов всех генетически связанных с ними систем письма. И потому, конечно, жизненно необходимы жителям соответствующих стран.</p>
    <p class="Textbody">Однако мы, индоевропейцы, семиты, тюрки и многие другие, выступая как единый советский народ, не испытываем в них ни малейшей потребности. И потому то, что реально ни один метод ввода не включён (разработчики объясняют это недостатком сил), огорчать нас не должно. Напротив, скорее радовать. Ибо попытки майнтайнеров некоторых дистрибутивов включать поддержку какого-либо из этих методов (мне приходилось сталкивать с IBus), да ещё и по умолчанию, нам, применителям, не давало ничего, кроме лишних проблем.</p>
    <h3 id="toc56"><a id="RefHeading15541713816058"></a><a id="bkmRefHeading15541713816058"></a><a id="toc55"></a><a id="bkmtoc55"></a><a id="RefHeading4081136957987"></a><a id="bkmRefHeading4081136957987"></a><a id="bkmRefHeading4081136957987"></a><a id="bkmbkmRefHeading4081136957987"></a>Менеджер драйверов и интегрированное видео AMD</h3>
    <p class="Textbody">Последний из фирменных инструментов Mint, о котором я хотел сказать пару слов — Менеджер драйверов, он же mintdrivers, предназначенный для управления проприетарными драйверами, например, для видеокарт. Правда, мой личный опыт общения с ним оказался неудачным, но это связано с моим «железом», а не собственно с программой. Так что просто опишу последовательность действий, проиллюстрировав её скриншотами.</p>
    <p class="Textbody">Запуск утилиты происходит из секции Администрирование главного меню, где она носит имя Менеджер драйверов. После чего на экране появляется (в моём случае с интегрированным процессорным видео Radeon HD 7500G) такая картинка:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_066.png">
        <img alt="Изображение220" class="frameGraphics" id="220graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_066-572x443.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:444.84158px" />
      </a>
      <a id="a220graphic"></a>
      <a id="bkm220graphic"></a>
    </p>
    <p class="Textbody">Представляется очевидным, что для установки проприетарного драйвера достаточно вместо первой строки отметить третью и нажать кнопку Применить изменения. Только я это сделал — как процесс пошёл:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_067.png">
        <img alt="Изображение221" class="frameGraphics" id="221graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_067-572x443.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:444.84158px" />
      </a>
      <a id="a221graphic"></a>
      <a id="bkm221graphic"></a>
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_067.png"> </a>
    </p>
    <p class="Textbody">Шёл процесс довольно медленно, так как кроме собственно драйвера fglrx в ходе его устанавливались lib32gcc1, dkms и ещё куча зависимостей, а также регенерация /boot/initrd.img. По завершении всего этого исходная картинка приняла следующий вид:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/mint-tools_068.png">
        <img alt="Изображение222" class="frameGraphics" id="222graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-tools_068-572x443.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:444.84158px" />
      </a>
      <a id="a222graphic"></a>
      <a id="bkm222graphic"></a>
    </p>
    <p class="Textbody">Заодно был создан и файл /etc/X11/xorg.conf с описанием конфигурации видеосистемы. Что в моём случае, правда, не помогло: после рестарта машина отказалась загружаться, выдав чёрный экран без возможности переключения в текстовую консоль и реакции на комбинацию из трёх пальцев. Пришлось перезагружаться в recovery mode и заниматься ликвидацией этого безобразия — но это совсем другая история.</p>
    <p class="Textbody">Впрочем, проделанный опыт не был совсем уж бесполезным. Оказалось, что теоретически установка проприетарных драйверов через штатный Менеджер драйверов действительно очень проста, хотя в дальнейшем не исключены осложнения — но они, повторяю, скорее всего связаны с особенностями «железа».</p>
    <p class="Textbody">На этом я пока поставлю точку в описании фирменного инструментария дистрибутива Mint. За бортом остались ещё несколько утилит, повода обращаться к которым у меня не было, и потому ничего сказать про них я не могу. В их числе:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">mintWifi — средство настройки соответствующего соединения; но у меня на Ноутбучке WiFi волшебным образом заработал сам собой, без всяких настроек; </p>
      </li>
      <li>
        <p class="Textbody">mintupload-manager — средство управления закачками на сервера, применения которому я не нашёл; </p>
      </li>
      <li>
        <p class="Textbody">mintnanny — блокировщик доменов; без надобности, ибо я не депутат госдумы, чтобы мне везде мерещилась банда педофилов с ихней порнографией. </p>
      </li>
    </ul>
    <p class="Textbody">Что же до утилит mint-make, mint-batch-make, mint-compress, mint-decompress, о назначении которых можно догадаться по их именам, то к ним я обращусь, когда и если (если и когда) в этом возникнет практическая необходимость.</p>
    <h2 id="toc57"><a id="RefHeading15561713816058"></a><a id="bkmRefHeading15561713816058"></a><a id="toc56"></a><a id="bkmtoc56"></a><a id="RefHeading12581136957987"></a><a id="bkmRefHeading12581136957987"></a><a id="bkmRefHeading12581136957987"></a><a id="bkmbkmRefHeading12581136957987"></a>Прочие настройки</h2>
    <p class="Textbody">В предыдущих очерках говорилось о штатных инструментах для настройки дистрибутива Mint и его среды Cinnamon. Чтобы закончить с этой тему, скажу несколько слов об инструментах конфигурирования не то чтобы нештатных, но непосредственно ни к дистрибутиву, ни к среде не привязанных. И к которым приходится обращаться не так уж часто.</p>
    <h3 id="toc58"><a id="RefHeading15581713816058"></a><a id="bkmRefHeading15581713816058"></a><a id="toc57"></a><a id="bkmtoc57"></a><a id="RefHeading4101136957987"></a><a id="bkmRefHeading4101136957987"></a><a id="bkmRefHeading4101136957987"></a><a id="bkmbkmRefHeading4101136957987"></a>Редактор dconf</h3>
    <p class="Textbody">Редактор dconf появился в GNOME 3 и ныне применяется для низкоуровнего конфигурирования, кроме родительсккой среды, также в Unity, MATE и Cinnamon. Он позволяет напрямую редактировать всю базу конфигурации, как общесистемную, так и штатных пользовательских приложений. И, хотя делает это и не самым простым способом, но даёт доступ к тем настройкам, которые разработчики сред посчитали недостойными внимания конечных пользователей. Или, скорее, решили, что народу они не нужны.</p>
    <p class="Textbody">Правда, в Cinnamon таких замаскированных настроек очень мало. И если в Unity обращаться к Редактору dconf приходится постоянно, а в MATE — периодически, то в нашей среде у меня поводы для запуска этой утилиты возникали буквально считанные разы.</p>
    <p class="Textbody">Запускается эта утилита, кстати, через пункт Редактор dconf в секции Администрирование главного меню, после чего предстаёт в таком виде:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/dconf_001.png">
        <img alt="Изображение223" class="frameGraphics" id="223graphic" src="http://alv.me/wp-content/img/im_cin_img/dconf_001-572x369.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:370.83844px" />
      </a>
      <a id="a223graphic"></a>
      <a id="bkm223graphic"></a>
    </p>
    <p class="Textbody">Каждый пункт во фрейме слева разворачивается каскадом вложенных пунктиков и подпунктиков, имя которым далеко превышает легион. И описывать которые я не буду. А дам пару практических рецептов для включения некоторых опций, недоступных через Системные настройки среды Cinnamon.</p>
    <p class="Textbody">Ранее я упоминал, что в текущей версии Cinnamon возможность сохранения сеанса из пункта Автостарт изъята. Но в Редакторе dconf она осталась. И доступ к ней осуществляется по схеме org.cinnamon.SessionManager, где следует включить параметр (в терминологии dconf — ключ) auto-save-session:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/dconf_002.png">
        <img alt="Изображение224" class="frameGraphics" id="224graphic" src="http://alv.me/wp-content/img/im_cin_img/dconf_002-572x369.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:370.83844px" />
      </a>
      <a id="a224graphic"></a>
      <a id="bkm224graphic"></a>
    </p>
    <p class="Textbody">Не так давно мы весьма подробно рассмотрели конфигурирование раскладок клавиатуры и их переключателей через соответствующий модуль Системных настроек Cinnamon. И пришли к выводу, что тут можно настроить всё, что только душе угодно. Тогда же было упомянуто, что всё то же самое можно проделать и в Редакторе dconf. Для чего достаточно проследовать по org.gnome.libgnomekbd.keyboard и заполнить желаемым образом поля layouts, model и options:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/dconf_003.png">
        <img alt="Изображение225" class="frameGraphics" id="225graphic" src="http://alv.me/wp-content/img/im_cin_img/dconf_003-572x369.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:370.83844px" />
      </a>
      <a id="a225graphic"></a>
      <a id="bkm225graphic"></a>
    </p>
    <p class="Textbody">Как заполнить — описывать не буду, потому что через модуль Клавиатура в Системных настройках это сделать проще. А вот если пройти по схеме org.gnome.libgnomekbd.desktop, то можно включить ключ load-exta-items:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/dconf_004.png">
        <img alt="Изображение226" class="frameGraphics" id="226graphic" src="http://alv.me/wp-content/img/im_cin_img/dconf_004-572x369.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:370.83844px" />
      </a>
      <a id="a226graphic"></a>
      <a id="bkm226graphic"></a>
    </p>
    <p class="Textbody">Это обеспечит загрузку редко используемых раскладок клавиатуры. В частности, для русской раскладки окажутся доступными дополнительные варианты — те, что пыведены курсивом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/dconf_005.png">
        <img alt="Изображение227" class="frameGraphics" id="227graphic" src="http://alv.me/wp-content/img/im_cin_img/dconf_005-572x530.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:531.8463px" />
      </a>
      <a id="a227graphic"></a>
      <a id="bkm227graphic"></a>
    </p>
    <p class="Textbody">В русскоязычном окружении этот ключ практического значения не имеет, но для всяких прочих языцей — может пригодиться. Например, для программирования на APL:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/dconf_006.png">
        <img alt="Изображение228" class="frameGraphics" id="228graphic" src="http://alv.me/wp-content/img/im_cin_img/dconf_006-572x313.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:314.8258px" />
      </a>
      <a id="a228graphic"></a>
      <a id="bkm228graphic"></a>
    </p>
    <p class="Textbody">Впрочем, более никаких практических задач для решения в Редакторе dconf я не придумал.</p>
    <h3 id="toc59"><a id="RefHeading15601713816058"></a><a id="bkmRefHeading15601713816058"></a><a id="toc58"></a><a id="bkmtoc58"></a><a id="RefHeading4121136957987"></a><a id="bkmRefHeading4121136957987"></a><a id="bkmRefHeading4121136957987"></a><a id="bkmbkmRefHeading4121136957987"></a>Mint и консоль</h3>
    <p class="Textbody">Всё, что было сказано о конфигурировании Mint в предыдущих очерках, относилось к настройкам графических сред, даже конкретно одной представительницы их — Cinnamon. Но ведь в Linux'е есть ещё и «текстовый» режим, то есть консоль. «Текстовый» в кавычках — потому что, конечно, чисто текстовой консоли нынче не найти, наверное, ни в одном дистрибутиве, везде frame buffer — но уж такова традиция.</p>
    <p class="Textbody">Любителей выполнять в «голой» консоли практическую работу нынче не так уж и много. Наверное, поэтому майнтайнеры практически всех дистрибутивов относятся к настройке консольного режима абы как, если не сказать — никак. А уж когда дело доходит до локализованных систем — это вообще туши свет. Редкий дистрибутив может похвастаться тем, что в его голой консоли в ответ на команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ date</span> </p>
    <p class="Textbody">выводятся настоящие русские буквы, а не квадратики или кракозябры.</p>
    <p class="Textbody">Повторяю, вряд ли кто будет сочинять в консоли многотомные романы на русском языке — в основном в текстовом режиме приходится загружаться при всякого рода сбоях. Но иногда приходится. Аварийные работы тоже лучше выполнять в комфортной и приятной для глаз обстановке. Да и вообще, как говорил штабс-капитан Мышлаевский, в казарме должен быть порядок, А текстовая консоль большинства современных дистрибутивов от порядка далека.</p>
    <p class="Textbody">К чести Mint надо сказать, что этот дистрибутив принадлежит как раз к тем редким, у которых консоль русифицирована «искаропки». Русские буквы здесь и правильно выводятся, и правильно вводятся. Причём вводятся в том самом варианте русской раскладки клавиатуры, который был задан при инсталляции системы, и переключатель раскладок (по комбинации Alt+Shift) оказывается таким же, как в графическом режиме. В общем, оказывается, что приложить руки к улучшательству есть где. Ибо у применителя всё должно быть прекрасно — в том числе и консоль.</p>
    <p class="Textbody">Особенно раздражает отсутствие поддержки мыши — без неё работа в консоли, даже аварийно-спасательная, становится мучительной. Ибо мышь в консоли — устройство не указательно-позиционирующее, а копировально-вставляющее. Достаточно выделить мышью фрагмент экрана, как он попадает в экранный буфер, откуда может быть вставлен в любое место, в том числе и в другую виртуальную консоль, щелчком средней кнопки мыши. Функция, незаменимая при правке конфигов — а ведь аварийно-спасательные работы обычно к ней и сводятся.</p>
    <p class="Textbody">Поясню (как ни странно, нынче это надо пояснять), что на современных колесовых мышах роль средней кнопки почти всегда выполняет это самое колёсико. А на ноутбучных тачпадах тот же эффект достигается одновременным нажатием обеих кнопок. Правда, что делать на входящих в моду ноутбуках с однокнопочными тачпадами — не знаю; разве что, не покупать их...</p>
    <p class="Textbody">Из поставленных задач по улучшательству консоли проще всего решается первоочередная — включение службы консольной мыши, сиречь gpm. Для этого нужно, как это ни парадоксально, установить пакет gpm:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo apt install gpm</span> </p>
    <p class="Textbody">Если сделать это, находясь в чистой консоли (а перключиться в любую из них можно по комбинации клавиш Control+Alt+F#, # — от 1 до 6; возврат в графический сеанс — Alt+F8), то немедленно после завершения установки можно будет увидеть курсор мыши в виде прямоугольничка. И теперь, по крайней мере, не придётся при всяких ремонтно-восстановительных работах вводить много лишних символов — в распоряжении применителя описанный выше «мышиный» буфер.</p>
    <p class="Textbody">Следующая задача на очереди — установка удобочитаемого экранного шрифта. Проще всего она решается утилитой dpkg-reconfigure. Вызванная в таком виде</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo dpkg-reconfigure console-setup</span> </p>
    <p class="Textbody">она запустит псевдографическую программу, настройки экранных шрифтов для консоли. Которая сначала попросит выбрать кодировку:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_078.png">
        <img alt="Изображение229" class="frameGraphics" id="229graphic" src="http://alv.me/wp-content/img/im_cin_img/param_078-572x363.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:364.82898px" />
      </a>
      <a id="a229graphic"></a>
      <a id="bkm229graphic"></a>
    </p>
    <p class="Textbody">Затем спросит об используемой таблице символов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_079.png">
        <img alt="Изображение230" class="frameGraphics" id="230graphic" src="http://alv.me/wp-content/img/im_cin_img/param_079-572x382.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:383.84px" />
      </a>
      <a id="a230graphic"></a>
      <a id="bkm230graphic"></a>
    </p>
    <p class="Textbody">Потом последует предложение выбрать шрифт:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_080.png">
        <img alt="Изображение231" class="frameGraphics" id="231graphic" src="http://alv.me/wp-content/img/im_cin_img/param_080-572x382.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:383.84px" />
      </a>
      <a id="a231graphic"></a>
      <a id="bkm231graphic"></a>
    </p>
    <p class="Textbody">Далее будет проведён маленький ликбез о консольных шрифтах и условиях их использования:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_081.png">
        <img alt="Изображение232" class="frameGraphics" id="232graphic" src="http://alv.me/wp-content/img/im_cin_img/param_081-572x382.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:383.84px" />
      </a>
      <a id="a232graphic"></a>
      <a id="bkm232graphic"></a>
    </p>
    <p class="Textbody">Не советую им пренебрегать — после этого легче сделать осознанный выбор матрицы шрифта (типографские термины к консольным шрифтам не применимы):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/param_082.png">
        <img alt="Изображение233" class="frameGraphics" id="233graphic" src="http://alv.me/wp-content/img/im_cin_img/param_082-572x382.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:383.84px" />
      </a>
      <a id="a233graphic"></a>
      <a id="bkm233graphic"></a>
    </p>
    <p class="Textbody">После этого происходит выход из интерфейса утилиты, и всё заказанное претворяется в действительность. Процесс этот связан с регенерацией initrd, так что его результат можно будет увидеть только после рестарта — с которым, впрочем, не обязательно торопиться.</p>
    <p class="Textbody">Третья задача очень важна для меня — но возможно, что большинству применителей решать её не придётся. Я использую сочетание варианта Typewriter Legacy для кириллической раскладки и CapsLock в качестве переключателя латиница/кириллица. Когда-то эта была стандартная комбинация (именно такова была первая русская раскладка для UNIX-косоли, созданная Андреем Черновым aka ache), но ныне воспринимается как экзотика. И её «спаривание» для консоли Linux требует некоторых усилий. В частности, в большинстве дистрибутивов мне приходилось прибегать к раскладке, изготовленной собственноручно.</p>
    <p class="Textbody">А вот в Mint эти усилия минимальны. Я имел не один раз повод радостно сообщить, что выбранная при установке раскладка клавиатуры и один из её вариантов (среди которых имеется и Typewriter Legacy) наследуется не только Иксами, но и консолью установленной системы. Правда, с переключением раскладок по Alt+Shift, порождённым каким-то умником в недрах Microsoft'а вместе с раскладкой winkeys (также одной из самых неудобных, какую только можно придумать).</p>
    <p class="Textbody">Однако задача с изменением переключателя решается очень просто: достаточно отредактировать файл /etc/default/keyboard. Он практически точно совпадает с клавиатурной секцией старого /etc/X11/xorg.conf или современного /etc/X11/xorg.conf.d/10-keymap.conf, и по умолчанию выглядит так:</p>
    <p class="Textbody"><span style="background-color:#dddddd">XKBMODEL="pc105"</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">XKBLAYOUT="us,ru"</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">XKBVARIANT=",typewriter-legacy"</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">XKBOPTIONS="grp:alt_shift_toggle,grp_led:scroll"</span> </p>
    <p class="Textbody">Так что в нём достаточно заменить значение переключателя alt_shift_toggle на желаемое, например, для меня — на caps_toggle. После чего можно с чистым сердцем перегружаться и, авторизовавшись в любой текстовой консоли, любоваться красивыми шрифтами семейства Terminus, созданными Димитром Жековым, набирать русские буквы в привычной раскладке и, при необходимости, копировать набранное из консоли в консоль через «мышиный» буфер.</p>
    <h3 id="toc60"><a id="RefHeading15621713816058"></a><a id="bkmRefHeading15621713816058"></a><a id="toc59"></a><a id="bkmtoc59"></a><a id="RefHeading4141136957987"></a><a id="bkmRefHeading4141136957987"></a><a id="bkmRefHeading4141136957987"></a><a id="bkmbkmRefHeading4141136957987"></a>GRUB2: восстановление загрузчика</h3>
    <p class="Textbody">В заключение всей «конфигурационной солянки» — пара слов о загрузчике GRUB2. Материалов в Сети на эту тему немерянно (одним из самых полезных мне представляется <a href="http://ru.wikibooks.org/wiki/Grub_2#.D0.92.D0.BE.D1.81.D1.81.D1.82.D0.B0.D0.BD.D0.BE.D0.B2.D0.BB.D0.B5.D0.BD.D0.B8.D0.B5_GRUB2_.D1.81_LiveCD._.D1.81.D0.BF.D0.BE.D1.81.D0.BE.D0.B1_3_.28.D1.81.D0.BE.D0.B2.D1.81.D0.B5.D0.BC_.D0.BF.D1.80.D0.BE.D1.81.D1.82.D0.BE.D0.B9.29" target="_blank">вот этот</a>), и пересказывать их я не намерен. А остановлюсь только на восстановлении загрузчика в случае его порчи по каким-либо причинам.</p>
    <p class="Textbody">Есть несколько методов восстановления GRUB2, я опишу тот, который представляется мне самым простым.</p>
    <p class="Textbody">Для начала надо иметь Live-носитель Mint в любом виде — DVD-, флешки, SD-карты, каковой помещается куда следует. При рестарте машины, обычно в момент появления логотипа производителя, нужно успеть нажать клавишу быстрого выбора загрузочного устройства — для современных ASUS'овских «матерей» это F8, для ASRock'овских — F11, для прочих — см. документацию. И в появившемся меню выбрать нужный пункт, он обычно называется явным образом. Происходит загрузка Live-среды, каковая в нашем случае представлена Mint с Cinnamon-окружением.</p>
    <p class="Textbody">Далее следует опознать имя файла устройства, несущего корневой раздел системы, загрузчик которой подлежит восстановлению — подчёркиваю, требуется имя устройства, а не раздела. Это можно сделать просмотром вывода либо команды</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo fdisk -l</span> </p>
    <p class="Textbody">либо команды</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls /dev/sd*</span> </p>
    <p class="Textbody">Предположим для определённости, что это устройство /dev/sda. Теперь корневой раздел монтируется в файловую систему Live-среды. Прще всего сделать это через Nemo — в его боковой панели, в секции Носители, отражаются все присутствующие в машине дисковые устройства. И достаточно выбрать пункт Присоединить контекстного меню или просто «левокликнуть» на соответствующем имени. Теперь главное — определить точку монтирования. В Mint (как и во всех Ubuntu'идах) временно смотированные устройства попадают в каталог /media/username, устройства с меткой — в подкаталог с её именем, без оной — в подкаталог с универсальным идентификатором устройства (UID), это полуметровая зубодробительная последовательность букв и цифр.</p>
    <p class="Textbody">А вот теперь — собственно восстановление загрузчика. Оно выполняется одной командой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo grub-install --root-directory=/media/username/mount_point /dev/sda</span> </p>
    <p class="Textbody">Здесь mount_point — метка диска или его очень простой UID вроде d55aebcb-7e7d-4d34-aff4-ed6e494e9b7f. Автодополнение в этом случае не работает, однако, даже если устройство не «помечено», его UID можно взять из файла /etc/mtab, описывающего временно смонтированные устройства, или, открыв его в Nemo, из адресной строки последнего.</p>
    <p class="Textbody">На этом дело восстановления загрузчика закончено — можно перезагружаться в нормальном режиме.</p>
    <h2 id="toc61"><a id="RefHeading15641713816058"></a><a id="bkmRefHeading15641713816058"></a><a id="toc60"></a><a id="bkmtoc60"></a><a id="RefHeading12601136957987"></a><a id="bkmRefHeading12601136957987"></a><a id="bkmRefHeading12601136957987"></a><a id="bkmbkmRefHeading12601136957987"></a>Основы командного интерфейса</h2>
    <p class="Textbody">Поскольку не исключена вероятность, что эту книгу будут читать и совсем начинающие применители Linux'а вообще, тех, для кого Mint оказался первым дистрибутивом этой операционной системы, в этом очерке будут даны некоторые общие сведения об интерфейсе командной строки (CLI — Command Line Interface). Тем более, что это потребуется уже ближайшее время, в очерках, посвящённых управлению пакетами.</p>
    <h3 id="toc62"><a id="RefHeading15661713816058"></a><a id="bkmRefHeading15661713816058"></a><a id="toc61"></a><a id="bkmtoc61"></a><a id="RefHeading4161136957987"></a><a id="bkmRefHeading4161136957987"></a><a id="bkmRefHeading4161136957987"></a><a id="bkmbkmRefHeading4161136957987"></a>Введение в CLI</h3>
    <p class="Textbody">CLI представляет собой базу, для которой GUI всякого рода являют лишь оболочку. Всякое действие в linux-системе может быть выполнено прямой командной директивой. И его же можно осуществить путем манипулирования объектами. Например, копирование файлов выполняется соответствующей командой — cp, это первый способ. Но его же можно осуществить перетаскиванием мышью объекта, представляющего наш файл зрительно, из того места, где он находился ранее, туда, где мы хотим видеть его копию, а это уже второй способ.</p>
    <p class="Textbody">То есть манипуляция объектами в GUI — это обычно более или менее опосредованное выполнение соответствующих данному действию команд. Почему основные навыки работы с CLI не помешают даже тому пользователю, который не вылезает из графической среды. Ибо сфера применения CLI не ограничивается «голой» консолью. Он же используется в эмуляторах терминала в графическом режиме оконной среды X. Более того, в настоящее время это основная среда для применения командного интерфейса — к текстовой консоли обычно обращаются только в аварийных ситуациях.</p>
    <p class="Textbody">CLI в большинстве случаев обеспечивается классом программ, именуемых командными интерпретаторами, командными процессорами, командными оболочками или по простому шеллами (shell).</p>
    <p class="Textbody">Как легко догадаться по одному из определений, кроме предоставления пользовательского интерфейса, шеллы выполняют и вторую функцию — служат интерпретаторами собственных языков программирования. На этом основывается классификация шеллов — они разделяются на две группы, обычно именуемые Bourne-shell совместимые и C-shell совместимые. В силу ряда причин в качестве стандарта принята одна из оболочек первой группы — так называемый POSIX-шелл. Правда, он представляет собой чистую абстракцию, однако большинство используемых в Unix'ах оболочек с этим стандартом совместимы. А системная оболочка Mint, Dash, довольно точно воспроизводит и его функциональность. И потому все примеры, иллюстрирующие принципиальные вопросы CLI, будут базироваться на наиболее используемых командах, построенных в соответствие с правилами POSIX-шелла.</p>
    <h3 id="toc63"><a id="RefHeading15681713816058"></a><a id="bkmRefHeading15681713816058"></a><a id="toc62"></a><a id="bkmtoc62"></a><a id="RefHeading4181136957987"></a><a id="bkmRefHeading4181136957987"></a><a id="bkmRefHeading4181136957987"></a><a id="bkmbkmRefHeading4181136957987"></a>Командная строка</h3>
    <p class="Textbody">Основой командного интерфейса является командная строка, начинающаяся с приглашения для ввода. Далее он будет обозначаться милым сердцу россиянина символом длинного зеленого друга — $, если речь идёт о сеансе обычного пользователя, или символом решётки — #, для приглашения строки в сеансе администратора. Это — чистая условность: вид приглашения может быть настроен в широких пределах, причём по разному в разных оболочках. Об этом мы поговорим, когда речь дойдёт до описания конкретного шелла — Zsh.</p>
    <p class="Textbody">Командная строка — визуальное представление среды, в которой задаются основные элементы командного интерфейса: командные директивы с их аргументами и опциями.</p>
    <p class="Textbody">Командная директива (или просто команда) — основная единица, посредством которой пользователь взаимодействует с шеллом. Она образуется по определенным правилам, именуемым синтаксисом. Синтаксис командной директивы определяется, в первую очередь, языком, принятым в данной командной оболочке. Кроме того, некоторые команды (не очень многочисленные, но весьма употребимые) имеют собственный, нестандартный синтаксис.</p>
    <p class="Textbody">Однако в целом базовые правила построения команд имеют много общего. И именно эти базовые правила станут предметом данного раздела. Синтаксические особенности отдельных нестандартных команд будут оговариваться по ходу изложения.</p>
    <p class="Textbody">Итак, командная директива образуется:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">именем команды, однозначно определяющим ее назначение, </p>
      </li>
      <li>
        <p class="Textbody">опциями, определяющими условия выполнения команды, и </p>
      </li>
      <li>
        <p class="Textbody">аргументами — объектами, над которым осуществляются действия. </p>
      </li>
    </ul>
    <p class="Textbody">Очевидно, что имя команды является обязательным компонентом, тогда как опции и аргументы могут и отсутствовать (или подразумеваться в неявном виде по умолчанию).</p>
    <p class="Textbody">ещё один непременный компонент командной директивы — это специальный невидимый символ конца строки: именно его ввод отправляет команду на исполнение. В обыденной жизни этот символ вводится нажатием и отпусканием клавиши Enter. Почему обычно и говорят: для исполнения команды нажмите клавишу Enter. Тот же эффект, как правило, достигается комбинацией клавиш Control+M. Символа конца командной строки, знаменующего исполнение команды, мы на экране не видим. Однако важно, что это — такой же символ, как и любой другой (хотя и имеющий специальное значение).</p>
    <p class="Textbody">В подавляющем большинстве случаев опции (или их последовательности) задаются непосредственно за именем команды, а аргумент (или группа аргументов) команду завершает, хотя это правило имеет некоторые исключения. Вне зависимости от порядка опций и аргументов, принятых для данной команды, интерпретация их осуществляется слева направо.</p>
    <p class="Textbody">Команды, опции и аргументы обязательно разделяются между собой пробелами. Кроме того, опции обычно предваряются (без пробела) символом дефиса или двойного дефиса. Впрочем, немногочисленные (но весьма употребимые) команды могут использоваться с опциями без всяких предваряющих символов.</p>
    <p class="Textbody">Как уже говорилось, имя команды определяет выполняемые ею функции. Существуют команды, встроенные в оболочку, то есть не имеющие запускающих их исполняемых файлов, и команды внешние. В последнем случае имя команды однозначно указывает на имя исполняемого файла программы, выполняемой при отдаче соответствующей директивы. Часто встроенные и внешние команды одного назначения имеют одинаковые имена. В этом случае обычно предпочтительно использование встроенных команд — впрочем, они и вызываются в первую очередь. Для вызова одноимённой внешней команды её нужно задать с указанием пути. Так, директива</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ time search for Mint in path2/</span> </p>
    <p class="Textbody">вызовет для определения времени выполнения команды search (о ней будет рассказываться в следующем очерке) встроенную команду time. А в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /usr/bin/time search for Mint in path2/</span> </p>
    <p class="Textbody">будет задействована внешняя утилита с тем же именем. Кстати, это один из тех случаев, когда второй вариант может иногда оказаться предпочтительней: встроенная и внешняя команды имеют разные форматы вывода, причём в первой он зависит от используемой командной оболочки. И потому она не всегда подходит для прямого сравнения результатов — например, быстродействия в разных системах.</p>
    <p class="Textbody">Определить, является ли данная команда встроенной в оболочку или внешней, можно с помощью встроенных команд type или which. Для встроенных команд вывод их будет таким:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ type which</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">which is a shell builtin</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">$ which type</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">type: shell built-in command</span> </p>
    <p class="Textbody">Или, в некоторых случаях, таким:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ which time</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">time: shell reserved word</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">$ type time</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">time is a reserved word</span> </p>
    <p class="Textbody">Для внешних команд любой из этих вариантов даст в выводе путь к исполняемому файлу:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ which date</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/bin/date</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">$ type date</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/bin/date</span> </p>
    <p class="Textbody">Некоторые команды могут выступать под несколькими именами. Это связано с тем, что исторически в различных Unix-системах команды, исполнявшие одинаковые функции, могли получать разные названия. В каждой конкретной системе обычно используется только одна из таких команд-дублеров. Но при этом имена дублирующих команд также могут присутствовать в системе — для совместимости. Не следует думать, что это две различные программы одного назначения: как правило, такая синонимичность команд реализуется посредством механизма ссылок (links) или псевдонимов (alias), о которых речь пойдёт позднее.</p>
    <p class="Textbody">Иногда команда, вызванная через имя своего синонима, может отличаться по своей функциональности от самой же себя, вызванной под родным именем. В этом случае говорят о эмуляции одной команды другой. Типичный пример — командная оболочка /bin/bash в большинстве дистрибутивов Linux имеет своего дублера — /bin/sh; вызванная таким образом, она воспроизводит базовую функциональность стандарта POSIX-шелла.</p>
    <h3 id="toc64"><a id="RefHeading15701713816058"></a><a id="bkmRefHeading15701713816058"></a><a id="toc63"></a><a id="bkmtoc63"></a><a id="RefHeading4201136957987"></a><a id="bkmRefHeading4201136957987"></a><a id="bkmRefHeading4201136957987"></a><a id="bkmbkmRefHeading4201136957987"></a>Автодополнение</h3>
    <p class="Textbody">Для правильного применения команд, конечно же, нужно знать их имена и назначение. Однако нас никто не заставляет напрягать пальцы вводом имени команды полностью. Потому что тут на помощь приходит великий метод автодополнения.</p>
    <p class="Textbody">Благодаря этому методу для любой команды достаточно ввести первые несколько ее символов — и нажать клавишу табуляции (Tab). И, если введённых буковок достаточно для однозначной идентификации, полное имя команды волшебным образом возникнет в строке. Если же наш ввод допускает альтернативы продолжения имени — все они высветятся на экране (сразу или после повторного нажатия на табулятор), и из них можно будет выбрать подходящую.</p>
    <p class="Textbody">Большинство употребимых команд POSIX-систем — коротки и мнемонически прозрачны. И может показаться. что не такое уж это облегчение — заменить ввод двух-трех символов нажатием табулятора (а то ещё и неоднократным). Однако, когда речь дойдет до аргументов команд — тут вся мощь автодополнения станет явной.</p>
    <p class="Textbody">И ещё маленькое отступление. Автодополнение — стандартная возможность Bash и всех других командных оболочек, относимых к категории развитых. Но как раз в стандарте POSIX эта возможность не предусмотрена, и потому POSIX shell ее лишён. Нет этой функции и в Dash — системной командной оболочке Mint. Которая, впрочем, в интерактивном режиме не используется.</p>
    <p class="Textbody">Ещё один способ облегчения ввода команд — обращение к их истории, о чём разговор будет несколько позже.</p>
    <h3 id="toc65"><a id="RefHeading15721713816058"></a><a id="bkmRefHeading15721713816058"></a><a id="toc64"></a><a id="bkmtoc64"></a><a id="RefHeading4221136957987"></a><a id="bkmRefHeading4221136957987"></a><a id="bkmRefHeading4221136957987"></a><a id="bkmbkmRefHeading4221136957987"></a>Опции</h3>
    <p class="Textbody">Указания только имени команды достаточно для выполнения некоторых из них. Типичный пример — команда ls (от list), предназначенная для просмотра имен файлов (строго говоря, содержимого каталогов). Данная без аргументов, она выводит список имен файлов, составляющих текущий каталог, представленный в некоторой форме по умолчанию, например, в домашнем каталоге пользователя это будет выглядеть примерно так:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ ls</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Desktop/    Downloads/   Music/  Pictures/  Templates/</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Documents/  lost+found/  mytmp/  Public/    Videos/</span> </p>
    <p class="Textbody">Исполнение же многих других команд невозможно без указания опций и (или) аргументов. Для них в ответ на ввод одного её имени часто следует не сообщение об ошибке (или не только оно), но и краткая справка по использованию команды. Например, в ответ на ввод команды для создания каталогов mkdir (от make directory) последует следующий вывод:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">usage: mkdir [-pv] [-m mode] directory ...</span> </p>
    <p class="Textbody">Для одних опций достаточно факта присутствия в командой директиве, другие же требуют указания их значений (даваемых после опции обычно через знак равенства). В приведённом примере команды mkdir к первым относятся опции -v (или --verbose), предписывающая выводит информацию о ходе выполнения команды (запомним эту опцию — в том же смысле она используется чуть ли не во всех командах Unix), и -p, которая позволяет создать любую цепочку промежуточных каталогов между текущим и новообразуемым (в случае их отсутствия).</p>
    <p class="Textbody">А вот опция -m, определяющая атрибуты доступа к создаваемому каталогу, обязательно требует указания значения — этих самых атрибутов, заданных в символьной форме.</p>
    <p class="Textbody">Многие опции имеют две формы — краткую, односимвольную, и полную, или многосимвольную, Некоторые же опции могут быть даны только в многосимвольной форме. Общее правило здесь таково: если одного символа достаточно для однозначного определения опции, могут употребляться обе формы в качестве равноправных. Однако поскольку количество символов латинского алфавита ограниченно (а человеческая фантазия, конструирующая опции — безгранична), при большом количестве опций одной команды некоторые из них приходится делать исключительно многосимвольными.</p>
    <p class="Textbody">Продемонстрирую это на примере опций все той же команды mkdir. Полный их список будет следующим:</p>
    <p class="Textbody"><span style="background-color:#dddddd">-m, --mode=MODE установить код доступа</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        (как в chmod)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">-p, --parents не выдавать ошибок,</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        если существует, создавать</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        родительские каталоги,</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        если необходимо</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">-v, --verbose печатать сообщение</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        о каждом созданном каталоге</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">--help показать помощь и выйти</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">--version  вывести информацию</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        о версии и выйти</span> </p>
    <p class="Textbody">Очевидно, что для опции --version краткая форма совпала бы с таковой для опции --verbose, и потому первая существует только в полной форме. А вот для опции --help краткая форма в большинстве команд возможна, и она выглядит как -h. Более того, во многих командах вызов помощи может быть вызван посредством опции -?. К слову сказать — приведенный выше список опций команды mkdir получен именно таким способом.</p>
    <p class="Textbody">Раз уж зашла речь об опциях --version и -h (--help, -?), давайте и их запомним на будущее. Это — так называемые стандартные опции GNU, в число коих входит и опция -v, --verbose. Назначение «длинной» их формы (--version, --help, --verbose) идентично почти во всех командах, краткой — во многих.</p>
    <p class="Textbody">Опять-таки, из того же примера видно, что опции в односимвольной форме предваряются единичным символом дефиса и могут быть даны единым блоком, без пробелов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mkdir -vpm 777 dir/subdir</span> </p>
    <p class="Textbody">При этом, естественно, опция, требующая указания значений, ставится последней, и ее значение отделяется пробелом. Опции же в многосимвольной форме требуют предварения удвоенным дефисом, обязательно должны разделяться пробелами и значения их, если таковые требуются, присваиваются через символ равенства (по научному он называется ещё оператором присваивания):</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mkdir --parents --mode=777 dir/subdir</span> </p>
    <p class="Textbody">Загадочные семерки после опции -m (--mode) — это и есть те самые атрибуты доступа, данные в символьной нотации, о которых речь пойдёт в соответствующем разделе.</p>
    <p class="Textbody">Опции команды именуются также флагами (реже ключами) или параметрами. Однозначной трактовки этих терминов нет. Однако обычно под флагами подразумеваются опции, не требующие указания значений. Термин параметр же применяется к опции, такового требующей, и объединяет опцию и ее значение. Правда, мне встречалось определение параметра как совокупности опций и аргументов, но я буду придерживаться приведенных определений.</p>
    <p class="Textbody">Порядок опций, если их приводится более одной, для большинства команд не существенен. Хотя, например, для команды tar, создающей файловые архивы, опция -f, значением которой является имя создаваемого или распаковываемого архива, традиционно указывается последней. И, к слову сказать, именно эта команда — одна из немногих, опции которой не обязаны предваряться символами дефиса. Так, директивы</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar cf filename.tar dir</span> </p>
    <p class="Textbody">и</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar -cf filename.tar dir</span> </p>
    <p class="Textbody">абсолютно равноценны: и та, и другая создает единый архивный файл filename.tar из отдельных файлов каталога dir.</p>
    <p class="Textbody">Особый смысл имеет символ удвоенного дефиса --, если после него не следует никакой опции: таким образом обозначается конец списка опций, и все последующие, отделённые пробелом, символы интерпретируются как аргументы. Одинарный же дефис с последующим пробелом, напротив, подменяет аргументы команды, то есть в качестве таковых рассматривается стандартный ввод: знание этого нам потребуется, когда речь дойдёт до командных конвейеров.</p>
    <h3 id="toc66"><a id="RefHeading15741713816058"></a><a id="bkmRefHeading15741713816058"></a><a id="toc65"></a><a id="bkmtoc65"></a><a id="RefHeading4241136957987"></a><a id="bkmRefHeading4241136957987"></a><a id="bkmRefHeading4241136957987"></a><a id="bkmbkmRefHeading4241136957987"></a>Пример: опции команды ls</h3>
    <p class="Textbody">Опции определяют условия выполнения команды. На предыдущей странице был приведён пример команды ls без опций. Однако на самом деле отсутствием опций при ней определяется вид выводимого списка по умолчанию — как многоколочночного списка, состоящего из имен файлов без учета т.н. скрытых файлов (а таковыми являются файлы, имена которых начинаются с символа точки, почему они ещё называются dot-файлами), без каких-либо их атрибутов и без визуального различия файлов различных типов.</p>
    <p class="Textbody">Различные же опции команды ls определяют состав и формат выводимого списка файлов. Так, в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls -a</span> </p>
    <p class="Textbody">она обеспечивает вывод списка имен всех файлов текущего каталога, включая<br />скрытые файлы вида .* (символ * здесь обозначает шаблон имени, соответствующий любому количеству любых символов — в том числе и нулевому, то есть отсутствию оных), символы текущего (./ каталога и</p>
    <p class="Textbody">каталога родительского (../).</p>
    <p class="Textbody">В форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls -l</span> </p>
    <p class="Textbody">дается вывод списка имен файлов в «длинном» формате (отсюда название опции -l — от long), то есть с указанием атрибутов доступа, принадлежности, времени модификации, размера и некоторых других характеристик:</p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxrwxr-x. 14 alv alv 4,0K Мар 14 08:40 current/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x.  2 alv alv 4,0K Фев  8 11:28 Desktop/</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">drwx------.  5 alv alv 4,0K Мар 11 18:34 priv/</span> </p>
    <p class="Textbody">Форма</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls -F</span> </p>
    <p class="Textbody">позволяет получить список файлов с символьным различением файлов различных типов. Например, имя каталога будет выглядеть как dirname/, имя исполнимого файла — как filename* (здесь звездочка — не шаблон имени, а символическое обозначение исполняемого файла), и так далее.</p>
    <p class="Textbody">Я столь подробно остановился на команде ls не только из-за многочисленности ее опций: это — одна из самых употребимых команд для просмотра файловой системы. И, должным образом настроенная (в том числе и с помощью приведенных опций), она дает ничуть не менее информативную и зрительно выразительную картину, чем развитые файловые менеджеры типа Midnight Commander или многочисленные файловых менеджеры графического режима.</p>
    <h3 id="toc67"><a id="RefHeading15761713816058"></a><a id="bkmRefHeading15761713816058"></a><a id="toc66"></a><a id="bkmtoc66"></a><a id="RefHeading4261136957987"></a><a id="bkmRefHeading4261136957987"></a><a id="bkmRefHeading4261136957987"></a><a id="bkmbkmRefHeading4261136957987"></a>Аргументы</h3>
    <p class="Textbody">Таким образом мы подобрались к понятию аргументов командной директивы. Аргументами определяется, как правило, объект (или объекты) действия команды. В большинстве случаев в качестве аргументов команд выступают имена файлов и (или) пути к ним.</p>
    <p class="Textbody">Выше говорилось, что при отсутствии аргументов команда ls выводит список имен файлов текущего каталога. Это значит, что текущий каталог выступает как заданный неявным образом (по умолчанию) аргумент команды ls. Если же требуется вывести список имен файлов каталога, отличного от текущего, путь к нему должен быть указан в качестве аргумента команды явно, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls /usr/bin</span> </p>
    <p class="Textbody">Большинство команд допускает указание не одного, а нескольких (и даже очень многих) аргументов. Так, единой директивой вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cp file1 file2 ... fileN dir</span> </p>
    <p class="Textbody">можно скопировать (команда cp — от copy) сколько угодно файлов из текущего каталога в каталог dir (на самом деле на это «сколько угодно» накладываются некоторые теоретические ограничения, определяемые максимально возможной длиной командной строки, но практически предел этот очень далек).</p>
    <p class="Textbody">Маленькое отступление. Упоминание команды cp — удобный случай чуть вернуться назад и рассмотреть одну очень важную опцию, почти универсальную для команд POSIX-систем. Для начала попробуем скопировать один каталог в другой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cp dir1 dir2</span> </p>
    <p class="Textbody">Как вы думаете, что получится в результате? Правильно, сообщение о невозможности выполнения этой операции — примерно в таком виде:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">cp: omitting directory 'dir1'</span> </p>
    <p class="Textbody">поскольку команда cp в чистом виде для копирования каталогов не предназначена. Что делать? Очень просто — указать опцию -R (от Recursive; в большинстве систем проходит и опция -r с тем же смыслом, но первая форма работает абсолютно везде. В результате в каталог dir2 не только будут скопированы сам каталог dir1 и все входящие в него файлы, но и вложенные подкаталоги из dir1, если таковые имеются.</p>
    <p class="Textbody">Маленькое уточнение: вполне возможно, что в дистрибутиве, который имеется в вашем распоряжении, проходит и копирование каталогов просто через cp, без всяких дополнительных опций. Это — потому, что команда cp часто определяется как псевдоним самой себя с опцией рекурсивного копирования, о чем скоро пойдет речь.</p>
    <p class="Textbody">Вообще рекурсия (то есть определение некоего выражения через самого себя) — очень важное понятие в Unix, пронизывающее происходящие от нее системы насквозь. И послужившие даже базой для своеобразного хакерского юмора. Однако сейчас для нас важно только то, что рекурсия применима практически ко всем файловым операциям, позволяя распространить действие одной командной директивы не только на файлы данного каталога, но и на все вложенные подкаталоги и их содержимое.</p>
    <p class="Textbody">Однако вернемся к аргументам. Действие некоторых команд неоднозначно в зависимости от аргументов, к которым она применяется. Например, команда mv служит как для переименования файлов, так и для их перемещёния в другой каталог. Как же она узнает, что ей делать в данном конкретном случае? Да именно по аргументам. Если дать ее в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mv filename1 filename2</span> </p>
    <p class="Textbody">то следствием будет переименование filename1 в filename2. А вот если первым аргументом указан файл, а вторым — каталог, например</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mv filename dir</span> </p>
    <p class="Textbody">то результатом будет перемещёние filename из текущего каталога в каталог dir. К слову сказать, команды типа mv воспринимают разное количество аргументов в зависимости от того, какие они, эти аргументы. В первом примере аргументов может быть только два — имя исходного файла и имя файла целевого. Зато во втором примере в качестве аргументов можно задать сколько угодно файлов и каталогов (с учетом вышеприведенной оговорки относительно «сколько угодно») — все они будут перемещёны в тот каталог, который окажется последним в списке. То есть директивой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mv file1 ... fileN dir1 ... dirM dirN</span> </p>
    <p class="Textbody">в каталог dirN будут перемещёны все файлы file1 ... fileN и все каталоги dir1 ... dirM. Характерно, что для этого команде mv, в отличие от команды cp, ей не требуется каких-либо дополнительных опций — она рекурсивна по самой своей природе.</p>
    <h3 id="toc68"><a id="RefHeading15781713816058"></a><a id="bkmRefHeading15781713816058"></a><a id="toc67"></a><a id="bkmtoc67"></a><a id="RefHeading4281136957987"></a><a id="bkmRefHeading4281136957987"></a><a id="bkmRefHeading4281136957987"></a><a id="bkmbkmRefHeading4281136957987"></a>Пути к файлам</h3>
    <p class="Textbody">Для правильного построения аргументов команды требуется рассмотрение ещё одного понятия — пути к файлу. Путь — это точное позиционирование файла в файловой системе относительно ее корня (обозначаемого символом прямого слэша — /) или нашего в ней положения — текущего каталога (который, напомню, символически обозначается единичной точкой — .).</p>
    <p class="Textbody">Так, если пользователь находится в своем домашнем каталоге (абсолютный путь к нему обычно выглядит как /home/username), то просмотреть содержимое каталога /usr/bin он может двумя способами — тем, который был дан в предыдущем примере, или вот так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls ../../usr/bin</span> </p>
    <p class="Textbody">Первый путь в аргументе команды ls — абсолютный, отсчитываемый от корневого каталога, второй — задается относительно каталога текущего, ведь ../ — это родительский каталог для него.</p>
    <p class="Textbody">Пути в аргументах команд могут быть весьма длинными. Например, чтобы просмотреть список шрифтов, применяемых в интерфейсе Cinnamon по умолчанию, нужно дать команду следующего вида:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls /usr/share/fonts/truetype/noto</span> </p>
    <p class="Textbody">И читатель вправе спросить — неужели мне все это вводить вручную? Отнюдь — отвечу я ему. Потому что автодополнение, о котором упоминалось по ходу разговора об именах команд, действует также для путей в их аргументах — последовательным нажатием клавиши табуляции все недостающие символы будут добавляться</p>
    <p class="Textbody">Ещё один способ избежать набора длинных путей к файлам — это определение переменной PATH. Внимательный читатель, вероятно, обратил внимание, что при наборе команды путь к исполняемому её файлу не указывается. Для внутренних команд причина понятна — они прошиты в самой оболочке. А как мы обходимся без указания путей к командам внешним? Неужели система мистическим чувством определяет, где они находятся?</p>
    <p class="Textbody">Отнюдь, ни малейшей мистики, Просто каталоги, в которых находятся команды (а это, как правило, /bin, /sbin, /usr/bin, /usr/sbin) определены в качестве значений переменной PATH, о чём мы подробнее поговорим со временем.</p>
    <h3 id="toc69"><a id="RefHeading15801713816058"></a><a id="bkmRefHeading15801713816058"></a><a id="toc68"></a><a id="bkmtoc68"></a><a id="RefHeading4301136957987"></a><a id="bkmRefHeading4301136957987"></a><a id="bkmRefHeading4301136957987"></a><a id="bkmbkmRefHeading4301136957987"></a>Кое-что об исключениях</h3>
    <p class="Textbody">Итак, типичная форма POSIX-команды в обобщенном виде выглядит следующим образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ command -[options] [arguments]</span> </p>
    <p class="Textbody">Из этого правила выбиваются немногочисленные, но весьма полезные и часто используемые команды. Однако и для таких команд с нестандартным синтаксисом устанавливаются те же компоненты — имя, опции, аргументы, хотя по ряду причин (в том числе исторических) порядок их может меняться.</p>
    <p class="Textbody">Это можно проиллюстрировать на примере полезнейшей команды find, предназначенной для поиска файлов (и не только для этого — она являет собой почти универсальное орудие в деле всякого рода файловых манипуляций). В типичной своей форме она выглядит примерно следующим образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find dir -option1 value -option2 [value]</span> </p>
    <p class="Textbody">Здесь dir — каталог, в котором выполняется поиск, — может рассматриваться в качестве аргумента команды. Опция -option1 (обратим внимание, что здесь, не смотря на многосимвольность опций, они предваряются единичным символом дефиса) и ее значение value определяют критерий поиска, например, -name filename — поиск файла с указанным именем, а опция -option2 предписывает, что же делать с найденным файлом (файлами), например, -print — вывести его имя на экран. причём опция действия также может иметь значение. Например, значением опции -exec будет имя команды, вызываемой для обработки найденного файла (файлов). Так, директива вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find ~/ -name *.tar -exec tar xf {} ;</span> </p>
    <p class="Textbody">требует отыскать в домашнем каталоге (~/), выступающем в качестве аргумента, файлы, имя которых (первая опция — критерий поиска) соответствует шаблону *.tar (значение первой опции), и выполнить (вторая опция — действия) в их отношении команду tar с собственными опциями, обеспечивающими распаковку архивов (значение второй опции). Интересно, что в этом контексте в качестве значений второй опции команды find выступает не только внешняя команда, но и все относящиеся к ней опции.</p>
    <p class="Textbody">В последнем примере имеется несколько символов, смысл которых может показаться непонятным. Надеюсь, он прояснится достаточно скоро — в разговоре о регулярных выражениях.</p>
    <h3 id="toc70"><a id="RefHeading15821713816058"></a><a id="bkmRefHeading15821713816058"></a><a id="toc69"></a><a id="bkmtoc69"></a><a id="RefHeading4321136957987"></a><a id="bkmRefHeading4321136957987"></a><a id="bkmRefHeading4321136957987"></a><a id="bkmbkmRefHeading4321136957987"></a>Псевдонимы</h3>
    <p class="Textbody">Вернемся на минуту к команде ls. У читателя может возникнуть вполне резонный вопрос: а если я всегда хочу видеть ее вывод с символическим различением типов файлов, да ещё в «длинном» формате? Ну и без вывода скрытых файлов мне никак не прожить. И что же — мне каждый раз вводить кучу опций, чтобы получить столь элементарный эффект?</p>
    <p class="Textbody">Отнюдь — ответил бы граф, стуча манжетами о подоконник. Потому что этот вопрос задавали себе многие поколения не только пользователей, но и разработчиков. И ответили на него просто — введением понятия псевдонима команды (alias).</p>
    <p class="Textbody">Что это такое? В большинстве случаев — просто некоторое условное имя, подменяющее определённую команду с теми её опциями, которые мы используем чаще всего. Причём, что характерно, псевдоним команды может совпадать с ее именем. То есть, например, — набирая просто ls, мы получаем список файлов не в умолчальном формате, а в том, в каком угодно нам.</p>
    <p class="Textbody">Устанавливаются псевдонимы очень просто — одноименной командой alias, в качестве аргументов которой выступают имя псевдонима и его значение, соединенные оператором присваивания (именуемым в просторечии знаком равенства). А именно, если мы хотим ныне, и присно, и во веки веков видеть вывод команды ls с символьным различением типов файлов, нам достаточно дать команду вроде следующей:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ alias ls='ls -F</span> </p>
    <p class="Textbody">Здесь следует обратить внимание на два момента: а) на то, что имя псевдонима совпадает с именем команды (что отнюдь не препятствует создания псевдонима типа ll='ls -l' специально для вывода файловых списков в длинном формате), и б) на одинарные кавычки, в которые заключено значение псевдонима. Смысл их станет ясен несколькими параграфами позже, а пока просто запомним, что кавычки (и именно одинарные) — обязательный атрибут команды установки псевдонима.</p>
    <p class="Textbody">Таким образом мы можем наделать себе псевдонимов на все случаи жизни. В разумных пределах, конечно — иначе вместо упрощения жизни мы создадим себе необходимость запоминания множество невнятных сочетаний символов. Однако на наиболее важных (и обычно определяемых) псевдонимах я остановлюсь.</p>
    <p class="Textbody">Вспомним команды типа cp и mv, которыми мы, в частности, можем скопировать или переместить какие-то файлы из каталога в каталог. А что произойдет, если чисто случайно в целевом каталоге уже имеются файлы, одноименные копируемым/перемещаемым? Произойдет штука, могущая иметь весьма неприятные последствия: файлы в целевом каталоге будут заменены новыми, теми, что копируются туда или перемещаются. То есть исходное содержание этих файлов будет утрачено — и безвозвратно, восстановить его будет невозможно никакими силами.</p>
    <p class="Textbody">Разумеется, иногда так и нужно, например, при полном резервном копировании старые версии файлов и должны быть заменены их более свежими вариантами. Однако такое приемлемо далеко не всегда. И потому в большинстве команд, связанных с необратимыми изменениями файловой системы, предусматривается специальная опция — -i (или --interactive). Если задать эту опцию с командой cp или mv, то при совпадении имён исходного и целевого файлов будет запрошено подтверждение на выполнение соответствующего действия:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ cp file1 file2</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">cp: overwrite  file2'?</span> </p>
    <p class="Textbody">И пользователь может решить, нужно ли ему затирать существующий файл, ответив yes (обычно достаточно y), или это нежелательно, и должно ответить no (а также просто n — или не отвечать ничего, это равноценно в данном случае отрицательному ответу).</p>
    <p class="Textbody">Так вот, дабы не держать в голове необходимость опции -i (ведь, как я уже говорил, пропуск ее в неподходящий момент может привести к весьма печальным результатам), в подавляющем большинстве систем для команд cp и mv (а также для команды rm, служащей для удаления файлов — эта операция также практически необратима) определяются одноименные им псевдонимы такого вида:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ alias cp='cp -i';</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">$ alias mv='mv -i';</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ alias rm='rm -i'</span> </p>
    <p class="Textbody">Все это, конечно, очень благородно, заметит внимательный читатель. Но что, если мне заведомо известно, что сотни, а то и тысячи файлов целевого каталога должны быть именно переписаны новыми своими версиями? Что же, сидеть и, как дурак, жать на клавишу Y?</p>
    <p class="Textbody">Не обязательно. Потому что все команды рассматриваемого класса имеют ещё опцию -f (в «длинной» своей форме, --force, она также практически универсальна для большинства команд). Которая, отменяя действие опции -i, предписывает принудительно переписать все файлы целевого каталога их обновленными тезками. И никто не мешает нам на этот случай создать ещё один псевдоним для команды cp, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ alias cpf='cp -f'</span> </p>
    <p class="Textbody">Правда, предварительно нужно убедиться, что в системе нет уже команды с именем, совпадающим с именем псевдонима — иначе эффект может быть весьма неожиданным (впрочем, это относится ко всем псевдонимам, не совпадающим с именами подменяемых команд).</p>
    <p class="Textbody">Есть и другой способ обойти опции, установленные для команды-псевдонима: просто отменить псевдоним. Что делается командой обратного значения</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ unalias alias_name</span> </p>
    <p class="Textbody">То есть дав директиву</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ unalias cp</span> </p>
    <p class="Textbody">мы вернем команде копирования ее первозданный смысл. Ну а узнать, какие псевдонимы у нас определены в данный момент, и каковы их значения, ещё проще: команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ alias</span> </p>
    <p class="Textbody">без опций и аргументов выведет полный их список:</p>
    <p class="Textbody"><span style="background-color:#dddddd">la='ls -A'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">less='less -M'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">li='ls -ial'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">ll='ls -l'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">ls='ls -F --color=auto'</span> </p>
    <p class="Textbody">и так далее.</p>
    <p class="Textbody">Когда я сказан о пользовании псевдонимами ныне, и присно, и вовек, — то был не совсем точен. Ныне, то есть в текущем сеансе пользователя — да, они работают. Однако после рестарта системы (или просто после выхода из данного экземпляра командной оболочки) они исчезнут без следа. Чтобы заданные псевдонимы увековечить, их нужно прописать в конфигурационном файле пользовательского шелла. Но этим мы займемся впоследствии. А пока обратимся к переменным.</p>
    <h3 id="toc71"><a id="RefHeading15841713816058"></a><a id="bkmRefHeading15841713816058"></a><a id="toc70"></a><a id="bkmtoc70"></a><a id="RefHeading4341136957987"></a><a id="bkmRefHeading4341136957987"></a><a id="bkmRefHeading4341136957987"></a><a id="bkmbkmRefHeading4341136957987"></a>Переменные</h3>
    <p class="Textbody">Переменные играют для аргументов команд примерно такую же роль, что и псевдонимы — для команд. То есть избавляют от необходимости мрачного ввода повторяющихся последовательностей символов. Конечно, это — далеко не единственное (а может быть, и не главное) назначение переменных, однако на данном этапе для нас наиболее существенное.</p>
    <p class="Textbody">Что такое переменная? Ответ просто — некоторое имя, которому присвоено некоторое значение. Не очень понятно? — Согласен. Но, возможно, станет яснее в дальнейшем.</p>
    <p class="Textbody">Имена переменных в принципе могут быть любыми, хотя некоторые ограничения также существуют. Я уже вскользь упоминал о переменных в разговоре про пути к файлам, где фигурировала переменная PATH. Когда дело дойлёт у нас до пользовательских аккаунтов, придётся поговорить о переменных SHELL, USER, HOME.</p>
    <p class="Textbody">Все эти (и ещё некоторые) имена зарезервированы за внутренними, или встроенными, переменными оболочки (некий минимальный их набор имеется в любом шелле). То есть значения их определены раз и навсегда. и пользователем не изменяются. То есть он, конечно, может их изменить, если очень хочет — но ничего доброго, кроме путаницы, из этого не выйдет.</p>
    <p class="Textbody">Таких встроенных переменных довольно много. Одна из первых по значению — всё та же переменная PATH. Это — список каталогов, в которых оболочка, в ответ на ввод пользователя в командной строке, ищет исполнимые файлы — то есть просто команды. Я уже обращал внимание, что во всех приведённых выше примерах имена команд указывались без всяких путей к ним (в отличие от файлов-аргументов, путь к которым — обязателен). Так вот, успех её поисков и определяется списком значений переменной PATH. Каковые могут быть просмотрены командой echo:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ echo $PATH</span> </p>
    <p class="Textbody">Обратим внимание на то, что в качества аргумента команды выступает не просто имя переменной, а оно же, но предваренное символом доллара. Который в данном случае никакого отношения к приглашению командной строки не имеет, а предписывает команде echo подменить имя переменной ее значением (значениями). В большинстве дистрибутивов Linux случае вывод команды для пользователя будет в обязательном порядке включать такие каталоги:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/bin:/usr/bin:/usr/local/bin</span> </p>
    <p class="Textbody">Для администратора системы сюда обязательно добавятся каталоги /sbin, /usr/sbin и /usr/local/sbin. Остальные значения переменной PATH могут варьировать по умолчанию, а также задаваться пользователем (как — поговорим позже).</p>
    <p class="Textbody">Обратим вниммание на одно важное обстоятельство: практически во всех дистрибутивах Linux и в более иных ОС в перечне значений переменной PATH  отсуствует текущий каталог</p>
    <p class="Textbody">Тем временем вернемся к переменной HOME. Значение ее — полный абсолютный путь к домашнему каталогу пользователя. То есть, чтобы перейти в него, пользователю по имени alv вместо</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cd /home/alv</span> </p>
    <p class="Textbody">достаточно набрать</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cd $HOME</span> </p>
    <p class="Textbody">и он в своих владениях. Может показаться, что экономия — грошовая (тем паче, что перейти в собственный каталог пользователь может просто командой cd без всяких аргументов), но минуту терпения — и выгоду от использования переменных вы увидите.</p>
    <p class="Textbody">Кроме переменных, предопределенных в шелле, пользователю предоставляется почти полная свобода в определении переменных собственных. И вот тут-то и наступает ему обещанное облегчение при наборе аргументов команд.</p>
    <p class="Textbody">Предположим, что у нас имеется глубоко вложенный подкаталог с данными, постоянно требующимися в работе. Чисто условно примем, что путь к нему — следующий:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/home/alv/data/all.my.works/geology/plate-tectonics</span> </p>
    <p class="Textbody">Весьма удручающе для набора, даже если исправно работать табулятором для автодополнения, не так ли? Прекрасно, упрощаем себе жизнь определением переменной:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ plate=/home/alv/data/all.my.works/geology/plate-tectonics</span> </p>
    <p class="Textbody">Дело в шляпе, Теперь, если нам нужно просмотреть состав этого каталога, достаточно будет команды</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls $plate</span> </p>
    <p class="Textbody">А вызвать из него любой файл для редактирования можно так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ joe $plate/filename</span> </p>
    <p class="Textbody">Подобно псевдонимам, переменные, определенные таким образом (то есть просто в командной строке), имеют силу только в текущем сеансе работы — по выходе из оболочки они утрачиваются. Для того, чтобы они действовали перманентно, переменные должны быть прописаны в конфигурационном файле пользовательского шелла. Однако, в отличие от псевдонимов, и этого оказывается не всегда достаточно. Ибо переменная, определенная посредством</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ NAME=Value</span> </p>
    <p class="Textbody">работает не просто только в текущем сеансе — но ещё и только в конкретном экземпляре шелла. Почему и называется переменной оболочки — shell variable. Звучит это. быть может, пока не очень понятно. Однако практически любое действие в шелле — запуск команды или программы, например, — начинается с того, что оболочка, в которой это действие совершается, запускает новый экземпляр самой себя — дочерний шелл, или, как иногда говорят, субшелл.</p>
    <p class="Textbody">Так вот, этот самый субшелл не наследует переменные родительской оболочки. И в итоге запущенная из командной строки программа ничего не будет знать, например, о путях к исполняемым файлам. Что автоматически ведет к невозможности запуска из нее команд просто по имени, без указания точного пути.</p>
    <p class="Textbody">Чтобы избежать такой неприятной ситуации, было придумано понятие переменных окружения, или переменных среды — environment variable. Это — те переменные, которые наследуются от родительского шелла всеми дочерними программами. И чтобы сделать их таковыми, переменные следует экспортировать. Как? Командой export, которая может быть применена двояким образом. Можно сначала определить переменную:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ NAME=Value</span> </p>
    <p class="Textbody">а затем применить к ней команду export:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ export NAME</span> </p>
    <p class="Textbody">А можно сделать это в один прием:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ export NAME=Value</span> </p>
    <p class="Textbody">Второй способ применяется, если нужно определить и экспортировать одну переменную. Если же за раз определяется несколько переменных:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ NAME1=Value1;</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">$ NAME2=Value2;</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">...;</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ NAMEN=ValueN</span> </p>
    <p class="Textbody">то проще прибегнуть к первому способу, так как команда export может иметь сколько угодно аргументов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ export NAME1 NAME2 ... NAMEN</span> </p>
    <p class="Textbody">Традиционно имена переменных окружения задаются в верхнем регистре, переменных оболочки — в нижнем.</p>
    <h3 id="toc72"><a id="RefHeading15861713816058"></a><a id="bkmRefHeading15861713816058"></a><a id="toc71"></a><a id="bkmtoc71"></a><a id="RefHeading4361136957987"></a><a id="bkmRefHeading4361136957987"></a><a id="bkmRefHeading4361136957987"></a><a id="bkmbkmRefHeading4361136957987"></a>Навигация и редактирование</h3>
    <p class="Textbody">Имя команды, ее опции и аргументы образуют т.н. командные «слова». В качестве словоразделителей выступают пробелы. Кроме того, как разделители «слов» интерпретируется ряд специальных символов — прямой слэш (/) — элемент пути к файлу, обратный слэш (\), служащий для экранирования специальных символов, и операторы командных конструкций, о которых будет сказано ниже.</p>
    <p class="Textbody">В некоторых случаях имеет смысл различать «большое слово» и «малое слово». Первые разделяются пробелами, в качестве же вторых интерпретируются символы, лежащие между всеми другими словоразделителями.</p>
    <p class="Textbody">Подчеркнем, что командное «слово» прямо не соотносится ни с опциями, ни с аргументами команды. Введение этого понятия призвано просто облегчить навигацию в командной строке и ее редактирование.</p>
    <p class="Textbody">Ибо одно из великих достижений командного интерфейса POSIX-систем, заценить которое могут в полной мере только те, кто застал времена «черного DOS'а», — это возможность перемещёния внутри командной строки и внесения необходимых изменений в имя команды, ее опции и аргументы. Делается это различными способами.</p>
    <p class="Textbody">Самый привычный и, казалось бы, очевидный способ — использование клавиш перемещёния курсора Left, Right, End и Home, действующих (хотя и не всегда) в командной строке точно так же, как и в каком-нибудь ворд-процессоре для Windows (клавиши Up, Down, PageUp, PageDown зарезервированы для других целей). То есть они позволяют перемещаться на один символ влево и вправо. в начало и конец командной строки. А если добавить сюда ещё клавиши Delete и Backspace, позволяющие удалять символы в позиции курсора или перед ней — то, казалось бы, чего ещё желать?</p>
    <p class="Textbody">Оказывается — есть чего, и самый очевидный способ навигации и редактирования оказывается не самым эффективным. Для начала заметим, что в общем случае привычные клавиши перемещёния курсора и редактирования в POSIX-системах не обязаны работать также, как они делают это в DOS/Windows. Это зависит от многих причин, в том числе и исторических. Ведь POSIX-системы по определению предназначены работать на любых практически машинах (в том числе и на тех, клавиатуры которых клавиш управления курсором просто не имели).</p>
    <p class="Textbody">Однако это не главное — в большинстве Linux-дистрибутивов командная оболочка по умолчанию настраивается так, чтобы пользователь при желании мог использовать привычные ему клавиши. Однако тут-то и оказывается, что плюс к этому оболочка предоставляет ему много более эффективную систему навигации по командной строке и ее редактирования. И это — система управляющих последовательностей, так называемых keybindings. То есть сочетания специальных клавиш, именуемых управляющими, с обычными алфавитно-цифровыми.</p>
    <h3 id="toc73"><a id="RefHeading15881713816058"></a><a id="bkmRefHeading15881713816058"></a><a id="toc72"></a><a id="bkmtoc72"></a><a id="RefHeading4381136957987"></a><a id="bkmRefHeading4381136957987"></a><a id="bkmRefHeading4381136957987"></a><a id="bkmbkmRefHeading4381136957987"></a>Управляющие последовательности</h3>
    <p class="Textbody">Основные управляющиеся клавиши, которые используются в таких последовательностях (и имеются на клавиатурах почти любых машин — как говорят в таких случаях, в любых типах терминалов) — это клавиши Control и Meta.</p>
    <p class="Textbody">Пардон — возразит внимательный читатель, — сколько я ни долблю по клавишам моей PC'шки, но клавиши Meta не замечал. Возражение принято, но: на PC-клавиатурах функции Meta выполняют либо а) нажатие и отпускание клавиши Escape, либо б) нажатие и удерживание клавиши Alt.</p>
    <p class="Textbody">Впрочем, к этой теме я ещё вернусь. А пока достаточно нескольких простых рецептов, практически универсальных для любых командных оболочек в терминалах любых типов.</p>
    <p class="Textbody">Рецепт первый: большая часть управляющих последовательностей состоит из сочетания клавиши Control и алфавитно-цифрового символа. Под сочетанием (или комбинацией, для чего я уже употреблял ранее символ плюс) понимается то, что, удерживая нажатой клавишу Control, мы одновременно нажимаем и какую-нибудь литерную или цифровую.</p>
    <p class="Textbody">Так, действие клавишной комбинации Control+F (от Forward — в большинстве случаев регистр алфавитной клавиши управляющей последовательности значения не имеет) эквивалентно нажатию клавиши Right — это перемещёние на один символ вправо, комбинации Control+B (от Back) — нажатию Left (перемещёние на один символ влево). Комбинации Control+A и Control+E действуют аналогично Home и End, перемещая курсор в начало и конец командной строки, соответственно, Ну а с помощью комбинаций Control+D и Control+H можно удалить единичный символ в позиции курсора или перед ней (также, как и клавишами Delete и Backspace, соответственно).</p>
    <p class="Textbody">Предвижу резонный вопрос: а какие достоинства в комбинации клавиш Control+Что_то по сравнению с элементарными End или Left? Конечно, одно достоинство — очевидно: при массовом вводе команд (а также, забегая вперед, замечу — и любых иных наборов символов, от исходных текстов до романов), при использовании keybindings руки не отрываются от основной (алфавитно-цифровой) части клавиатуры. И в итоге, по приобретении некоторого минимального навыка, дело движется ну гораздо быстрее. Обосновать тестами не могу (тут какая-нибудь физиометрия понадобится), но не верящим — предлагаю попробовать.</p>
    <p class="Textbody">Главное же преимущество клавиатурных последовательностей перед стандартными навигационными клавишами — много более широкая их функциональность. Я не случайно начал этот параграф с упоминания командных «слов» — это, наряду с единичными символами, также навигационные (и, добавлю, редакционные) единицы командной строки. То есть управляющие последовательности позволяют при навигации и редактировании оперировать не только единичными символами, но и целыми словами.</p>
    <p class="Textbody">Например, комбинация Meta+F смещает курсор на одно «слово» вперед, та же Meta в сочетании с B — на одно слово назад, и так далее. Прошу обратить внимание: действие алфавитной клавиши в комбинации с Meta сходно по смыслу ее сочетанию с клавишей Control, но как бы «усилено»: последовательность Meta+D уничтожает не символ в позиции курсора, как это было бы для D в сочетании с Control, а все командное «слово».</p>
    <p class="Textbody">Рассматривать ключевые последовательности подробно здесь я не буду: детали их действия зависят от командной оболочки и ее настроек. Отмечу только два существенных обстоятельства. Первое: keybindings предоставляют пользователю полный комплекс приемов для любых действий в командной строке — вплоть до преобразования регистров уже введенных символов и «слов» (из нижнего в верхний и наоборот), «перетасовки» символов в команде или ее аргументах, и так далее.</p>
    <p class="Textbody">Значение управляющих последовательностей не ограничивается командной строкой — большинство популярных в POSIX-мире текстовых редакторов, от простых Nano или joe до грандиозного vim и монструозного emacs. построены по тому же принципу. Так что навыки, полученные при работе с keybindings, например, в Bash, весьма поспособствуют виртуозному освоению любого из этих инструментов.</p>
    <p class="Textbody">И второе — действие ключевых последовательностей, как правило. не зависит не только от типа терминала и физического устройства клавиатуры, но и от ее раскладки — при переключении на кириллицу они будут работать столь же справно, как и в латинице.</p>
    <h3 id="toc74"><a id="RefHeading15901713816058"></a><a id="bkmRefHeading15901713816058"></a><a id="toc73"></a><a id="bkmtoc73"></a><a id="RefHeading4401136957987"></a><a id="bkmRefHeading4401136957987"></a><a id="bkmRefHeading4401136957987"></a><a id="bkmbkmRefHeading4401136957987"></a>История команд</h3>
    <p class="Textbody">Возможности навигации и редактирования строки особенно ярко проявляются в сочетании с другой замечательной особенностью, предоставляемой командными оболочками — доступом к истории команд. То есть: раз введенная в строке команда не уходит в небытие после исполнения, а помещается в специальный буфер памяти. Который, как и все в Unix'ах, именуется весьма незатейливо — буфер истории команд. Откуда команда (со всеми её опциями и аргументами) может быть извлечена для повторного использования. Или — для редактирования и исполнения в новой реинкарнации.</p>
    <p class="Textbody">Буфер истории команд сохраняется в течении всего сеанса работы. Однако в большинстве случаев командные оболочки настраиваются так, что по выходе из сеанса буфер истории сохраняется в специальном файле в домашнем каталоге пользователя, и таким образом его содержимое оказывается доступным при следующем запуске шелла. Имя этого файла может быть различным в разных оболочках, но обычно включает компонент history (в Bash — ~/.bash_history).Так что, можно сказать, что введенным нами командам суждена вечная жизнь.</p>
    <p class="Textbody">Конечно, не совсем вечная. И размер буфера истории команд, и количество строк в файле истории — величины конечные. Так что, если установленный предел превышен, то старые команды вытесняются более новыми. Однако и величину буфера, и количество строк в файле истории можно установить любыми. Разумеется, в разумных пределах — не знаю, существует ли принципиальное ограничение на их размер, за исключением объёма памяти и дискового пространства. А если учесть, что и из буфера, и из памяти с помощью соответствующих настроек (со временем я расскажу, каких) можно исключить дубликаты и ещё кое-какой мусор — то мое заявление о вечной жизни команд не выглядит столь уж преувеличенным.</p>
    <p class="Textbody">Универсальное средство доступа к буферу истории команд — специальная команда, встроенная во все шеллы, таковой поддерживающие — history (в большинстве дистрибутивов Linux она по умолчанию имеет псевдоним — h). Данная без опций, эта команда выводит полный список команд в их исторической (издревле к современности) последовательности, или некоторое количество команд, определенных соответствующими настройками (о которых будет говориться позднее).</p>
    <p class="Textbody">В качестве опции можно указать желаемое количество одновременно выведенных команд. Например, директива</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ history -2</span> </p>
    <p class="Textbody">выведет две последние команды из буфера истории вместе с их номерами:</p>
    <p class="Textbody"><span style="background-color:#dddddd">1023  joe shell.html</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">1024  less ~/.zshrc</span> </p>
    <p class="Textbody">Любая из команд в буфере истории может быть повторно запущена на исполнение. Для этого достаточно набрать в командной строке символ ! (восклицательный знак) и затем, без пробела — номер команды в списке буфера. Например,</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ !1023</span> </p>
    <p class="Textbody">для приведенного выше примера повторно откроет файл shell.html в текстовом редакторе joe.</p>
    <p class="Textbody">Другой способ доступа к командам из буфера истории — комбинации клавиш Control+P и Control+N, служащие для последовательного его просмотра (как бы «пролистывания») назад и, соответственно, вперед (разумеется, если есть куда). Они дублируются клавишами управления курсором Up и Down (назад и вперед, соответственно). Кроме того, последовательности Meta+&lt; и Meta+&amp;rt; обеспечивают переход к первой и последней команде в буфере истории.</p>
    <p class="Textbody">Любая извлеченная (с помощью стрелок или управляющими последовательностями) из буфера истории в текущую строку команда может быть повторно запущена на исполнение — нажатием клавиши Enter или дублирующей ее комбинацией Control+M. причём предварительно ее можно отредактировать — изменить опции, или аргументы, — точно так же, как и только что введенную.</p>
    <h3 id="toc75"><a id="RefHeading15921713816058"></a><a id="bkmRefHeading15921713816058"></a><a id="toc74"></a><a id="bkmtoc74"></a><a id="RefHeading4421136957987"></a><a id="bkmRefHeading4421136957987"></a><a id="bkmRefHeading4421136957987"></a><a id="bkmbkmRefHeading4421136957987"></a>Поиск в истории</h3>
    <p class="Textbody">Во всех современных «развитых» шеллах предусмотрены средства поиска команды в буфере истории — простым перебором (обычно Meta+P — назад и Meta+N — вперед).</p>
    <p class="Textbody">Впрочем, не смотря на громкое название, обычный поиск ничем практически не отличается от пролистывания исторического списка курсорными стрелками. Что при обширной истории команд может быть весьма утомительным. И потому для ее облегчения предусмотрена такая интересная возможность, как наращиваемый поиск (incremental search) нужной команды в буфере истории по одному (или нескольким) из составляющих ее символов.</p>
    <p class="Textbody">Выполняется инкрементный поиск так: после нажатия (при пустой командной строке) клавишной комбинации Control+R появляется предложение ввести алфавитный символ (или — последовательность символов произвольной длины), заведомо входящий в состав требуемой команды:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ bck-i-search: _</span> </p>
    <p class="Textbody">Ввод такого символа выведет последнюю из команд, его содержащих. При этом введенный символ будет отмечен знаком курсора. Он не обязан входить в имя команды, но может быть составляющим ее опций или аргументов (имени файла или пути к нему, например). Следующее нажатие Control+R зафиксирует курсор на предыдущем символе, в пределах этой же или более ранней по списку команды, и т.д. Однако вместо этого в строке поиска можно вводить дополнительные символы, детализирующие условия поиска команды (или — ее опций и аргументов).</p>
    <p class="Textbody">Процедуру поиска можно продолжать вплоть до достижения требуемого результата — то есть нахождения той команды, которая нужна именно сейчас. Нажатие клавиши Enter в любой из этих моментов запускает найденную (то есть помещённую в командную строку) команду на исполнение, с завершением поиска. Поиск обрывается также и нажатием комбинации Control+C. Перед запуском найденная команда может быть отредактирована стандартными средствами — с использованием управляющих последовательностей.</p>
    <h3 id="toc76"><a id="RefHeading15941713816058"></a><a id="bkmRefHeading15941713816058"></a><a id="toc75"></a><a id="bkmtoc75"></a><a id="RefHeading4441136957987"></a><a id="bkmRefHeading4441136957987"></a><a id="bkmRefHeading4441136957987"></a><a id="bkmbkmRefHeading4441136957987"></a>Регулярные выражения</h3>
    <p class="Textbody">Как известно, все пользователи-POSIX'ивисты должны быть в обязательном порядке привержены одному из семи смертных грехов. И грех этот — леность, можно сказать, показатель профессиональной пригодности линуксоида. В соответствие со своей леностью разработчики POSIX-систем придумывают способы, как бы им минимизировать свои усилия. А применители из лени изощряются в использовании этих приемов на практике. В частности — в том, как свести к минимуму набор в командной строке.</p>
    <p class="Textbody">Собственно говоря, этой цели служили почти все приемы, описанные выше. Осталось осветить немногое. А именно — регулярные выражения, реализуемые с помощью т.н. специальных символов (или метасимволов).</p>
    <p class="Textbody">Элементарная, и весьма частая, в духе школьных, задача: из каталога dir1 требуется скопировать все файлы в каталог dir2. Так неужели все они должны быть перечислены в качестве аргументов команды cp? Нет, нет, и ещё раз нет. Ибо для этой цели придуманы шаблоны имен файлов. Самый часто используемый из них — специальный символ * (вроде бы я о нем уже говорил?). Он подменяет собой любое количество любых символов (в том числе — и нулевое, то есть отсутствие символов вообще). То есть для решения предложенной задачи нам достаточно дать команду:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cp dir1/* dir2</span> </p>
    <p class="Textbody">Чуть усложним условия: к копированию из dir1 предназначены не все файлы, а только html-документы, традиционно имеющие суффикс html. Решение от этого не становится сложнее:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cp dir1/*html dir2</span> </p>
    <p class="Textbody">Однако тут можно вспомнить, что html-документы могут иметь и расширение htm. Не пропустим ли мы их таким образом при копировании? Таким — безусловно, пропустим. Однако нам на помощь придет другой шаблон — символ ?. А соответствует он любому единичному символу (или — его отсутствию, т.е. символу null). И значит, если команда из примера будет модифицирована таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cp dir1/*htm? dir2</span> </p>
    <p class="Textbody">то она гарантированно охватит все возможные маски html-документов.</p>
    <p class="Textbody">Вроде все хорошо. Однако нет: из каталога dir1 нам нужно скопировать только три определенных файла — file1, file2, file3. Не придется ли каждый из них указывать в командной строке с полным путем (а ведь они могут быть и в глубоко вложенном подкаталоге типа dir1/dir11/dir111)? Все равно не придется, на столь хитрую... постановку задачи у нас есть прием с левой резьбой — символы группировки аргументов, обозначаемые фигурными скобками. Что на практике выглядит так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cp path/{file1,file2,file3} dir2</span> </p>
    <p class="Textbody">И приведет к единоразовому копированию всех трех файлов в каталог dir2. Заметим, что сгруппированные аргументы разделяются запятыми без пробелов. И ещё: в оболочке Bash группируемые аргументы придется полностью вводить руками. Но вот в Zsh на них распространяется возможность автодополнения, да и запятая после каждого имени появляется автоматически (и столь же автоматически исчезает при закрытии фигурной скобки).</p>
    <p class="Textbody">Группировка аргументов может быть сколь угодно глубоко вложенной. Так, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mkdir -p dir1/{dir11/{dir111,dir112},dir12/{dir121,dir122}}</span> </p>
    <p class="Textbody">в один заход создаст трехуровневую структуру каталогов внутри текущего — если только не забыть про опцию -p, которая предписывает создавать промежуточные подкаталоги в случае их отсутствия.</p>
    <p class="Textbody">И ещё несколько примеров. Регулярное выражение для диапазона — то есть вида [...], подменяет любой из символов, заключенных в квадратные скобки. Символы эти могут даваться списком без пробелов (например, выражение [12345] соответствует любому символу от 1 до 5) или определяться в диапазоне, крайние значения которого разделяются дефисом без пробелов (эквивалентное первому выражение — [1-5]). Кроме того, символ ^, предваряющий список или диапазон, означает отрицание: выражение [^abc] подменяет любой символ, исключая символы a, b и c.</p>
    <p class="Textbody">Последние примеры регулярных выражений могут показаться надуманными. Однако представим. что в том же каталоге dir1, кроме html-документов, содержатся также файлы изображений в различных форматах — GIF, JPEG, TIFF и так далее (традиционно имеющие одноименные расширения). И все они должны быть скопированы в каталог dir2, а вот как раз html-файлы нам в данный момент без надобности. No problemas, как говорят у них:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cp dir1/*[^html] dir2</span> </p>
    <p class="Textbody">И в каталоге dir2 окажется все содержимое каталога dir1, за исключением html-файлов.</p>
    <h3 id="toc77"><a id="RefHeading15961713816058"></a><a id="bkmRefHeading15961713816058"></a><a id="toc76"></a><a id="bkmtoc76"></a><a id="RefHeading4461136957987"></a><a id="bkmRefHeading4461136957987"></a><a id="bkmRefHeading4461136957987"></a><a id="bkmbkmRefHeading4461136957987"></a>Экранирование</h3>
    <p class="Textbody">Из приведённых примеров можно видеть, что метасимволы, образующие регулярные выражения, интерпретируются командной оболочкой особым образом, не так, как обычные алфавитно-цифровые символы, составляющие, скажем, имена файлов.</p>
    <p class="Textbody">В то же время собственно POSIX-системы накладывают на имена файлов очень мало ограничений. И в принципе система не запретит вам создать файл с именем, содержащим метасимволы. Другое дело, что работать с таким образом именованными файлами может быть сложно — командная оболочка будет пытаться интерпретировать их в соответствии с правилами для регулярных выражений.</p>
    <p class="Textbody">Конечно, использовать метасимволы в именах файлов весьма не рекомендуется. Однако а) возможны элементарные ошибки при наборе, и б) файлы, полученные при обмене с другими операционными системами (сами знаете. какими), могут иметь довольно непривычный (и, я даже сказал бы, неприличный) вид.</p>
    <p class="Textbody">Вспомним, что MS Word в качестве имени файла спокойно берёт первую фразу документа. А если это — вопрос? И тогда завершающий имя символ ? будет в шелле интерпретироваться как шаблон, а не как элемент имени. Думаю, не нужно обладать очень развитым воображением, чтобы представить последствия. Что делать в таких ситуациях? Для их разрешения резонными людьми придумано было понятие экранирования.</p>
    <p class="Textbody">Начнём с первого примера использования экранирования — разрыва длинных строк. Командные директивы, с многочисленными их опциями, особенно в полной форме, и аргументами могут оказаться весьма длинными, не укладывающимися в пределы экранной строки. Правда, обычно командная оболочка по умолчанию настраивается с разрешением так называемого word wrapping'а (то есть переноса «слов» команды без обрыва строки — последнее, как мы помним, достигается нажатием клавиши Enter или комбинации Control+M и приводит к немедленному исполнению введённой команды. Если ввод ее не окончен — последует сообщение об ошибке). Однако перенос «слов» при этом происходит, как бог на душу положит. И в результате командная директива теряет читабельность и становится сложной для понимания.</p>
    <p class="Textbody">Тут-то и приходит на помощь понятие экранирования, упомянутое абзацем выше. Знак экранирования — обратный слэш (\), — превращает символ, имеющий специальное значение, например, упоминавшийся ранее шаблон в именах файлов — *, в самую обычную звездочку. А раз конец строки — тоже символ, хотя и специальный, то и он доступен для экранирования. Так что если завершить введённый фрагмент команды обратным слэшем (некоторые оболочки требуют предварить его пробелом, и лучше так и делать, хотя в Bash или Zsh пробел не обязателен), после чего нажать Enter, то вместо попытки исполнения будет образована новая строка. в которой можно продолжать ввод. Вид приглашения к вводу при этом изменится — это будет так называемое вторичное приглашение командной строки, и его представление настраиваемо, также как и вид приглашения первичного.</p>
    <p class="Textbody">Возвращаемся к экранированию обратным слэшем. Действие его распространяется только на непосредственно следующий за ним символ. Если символы, могущие быть воспринятые как специальные, идут подряд, каждый из них должен предваряться обратным слэшем.</p>
    <p class="Textbody">У обратного слэша есть ещё одна интересная особенность — я назвал бы ее инвертированием специального значения символов. Для примера: некая последовательность цифр (например, 033), введенная в командной строке, будет воспринята как набор обычных символов. Однако она же может выступать как код какого-либо символа (в частности, 033 — код символа Escape в восьмеричной системе счисления). И подчас возникает необходимость ввода таких кодов (тот же код для Escape, скажем, затруднительно ввести каким-либо иным образом).</p>
    <p class="Textbody">И вот тут обратный слэш проявляет свое инвертирующее действие: последовательность \033 будет восприниматься уже не как набор символов, а как код символа Escape (обратим внимание, что тут достаточно единичного слэша). Непосредственно в командной строке такой способ инвертированного экранирования, по понятным причинам, обычно не используется, но находит широкое применение в сценариях.</p>
    <h3 id="toc78"><a id="RefHeading15981713816058"></a><a id="bkmRefHeading15981713816058"></a><a id="toc77"></a><a id="bkmtoc77"></a><a id="RefHeading4481136957987"></a><a id="bkmRefHeading4481136957987"></a><a id="bkmRefHeading4481136957987"></a><a id="bkmbkmRefHeading4481136957987"></a>О кавычках</h3>
    <p class="Textbody">Есть и экраны, распространяемые на все, что заключено внутри них. Это — кавычки, двойные и одинарные: большая часть символов между ними утрачивает свое специальное значение. Но не все: в двойных кавычках сохраняют специальное значение метасимволы $ и \, а также обратные кавычки (`), о назначении которых я скажу чуть позже. То есть в них сохраняется возможность, с одной стороны, получения значений переменных (как мы помним, с помощью $ИМЯ). А с другой стороны, если нам требуется дать символ бакса в его прямом и привычном значении, у нас есть возможность заэкранировать его обратным слэшем. И если потребуется вывести на экран сообщение «с вас, уважаемый, пятьсот баксов», то это можно сделать таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ echo "с вас, уважаемый, \$500"</span> </p>
    <p class="Textbody">ещё одно широко применяемое использование двойных кавычек — экранирование пробелов, предотвращающих разбиение аргументов команды на отдельные «слова». Правда, в случае с командой echo это, как правило, не требуется (хотя настоятельно рекомендуется экранировать ее аргумент таким образом). Однако представьте, что в качестве аргумента команды копирования и перемещёния выступает файл, переписанный с Windows-машины. Ведь там пробелы в именах — вещь обычная. Тут-то экранирование двойными кавычками и придется к месту.</p>
    <p class="Textbody">Из сказанного понятно, почему двойные кавычки именуются ещё неполными, или не строгими — они все же допускают внутри себя использование символов со специальными значениями. В противоположность им, кавычки одинарные носят имя строгих, или полных. Потому что между ними утрачивают специальное значение все метасимволы, кроме их самих — в том числе и символ единичного экранирования. В итоге они используются там, где гарантированно требуется отсутствие специальных символов. Если вы помните, мы применили строгие кавычки при установке псевдонимов. Они же часто оказываются обязательными при определении переменных.</p>
    <p class="Textbody">Завершая тему экранирования, осталось сказать только об обратных кавычках. Их функция очень узка: они служат для экранирования команд. То есть, скажем, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ echo date</span> </p>
    <p class="Textbody">в полном соответствие со своим именем, просто выведет нам собственный аргумент:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">date</span> </p>
    <p class="Textbody">Однако если аргумент команды закрыть обратными кавычками, то date будет воспринято как имя команды, подлежащей исполнению. И результат этого исполнения (то есть текущая дата и время — а именно для их получения и предназначена команда date) будет замещать имя команды в выводе echo:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ echo `date`</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Втр Дек 16 11:45:12 MSK 2003</span> </p>
    <p class="Textbody">Если вспомнить, что обратные кавычки сохраняют свое специальное значение внутри кавычек двойных, становится ясной польза от их применения: они незаменимы в тех случаях, когда требуется вывод результатов работы одной команды внутри другой. К как в нашем примере с выводом даты, если его (вывод) следует включить в некое выдаваемое командой echo сообщение.</p>
    <p class="Textbody">Конечно, в описанном случае добиться той же цели можно было бы гораздо легче — просто командой date. Однако представьте, что у нас возникло желание одновременно и получить сведения о количестве пользователей в системе (для чего предназначена команда who). Тут-то и выясняется. что проще всего это сделать командой типа следующей:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ echo "На момент `date` в системе</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        зарегистрированы `who`"</span> </p>
    <p class="Textbody">Ответом на что будет сообщение, подобное тому, что часто можно наблюдать на главной странице многих сайтов:</p>
    <p class="Textbody"><span style="background-color:#dddddd">На момент Сб. дек. 20 06:05:56 MSK 2014 в системе</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">зарегистрированы alv      tty8         2014-12-15 00:34 (:0)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alv      pts/1        2014-12-15 00:34 (:0)</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alv      pts/5        2014-12-19 09:37 (:0)</span> </p>
    <p class="Textbody">А теперь последнее, чем и закроем тему регулярных выражений вообще. В этом разделе рассматривалось использование метасимволов в командной оболочке (конкретно, в данном случае. в Dash, Bash и Zsh). В других оболочках применение метасимволов и условия их экранирования могут несколько отличаться. И к тому же многие запускаемые из строки шелла команды могут иметь свои правила построения регулярных выражений. Так что в итоге их форма определяется сочетанием особенностей конкретной оболочки и команды, из неё запущенной. Все это при необходимости будет оговариваться в дальнейшем.</p>
    <p class="Textbody">А пока переходим к рассмотрению командных конструкций — одной из тех особенностей CLI, которая определяет мощь и универсальность этого интерфейса.</p>
    <h3 id="toc79"><a id="RefHeading16001713816058"></a><a id="bkmRefHeading16001713816058"></a><a id="toc78"></a><a id="bkmtoc78"></a><a id="RefHeading4501136957987"></a><a id="bkmRefHeading4501136957987"></a><a id="bkmRefHeading4501136957987"></a><a id="bkmbkmRefHeading4501136957987"></a>Вводные слова о командных конструкциях</h3>
    <p class="Textbody">Надеюсь, из того, что было рассказано на предшествующих страницах, посвящённых CLI, читателю стало ясно, что подавляющее большинство команд в POSIX-системах очень просты по сути и предназначены для выполнения какого-либо одного элементарного действия.</p>
    <p class="Textbody">То есть команда cp умеет только копировать файлы, команда rm — только удалять их, но зато делают они это хорошо. Подчас — через чур хорошо, что мог ощутить на себе каждый, кому «посчастливилось» по ошибке выдать директиву вроде</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ rm -Rf *</span> </p>
    <p class="Textbody">Для тех, кто не испытал этого волнительного ощущения, поясню: результатом будет полное и безвозвратное уничтожение всех файлов от текущего каталога вниз (включая подкаталоги любой степени вложенности).</p>
    <p class="Textbody">А если задать ту же команду от лица администратора, то, в зависимости от текущего положения на файловом древе, можно нечувствительно удалить что угодно, вплоть до системы целиком: одна из причине, почему повседневные действия не следует выполнять под root'ом.</p>
    <p class="Textbody">Собственно, разделение любой задачи на серию элементарных операций — это и есть основной принцип работы в POSIX-системах, тот самый пресловутый Unix-way, о котором столько говорят его приверженцы.</p>
    <p class="Textbody">Однако вслед за этапом решительного размежевания (эх, неистребимы в памяти нашего поколения слова товарища Ленина) должен наступить этап объединения, как за анализом явления следует синтез эмпирических данных о нём. И целям такого объединения служат командные конструкции.</p>
    <p class="Textbody">Командные конструкции — очень важный компонент интерфейса командной строки. Они позволяют объединять несколько команд воедино и выполнять различные команды последовательно или параллельно. Для этого служат специальные символы — операторы: фонового режима, объединения, перенаправления и конвейеризации.</p>
    <h3 id="toc80"><a id="RefHeading16021713816058"></a><a id="bkmRefHeading16021713816058"></a><a id="toc79"></a><a id="bkmtoc79"></a><a id="RefHeading4521136957987"></a><a id="bkmRefHeading4521136957987"></a><a id="bkmRefHeading4521136957987"></a><a id="bkmbkmRefHeading4521136957987"></a>Совместное выполнение команд</h3>
    <p class="Textbody">Простейшая командная конструкция — это выполнение команды в фоновом режиме, что вызывается вводом символа амперсанда после списка опций и (или аргументов):</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ command [options] [arguments] &amp;</span> </p>
    <p class="Textbody">В Bash и Zsh пробел перед символом амперсанда не обязателен, но в некоторых шеллах он требуется, и потому лучше возвести его ввод (как и во всех аналогичных случаях) в ранг привычки. После этого возвращается приглашение командной строки и возможен ввод любых других команд (в том числе и фоновых). Команды для параллельного исполнения можно задать и в той же строке:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ command1 &amp; command2 &amp; ... &amp; commandN</span> </p>
    <p class="Textbody">В результате все команды, перечисленные в строке, кроме той, что указана последней, будут выполняться в фоновом режиме.</p>
    <p class="Textbody">Существуют и конструкции для последовательного выполнения команд. Так, если ряд команд разделен в строке символом точки с запятой (;)</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ command1 ; command2 ; ... ; commandN</span> </p>
    <p class="Textbody">то сначала будет выполнена команда command1, затем — command1 и так далее. Молчаливо предполагается, что каждая из этих команд может иметь любое количество опций и аргументов. И, опять-таки, обрамление ; пробелами не обязательно во многих командных оболочках. Сами по себе команды не обязаны быть связанными между собой каким-либо образом — в сущности, это просто эквивалент последовательного их ввода в командной строке:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ command1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">$ command2</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">и так далее. При этом первая команда может, например, копировать файлы, вторая — осуществлять поиск, третья — выполнять сортировку, или другие действия. Очевидно, что в общем случае выполнение последующей команды не зависит от результатов работы предшествующей.</p>
    <p class="Textbody">Однако возможна ситуация, когда результаты предыдущей команды из такой конструкции используются в команде последующей. В этом случае ошибка исполнения любой составляющей команды, кроме последней, делает невозможным продолжение работы всей конструкции. Что само по себе было бы ещё полбеды — однако в некоторых ситуациях исполнение последующей команды возможно только при условии успешного завершения предыдущей.</p>
    <p class="Textbody">Характерный пример — сборка программы из ее исходных текстов, включающая три стадии — конфигурирование, собственно компиляцию и установку собранных компонентов. Что обычно выполняется последовательностью из трёх команд:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ ./configure</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">$ make</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ make install</span> </p>
    <p class="Textbody">Ясно, что если конфигурирование завершилось ошибкой, то компиляция начаться не сможет и, соответственно, потом нечего будет устанавливать. И потому объединение их в последовательную конструкцию вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ./configure ; make ; make install</span> </p>
    <p class="Textbody">может оказаться нецелесообразным.</p>
    <p class="Textbody">Однако для предотвращения таких ситуаций в конструкции из взаимосвязанных команд существует другой оператор, обозначаемый удвоенным символом амперсанда — &amp;&amp;. Он указывает, что последующая команда конструкции должна исполняться только в том случае, если предыдущая завершилась успешно:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ./configure &amp;&amp; make &amp;&amp; make install</span> </p>
    <p class="Textbody">На практике обе приведённые в качестве примера конструкции дадут один и тот же результат — разумеется, если все составляющие их команды будут выполнены без ошибок. Однако в ряде иных случаев различие между этими конструкциями может быть существенным.</p>
    <p class="Textbody">Впрочем, предусмотрена и командная конструкция, в которой последующей команде предписано исполняться в том и только в том случае, если предыдущая команда завершилась неудачно. Она имеет вид</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ command1 || command2</span> </p>
    <p class="Textbody">и может служить, в частности, для вывода сообщений об ошибках.</p>
    <h3 id="toc81"><a id="RefHeading16041713816058"></a><a id="bkmRefHeading16041713816058"></a><a id="toc80"></a><a id="bkmtoc80"></a><a id="RefHeading4541136957987"></a><a id="bkmRefHeading4541136957987"></a><a id="bkmRefHeading4541136957987"></a><a id="bkmbkmRefHeading4541136957987"></a>Перенаправление</h3>
    <p class="Textbody">Следующая командная конструкция — это так называемое перенаправление ввода/вывода. Чтобы понять,что это такое, нужно помнить две вещи:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">любая команда получает данные для своей работы (например, список опций и аргументов) со стандартного устройства ввода (которым в первом приближении будем считать клавиатуру), а результаты своей работы представляет на стандартном устройстве вывода (коим договоримся считать экран монитора); </p>
      </li>
      <li>
        <p class="Textbody">POSIX-системах любое устройство — не более чем имя специального файла, именуемого файлом устройства. </p>
      </li>
    </ol>
    <p class="Textbody">Таким образом, ничто не запрещает нам подменить специальный файл устройства ввода или устройства вывода любым иным файлом (например, обычным текстовым). Откуда и будут в этом случае браться входные данные или куда будет записываться вывод команды.</p>
    <p class="Textbody">Перенаправление вывода команды обозначается следующим образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ command &gt; filename</span> </p>
    <p class="Textbody">или</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ command &gt;&gt; filename</span> </p>
    <p class="Textbody">В первом случае (одиночный символ &gt;) вывод команды command образует содержимое нового файла с именем filename, не появляясь на экране. Или, если файл с этим именем существовал ранее, то его содержимое подменяется выходным потоком команды (точно также, как при копировании одного файла в другой, уже существующий). Почему такое перенаправление называется замещающим (или перенаправлением в режиме замещёния).</p>
    <p class="Textbody">Во втором же случае (двойной символ &gt;&gt;) происходит добавление вывода команды command в конец существующего файла filename (при отсутствии же его в большинстве случаев просто образуется новый файл). И потому это называется присоединяющим перенаправлением, или перенаправлением в режиме присоединения.</p>
    <p class="Textbody">Перенаправление ввода выглядит так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ command &lt; filename</span> </p>
    <p class="Textbody">Простейший случай перенаправления вывода — сохранение результата исполнения команды в обычном текстовом файле. Например, конструкция</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls dir1 &gt; list</span> </p>
    <p class="Textbody">создаст файл, содержанием которого будет список файлов каталога dir1. А в результате выполнения конструкции</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls dir2 &gt;&gt; list</span> </p>
    <p class="Textbody">к этому списку добавится и содержимое каталога dir2.</p>
    <p class="Textbody">При перенаправлении ввода команда получает данные для своей работы из входящего в командную конструкцию файла. Например, конструкция</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sort &lt; list</span> </p>
    <p class="Textbody">выведет на экран строки файла list, отсортированных в порядке возрастания значения ASCII-кода первого символа, а конструкция</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sort -r &lt; list</span> </p>
    <p class="Textbody">осуществит сортировку строк того же файла в порядке, обратном алфавитному (вернее, обратном порядку кодов символов, но это нас в данном случае не волнует).</p>
    <p class="Textbody">В одной конструкции могут сочетаться перенаправления ввода и вывода, как в режиме замещёния, так и в режиме присоединения. Так, конструкция</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sort -r &lt; list &gt; list_r</span> </p>
    <p class="Textbody">не только выполнит сортировку строк файла list (это — назначение команды sort) в обратном алфавитному порядке (что предписывается опцией -r, происходящей в данном случае от reverce), но и запишет ее результаты в новый файл list_r, а конструкция</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sort -r &lt; list &gt;&gt; list</span> </p>
    <p class="Textbody">добавит по-новому отсортированный список в конец существующего файла list.</p>
    <h3 id="toc82"><a id="RefHeading16061713816058"></a><a id="bkmRefHeading16061713816058"></a><a id="toc81"></a><a id="bkmtoc81"></a><a id="RefHeading4561136957987"></a><a id="bkmRefHeading4561136957987"></a><a id="bkmRefHeading4561136957987"></a><a id="bkmbkmRefHeading4561136957987"></a>Конвейеры</h3>
    <p class="Textbody">Возможности построения командных конструкций не ограничиваются перенаправлением ввода/вывода: результаты работы одной команды могут быть переданы для обработки другой команде. Это достигается благодаря механизму программных каналов (pipe) или конвейеров — последний термин лучше отражает существо дела.</p>
    <p class="Textbody">При конвейеризации команд стандартный вывод первой команды передается не в файл, а на стандартный ввод следующей команды. Простой пример такой операции — просмотр списка файлов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls -l | less</span> </p>
    <p class="Textbody">Перенаправление вывода команды ls, то есть списка файлов, который при использовании полного формата записи (опция -l) может занимать многие экраны, на ввод команды less позволяет просматривать результат с ее помощью постранично или построчно в обоих направлениях.</p>
    <p class="Textbody">Конвейеризация команд может быть сколь угодно длинной. Возможно также объединение конвейеризации команд и перенаправления в одной конструкции. Кроме того, команды в конструкции могут быть сгруппированы с тем, чтобы они выполнялись как единое целое. Для этого группа команд разделяется символами ; и пробелами, как при последовательном выполнении команд, и заключается в фигурные скобки. Так, если нам требуется перенаправить вывод нескольких команд в один и тот же файл, вместо неуклюжей последовательности типа</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ command1 &gt; file ; command2 &gt;&gt; file ; ... ; commandN &gt;&gt; file</span> </p>
    <p class="Textbody">можно прибегнут к более изящной конструкции:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ { command1 ; command2 ; ... ; commandN } &gt; file</span> </p>
    <p class="Textbody">Как и многие из ранее приведённых примеров, этот может показаться надуманным. Однако представьте, что вам нужно создать полный список файлов вашего домашнего каталога, разбитый по подкаталогам, да ещё и с комментариями, в каком подкаталоге что находится. Конечно, можно вывести состав каждого подкаталога командой ls, слить их воедино командой cat (она предназначена, в частности, и для объединения — конкатенации, — файлов, и речь о ней будет позже), загрузить получившееся хозяйство в текстовый редактор или ворд-процессор, где добавить необходимые словеса. А можно — обойтись единой конструкцией:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ { echo "List of my files" ;  &gt; echo "My text" ;</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        ls text/* ;  &gt; echo "My images" ;</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        ls images/* ;  &gt; echo "My audio" ;</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        ls audio/* ;  &gt; echo "My video" ;</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        ls video/* } &gt; my-filelist</span> </p>
    <p class="Textbody">И в результате получить файл такого (условно) содержания, которое мы для разнообразия просмотрим с помощью только что упомянутой команды cat (благо и для просмотра содержимого файлов она также пригодна):</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ cat my-filelist</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">List of my files</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">My text</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">text/text1.txt text/text2.txt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">My images</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">images/img1.tif images/img2.tif</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">My audio</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">audio/sing1.mp3 audio/sing2.mp3</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">My video</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">video/film1.avi video/film2.avi</span> </p>
    <h3 id="toc83"><a id="RefHeading16081713816058"></a><a id="bkmRefHeading16081713816058"></a><a id="toc82"></a><a id="bkmtoc82"></a><a id="RefHeading4581136957987"></a><a id="bkmRefHeading4581136957987"></a><a id="bkmRefHeading4581136957987"></a><a id="bkmbkmRefHeading4581136957987"></a>Понятие о фильтрах</h3>
    <p class="Textbody">С понятием командных конструкций тесно связано понятие программ-фильтров. Это — команды, способные принимать на свой ввод данные с вывода других команд, производить над ними некоторые действия и перенаправлять свой вывод (то есть результат модификации полученных данных) в файлы или далее по конвейеру — другой команде.</p>
    <p class="Textbody">Программы-фильтры — очень эффективное средство обработки текстов, и в своё время мы к ним вернемся для подробного изучения. Пока же важно отметить, что в качестве фильтров могут работать не все команды. Например, команды find или grep фильтруют имена файлов или фрагменты их содержимого, а команда ls фильтром не является.</p>
    <h3 id="toc84"><a id="RefHeading16101713816058"></a><a id="bkmRefHeading16101713816058"></a><a id="toc83"></a><a id="bkmtoc83"></a><a id="RefHeading4601136957987"></a><a id="bkmRefHeading4601136957987"></a><a id="bkmRefHeading4601136957987"></a><a id="bkmbkmRefHeading4601136957987"></a>Сценарии оболочки</h3>
    <p class="Textbody">Наш затянувшийся разговор о командах и командном интерфейсе подходит к концу. И в заключение этого раздела — ещё немного терпения. Потому что было бы несправедливо не уделить чуть-чуть места тому, что придает командному интерфейсу POSIX-систем его несравненную гибкость и универсальность. Заодно способствуя закоснению пользователя в смертном грехе лености. Итак — слово о сценариях оболочки.</p>
    <p class="Textbody">В самом начале я обмолвился, что шелл — это не просто среда для ввода единичных команд и командных конструкций, но и ещё интерпретатор собственного языка программирования. Так вот, сценарии оболочки, именуемые также скриптами, — это и есть программы, написанные на этом языке.</p>
    <p class="Textbody">Только не заподозрите меня в гнусном намерении учить вас программерству. Господь борони, и в мыслях не держал (тем паче, что и сам-то этим ремеслом не владею в должной для обучения других степени). Нет, просто на последующих страницах нам то и дело придётся рассматривать кое-какие примеры готовых сценариев, а подчас и пытаться создавать их собственноручно. Ибо занятие это в элементарном исполнении навыков программирования не требует вообще.</p>
    <p class="Textbody">В самом простом случае сценарий — это просто одна или несколько команд или (и) командных конструкций с необходимыми опциями и аргументами, сохраненные в виде обычного именованного текстового файла. И предназначены они в первую очередь для автоматизации часто исполняемых рутинных операций, в частности, ввода длинных последовательностей в командной строке.</p>
    <p class="Textbody">Создание пользовательского сценария — просто, как правда. Для этого всего и нужно:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">создать командную конструкцию, достойную увековечивания; </p>
      </li>
      <li>
        <p class="Textbody">поместить ее в простой текстовый файл; </p>
      </li>
      <li>
        <p class="Textbody">по потребности и желанию снабдить комментариями; </p>
      </li>
      <li>
        <p class="Textbody">тем или иным способом запустить файл на исполнение. </p>
      </li>
    </ul>
    <p class="Textbody">С принципами создания команд и командных конструкций мы в первом приближении разобрались раньше. А вот способов помещёния их в файл существует множество. Можно просто ввести (или вызвать из буфера истории) нужную команду и оформить ее как аргумент команды echo, вывод которой перенаправить в файл:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ echo "cp -rf workdir backupdir" &gt; mybackup</span> </p>
    <p class="Textbody">Таким образом мы получили простейший скрипт для копирования файлов из рабочего каталога в каталог для резервного хранения данных, что впредь и будем проделывать регулярно (не так ли?).</p>
    <p class="Textbody">Аналогичную процедуру можно выполнить с помощью команды cat — она, оказывается, способна не только к объединению файлов и выводу их содержимого, но и к вводу в файл каких-либо данных. Делается это так. Вызываем cat с перенаправлением ее вывода в файл:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cat &gt; myarchive</span> </p>
    <p class="Textbody">и нажимаем Enter. После этого команда остается в ожидании ввода данных для помещёния их в новообразованный файл. Не обманем ее ожиданий и проделаем это. причём можно не жаться и выполнить ввод в несколько строк, например:</p>
    <p class="Textbody"><span style="background-color:#dddddd">cd $HOME/archivedir tar cf archive.tar</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        ../workdir gzip archive.tar</span> </p>
    <p class="Textbody">Завершив ввод тела скрипта, все той же клавишей Enter открываем новую строку и набираем комбинацию Control+D, выдающую символ окончания файла.</p>
    <p class="Textbody">В результате получаем сценарий для архивирования в специально предназначенном для этого каталоге archivedir наших рабочих данных (командой tar), а заодно и их компрессии (командой gzip) — в Unix, в отличие от DOS/Windows, архивирование и компрессия обычно рассматриваются как разные процедуры.</p>
    <p class="Textbody">Наконец, сценарий можно создать в любом текстовом редакторе. но это не так интересно — по крайней мере, пока. Да и стоит ли вызывать редактор ради двух-трёх строк?</p>
    <p class="Textbody">Комментариями в шелл-сценариях считаются любые строки, начинающиеся с символа решетки (#) — они не учитываются интерпретатором и не принимаются к исполнению. Хотя комментарий может быть начат и внутри строки — важно только, что между символом # и концом её больше ничего не было бы. Ясно, что комментарии — элемент для скрипта не обязательный, но очень желательный. Хотя бы для того, чтобы не забыть, ради чего этот сценарий создавался.</p>
    <p class="Textbody">Но одна строка, начинающаяся символом решётки, в сценарии практически обязательна. И должна она быть первой и выглядеть следующим образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#!/path/shell_name</span> </p>
    <p class="Textbody">В данном случае восклицательный знак подчеркивает, что предваряющий его символ решетки (#) — не комментарий, а указание (т.н. sha-bang) на точный абсолютный путь к исполняемому файлу оболочки, для которой наш сценарий предназначен, например,</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#!/bin/sh</span> </p>
    <p class="Textbody">для POSIX-шелла, или</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#!/bin/bash</span> </p>
    <p class="Textbody">для оболочки Bash. Здесь следует подчеркнуть, что шелл, для которого предназначается сценарий, отнюдь не обязан совпадать с командной оболочкой пользователя. И полноты картины для замечу, что указание точного имени интерпретатора требуется не только для шелл-скриптов, но и для программ на любых языках сценариев (типа Perl или Python).</p>
    <p class="Textbody">Так что по хорошему в обоих приведенных выше примерах ввод команд сценария следовало бы предварить строкой sha-bang. Конечно, отсутствие имени командной оболочки в явном виде обычно не помешает исполнению шелл-сценария: для этого будет вызван системный командный интерпретатор по умолчанию — в Mint /bin/dash. Однако если сценарий предназначен для другой командной оболочки, то без sha-bang он может исполняться неправильно (или не исполняться вообще).</p>
    <p class="Textbody">Теперь остается только выполнить наш сценарий. Сделать это можно разными способами. Самый напрашивающийся — непосредственно вызвать требуемый шелл как обычную команду, снабдив его аргументом — именем сценария (предположим, что он находится в текущем каталоге):</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ bash scriptname</span> </p>
    <p class="Textbody">Далее, для вызова скриптов существует специальная встроенная команда оболочки, обозначаемая символом точки. Используется она аналогично:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ . ./scriptname</span> </p>
    <p class="Textbody">с тем только исключением, что тут требуется указание текущего каталога в явном виде (что и символизируется ./).</p>
    <p class="Textbody">Однако наиболее употребимый способ запуска сценариев — это присвоение его файлу так называемого атрибута исполнения. Эта процедура волшебным образом превращает невзрачный текстовый файлишко во всамделишную (хотя и очень простую) программу.</p>
    <p class="Textbody">Так вот, после присвоения нашему сценарию бита исполнения запустить его можно точно также, как любую другую команду — просто из командной строки:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ./scriptname</span> </p>
    <p class="Textbody">Опять же — в предположении, что сценарий находится в текущем каталоге (./), иначе потребуется указание полного пути к нему. Что, понятно, лениво, но решается раз и навсегда: все сценарии помещаются в специально отведенный для этого каталог (например, $HOME/bin), который и добавляется в качестве ещё одного значения переменной PATH данного пользователя.</p>
    <h3 id="toc85"><a id="RefHeading16121713816058"></a><a id="bkmRefHeading16121713816058"></a><a id="toc84"></a><a id="bkmtoc84"></a><a id="RefHeading4621136957987"></a><a id="bkmRefHeading4621136957987"></a><a id="bkmRefHeading4621136957987"></a><a id="bkmbkmRefHeading4621136957987"></a>Понятие о функциях</h3>
    <p class="Textbody">И уж совсем в заключение этого раздела осталось сказать пару слов о функциях командной оболочки. Это — такая же последовательность команд (или даже просто одиночная команда), как и сценарий, но — не вынесенная в отдельный исполняемый файл, а помещённая в тело другого скрипта. В коем она опознаётся по имени, и может быть выполнена неоднократно в ходе работы этого скрипта.</p>
    <p class="Textbody">Главное отличие функции от сценария — в том, что она выполняется в том же процессе (и, соответственно, экземпляре шелла), что и заключающий её сценарий. Тогда как для каждого скрипта, вызываемого из другого сценария, создаётся отдельный процесс, порождающий собственный экземпляр шелла. Это может быть важным, если в сценарии определяются некоторые переменные, которые имеют силу только в нём самом.</p>
    <p class="Textbody">Функции не обязательно помещаются внутрь сценария — их можно собрать в некоторые отдельные файлы, которые именуются библиотеками функций и могут быть использованы по мере надобности.</p>
    <p class="Textbody">Ранее на протяжении всего повествования неоднократно упоминались (и будут упоминаться впредь) системные библиотеки, в частности, главная библиотека glibc. Так вот, это — точно такие же сборники функций, правда, не командной оболочки, а языка Си, и, соответственно, хранящиеся не в виде текстовых файлов, а в бинарном, откомпилированном, виде.</p>
    <h3 id="toc86"><a id="RefHeading16141713816058"></a><a id="bkmRefHeading16141713816058"></a><a id="toc85"></a><a id="bkmtoc85"></a><a id="RefHeading4641136957987"></a><a id="bkmRefHeading4641136957987"></a><a id="bkmRefHeading4641136957987"></a><a id="bkmbkmRefHeading4641136957987"></a>Настройка шелла</h3>
    <p class="Textbody">Во всех дистрибутивах Linux в качестве пользовательской командной оболочки по умолчанию выступает Bash, и Mint здесь не исключение. Так что, хотя автор этих строк не является ни её любителем, ни, тем более, знатоком, совсем обойти её вниманиемне мог. Так что ниже даётся мини-очерк настройки этого шелла.</p>
    <p class="Textbody">Оболочка Bash поддерживает все интерактивные возможности, столь важные для пользователя, как то: автодополнение для команд и путей к файлам, историю оных (включая средства инкрементного поиска), мощные возможности навигации и редактирования командной строки.</p>
    <p class="Textbody">Важно, что существует дополнительный пакет bash-completion: установка его обогащает базовую оболочку множеством опциональных средств настройки автодополнения (в том числе и для командных аргументов). Правда, чтобы эта дополненная оболочка была по настоящему удобной и функциональной, нужно приложить некоторые усилия по её настройке, чем мы сейчас и займёмся.</p>
    <p class="Textbody">Схема настройки bash предусматривает наличие пары файлов /etc/profile и /etc/bashrc (для логин-шелла и просто интерактивного его экземпляра), а также соответствующих им пользовательских конфигов — ~/.bash_profile и ~/.bashrc. При авторизации первым в любом случае считывается общесистемный профильный файл /etc/profile, вслед за ним — пользовательский профильный файл ~/.bash_profile, после чего происходит обращение к ~/.bashrc. Файл /etc/profile может занимать особое положение — в него часто помещают переменные окружения (например, локально-зависимые), которые должны быть общими для всех пользователей данной системы. Пользовательские же настройки определяются в файлах ~/.bash_profile и ~/.bashrc. Обычно в ~/.bash_profile определяются переменные окружения, которые должны действовать для всех дочерних процессов, а в ~/.bashrc — параметры, всегда требуемые в интерактивном режиме (например, псевдонимы).</p>
    <p class="Textbody">Редактирование командной строки в bash обеспечивается отдельным пакетом — библиотекой функций readline. Она имеет собственные конфигурационные файлы, общесистемный /etc/inputrc и пользовательский ~/.inputrc.</p>
    <p class="Textbody">Впрочем, в большинстве современных дистрибутивов Linux, ориентированных на графический режим и, следовательно, использование эмулятора терминала с интерактивным шеллом, не являющимся, тем не менее, шеллом пользовательским (login shell), ~/.bash_profile играет сугубо служебную роль, и содержимое его сводится к отработке файла ~/.bashrc:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># include .bashrc if it existsif [ -f ~/.bashrc ]; then</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">. ~/.bashrc</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">fi# set PATH so it includes user's private bin if it existsif [ -d ~/bin ] ; then</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">PATH=~/bin:"${PATH}"</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">fi</span> </p>
    <p class="Textbody">Именно в ~/.bashrc и выполняются при этом все пользовательские настройки.</p>
    <p class="Textbody">Большинство настроек Bash по умолчанию разумны, и потому наличные в данном дистрибутиве файлы вполне могут быть взяты за основу. Однако путём некоторых несложных действий их можно дополнить, увеличив удобство интерактивного использования командной оболочки.</p>
    <p class="Textbody">По умолчанию в Bash автодополнение клавишей табулятора не работает, например, в аргументах многих команд, таких, как sudo или man.</p>
    <p class="Textbody">Решается эта задача очень просто: достаточно файл ~/.bashrc внести следующие строки:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># enable bash completion in interactive shells</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">if [ -f /etc/bash_completion ]; then</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> . /etc/bash_completion</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">fi</span> </p>
    <p class="Textbody">После этого автодополнение будет работать буквально везде, где только можно себе представить, например, после набора dpkg --sea и нажатия табулятора получится dpkg --search.</p>
    <p class="Textbody">Если в файл /etc/inpurc (или в ~/inpurc) добавить такие строки:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">"e[A": history-search-backward</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">"e[B": history-search-forward</span> </p>
    <p class="Textbody">то набор части команды, например, cd /, и последующий перебор стрелками &lt;Up&gt; и &lt;Down&gt; истории команд повлечёт извеление из буфера истории только тех из них, которые начинаются на cd /.</p>
    <h2 id="toc87"><a id="RefHeading16161713816058"></a><a id="bkmRefHeading16161713816058"></a><a id="toc86"></a><a id="bkmtoc86"></a><a id="RefHeading12621136957987"></a><a id="bkmRefHeading12621136957987"></a><a id="bkmRefHeading12621136957987"></a><a id="bkmbkmRefHeading12621136957987"></a>Утилиты CLI</h2>
    <p class="Textbody">В этом очерке будут рассмотрены утилиты командной строки разного назначения — комплекс так называемых классических UNIX-утилит в их современных свободных реализациях, используемых в дистрибутивах Linux, в том числе и в Mint.</p>
    <h3 id="toc88"><a id="RefHeading16181713816058"></a><a id="bkmRefHeading16181713816058"></a><a id="toc87"></a><a id="bkmtoc87"></a><a id="RefHeading4661136957987"></a><a id="bkmRefHeading4661136957987"></a><a id="bkmRefHeading4661136957987"></a><a id="bkmbkmRefHeading4661136957987"></a>Самая главная команда</h3>
    <p class="Textbody">Эта рубрика посвящена самой главной команде — man, а также сопутствующим ей материям. Содержание её — не информация о тех или иных командах, или свойствах системы, а метаинформация: информация о том, как получить нужную информацию. То есть выработке некоторых навыков, которые у применителя Linux должны быть доведены до уровня рефлексов.</p>
    <p class="Textbody">Команд в свежеустановленной Linux-системе — немерянное количество, только консольных утилит под тысячу. Да ещё почти каждая команда имеет опции, подчас также в немалом числе. И возникает естественный вопрос: как нормальный человек все это может запомнить? Да никак — последует ответ. Потому что запоминать все это изобилие команд нет не только возможности — но и ни малейшей необходимости: гораздо важнее понимать, каким образом соответствующую информацию можно получить в нужный момент. И тут нам на помощь приходит самая главная команда — команда man.</p>
    <p class="Textbody">Команда man предназначена для вызова экранной документации в одноименном формате (Manual Pages, что на Руси ласково переводится как «тетя Маня»). А такая man-документация почти обязательно сопровождает любую уважающую себя программу для POSIX-систем. И устанавливается в принудительном порядке при инсталляции соответствующей программы в любом случае — разворачивается ли она из бинарного тарбалла или собирается из исходников.</p>
    <p class="Textbody">Для файлов man-документации предназначен специальный каталог. Обычно это /usr/share/man, разделяемый на подкаталоги, соответствующие восьми нумерованным группам. Назначение этих групп следующее:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">man1 — команды и прикладные программы пользователя; </p>
      </li>
      <li>
        <p class="Textbody">man2 — системные вызовы; </p>
      </li>
      <li>
        <p class="Textbody">man3 — библиотечные функции; </p>
      </li>
      <li>
        <p class="Textbody">man4 — драйверы устройств; </p>
      </li>
      <li>
        <p class="Textbody">man5 — форматы файлов; </p>
      </li>
      <li>
        <p class="Textbody">man6 — игры; </p>
      </li>
      <li>
        <p class="Textbody">man7 — различные документы, не попадающие в другие группы (в том числе относящиеся к национальной поддержке); </p>
      </li>
      <li>
        <p class="Textbody">man8 — команды администрирования системы. </p>
      </li>
    </ol>
    <p class="Textbody">Кроме того, имеется несколько подкаталогов с локализованными man-страницами, в том числе и русскоязычными, имеющими ту же структуру, хотя и обычно не полную. Так, подкаталог с русскоязычными страницами, /usr/share/man/ru, включает в себя только группы man1, man5, man7 и man8.</p>
    <p class="Textbody">Нас, применителей, в первую очередь интересуют команды из 1-й и, поскольку на персоналке каждый юзер — сам себе админ, из 8-й групп, хотя и об остальных категориях забывать не следует, иногда позарез нужные сведения отыскиваются в самой неожиданной из них.</p>
    <p class="Textbody">Внутри групповых подкаталогов можно увидеть многочисленные файлы вида filename.#.gz. Последний суффикс свидетельствует о том, что man-страница упакована компрессором gzip. Цифра после имени соответствует номеру группы (то есть в подкаталоге man1 это всегда будет единица). Ну а имя man-страницы совпадает с именем команды, которую она описывает. Если, конечно, речь идет о команде — в разделе 2 оно будет образовано от соответствующего системного вызова, в разделе 2 — от имени функции, и так далее. Но пока нас интересует только информация о командах, так что дальше я этого оговаривать не буду.</p>
    <p class="Textbody">Для вызова интересующей документации требуется дать команду man с аргументами — номером группы и именем man-страницы, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ man 1 ls</span> </p>
    <p class="Textbody">Причём номер группы необходим только в том случае, если одноимённые документы имеются в разных группах. Для пользовательских команд он обычно не нужен, так как все равно просмотр групповых каталогов идёт сначала в man1, затем — в man8, и только потом — во всех остальных (в порядке возрастания номеров). Так что для получения информации, например, по команде ls достаточно ввести следующее:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ man ls</span> </p>
    <p class="Textbody">после чего можно будет лицезреть примерно такую картину:</p>
    <p class="Textbody"><span style="background-color:#dddddd">LS(1)   FSF     LS(1)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        ls — list directory contents</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">SYNOPSIS</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        ls [OPTION]... [FILE]...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">DESCRIPTION</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        List  information  about</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        the FILEs (the current directory by default).</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        Sort entries alphabetically if none</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        of -cftuSUX nor --sort.</span> </p>
    <p class="Textbody">То есть в начале man-страницы даются имя команды, которую она описывает (ls), ее групповая принадлежность (1 — пользовательские команды) и авторство (в данном случае — FSF, Free Software Foundations), или название системы. После чего обычно дается обобщенный формат вызова (SYNOPSIS) и краткое описание.</p>
    <p class="Textbody">Следующая, основная, часть man-страницы — описание опций команды, и условия их применения. Далее иногда (но, к сожалению, не всегда) следуют примеры использования команды (Examples) в разных типичных ситуациях. В заключении, как правило, даются сведения о найденных ошибках (Bug Report) и приведен список man-страниц, тематически связанных с данной (See also), с указанием номера группы, к которой они принадлежат, иногда — историческая справка, а также указываются данные об авторе.</p>
    <p class="Textbody">Большинство man-страниц занимают более одного экрана. В этом случае возникает необходимость перемещёния по экранам и строкам — т.е. некоторая навигация. Сама по себе команда man не отвечает не только за навигацию по странице. но даже за ее просмотр. Для этой цели она неявным образом вызывает специальную программу постраничного просмотре — т.н. pager (это — совсем не то, чем дети лохов в песочнице ковыряются). В Linux таковым по умолчанию выступает уже известная нам команда less, но на эту роль можно назначить также more или most — это делается указанием значения соответствующей переменной, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">export PAGER=most</span> </p>
    <p class="Textbody">в конфигурациооном файле пользователя.</p>
    <p class="Textbody">Обращение к man-страницам позволяет получить практически исчерпывающую информацию по любым командам, но только в том случае, если пользователь знает название той команды, которая требуется в данном случае. А если он только в общих чертах представляет, что это команда должна делать?</p>
    <p class="Textbody">Что ж, тогда можно прибегнуть к поиску man-страниц по ключевым словам, отражающим требуемые функции. Чему призвана служить опция -k команды man. Например, директива</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ man -k print</span> </p>
    <p class="Textbody">выведет на экран список всех man-страниц, описывающих команды, имеющие отношение к печати (причём не только на принтере, но и к выводу на экран — по английски подчас это тоже будет обозначаться как print).</p>
    <p class="Textbody">Исчерпывающим руководством по использованию системы Manual Pages является ее собственная man-страница. Доступ к ней осуществляется по команде</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ man man</span> </p>
    <p class="Textbody">которая выводит на экран man-страницу, содержащую описание команды man (эко загнул, а?):</p>
    <p class="Textbody"><span style="background-color:#dddddd">MAN(1)  FreeBSD General Commands Manual MAN(1)</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        man — format and display the on-line</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        manual pages</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">SYNOPSIS</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        man [-adfhkotw] [-m machine]</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        [-p string] [-M path] [-P pager]</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        [-S list] [section] name ...</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">DESCRIPTION</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">     Man formats and displays the on-line manual pages.</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        ...</span> </p>
    <p class="Textbody">С навигационными возможностями команды less можно ознакомиться, нажав клавишу h — вызов встроенной её помощи. Из которой мы и узнаем, что перемещаться по man-странице можно с помощью управляющих последовательностей.</p>
    <p class="Textbody">Управляющие последовательности команды less для большинства навигационных действий весьма разнообразны, но в принципе разделяются на две группы: чисто буквенные и состоящие из комбинаций Control+литера. Так, переместиться на одну строку вперед можно просто нажатием клавиши j, на одну строку назад — клавиши k, сместиться на экранную страницу — с помощью клавиш f (вперед) и b (назад). Однако того же результата можно доиться комбинациями клавиш Control+n и Control+p для построчного перемещёния и Control+v и Control+и — для постраничного (вперед и назад, соответственно).</p>
    <p class="Textbody">Аналогично и для большинства других действий (смещёние на половину экранной страницы, например: Control+D и d — вперед, Control+U и u — назад) можно обнаружить минимум одну альтернативную пару управляющих последовательностей. Регистр символов обычно значения не имеет. Одно из исключений — нажатие клавиши g перемещает к первой строке man-страницы, клавиши G — к последней.</p>
    <p class="Textbody">Наличие двух типов управляющих последовательностей может показаться излишним усложнением, однако имеет глубокое внутреннее обоснование. За исключением некоторых отщепенцев (в числе коих и автор этих строк), подавляющее большинство записных юниксоидов пользуются одним из двух редакторов — Vim или emacs.</p>
    <p class="Textbody">Оба эти редактора относятся к категории командных. То есть все действия по редактированию осуществляются в них обычно не выбором пунктов из меню, а прямыми командными директивами, примерно как в командной строке оболочки. Так вот, одно из кардинальных различий между Vim и emacs — различие управляющих последовательностей для навигации по тексту и его редактированию. vi-образный стиль навигации основан на однобуквенных командных аббревиатурах (команды типа j или k пришли в less именно оттуда). Стиль emacs же подразумевает последовательности, образованные сочетанием клавиши Control и различных алфавитно-цифровых комбинаций.</p>
    <p class="Textbody">Поскольку эффективное использование любого редактора командного стиля подразумевает доведенное до автоматизма использование управляющих последовательностей, переключение с vi-стиля на стиль emacs в этом деле может быть просто мучительным. Вот и предусмотрели разработчики pager'ов, в своей заботе о человеке, возможность использования и того, и другого стиля — кто к чему привык.</p>
    <p class="Textbody">Раз уж зашла речь о стилях управляющих последовательностей... В большинстве командных оболочек такое переключение между стилями управления также возможно. Только не параллельное, а альтернативное. И устанавливается оно в конфигурационных файлах пользовательского шелла.</p>
    <p class="Textbody">Возвратимся, однако, к нашей man-документации. Для навигации по странице можно использовать и обычные клавиши управления курсором, клавиши PgUp/PgDown, а также некоторые другие. Например, нажатие Enter приводит к смещёнию на одну строку вперед (аналогично клавише Down, а клавиши Spacebar — на один экран вперед (подобно PgDown.</p>
    <p class="Textbody">Однако это — не лучший способ навигации. Потому что управляющие последовательности (не зависимо, в стиле ли vi, или в стиле emacs) обладают дополнительной полезной возможностью: они понимают числовые аргументы. То есть если мы нажмем клавишу с цифрой 5, а вслед за ней — клавишу J, то мы сместимся на пять строк вперед, комбинация 3+K — на три страницы назад, и так далее.</p>
    <p class="Textbody">Есть и возможность поиска внутри man-страницы. Для этого нажимается клавиша прямого слэша (/), после чего вводится искомое слово (последовательность символов). Для выхода из просмотра man-страницы предусмотрена клавиша q. Кроме того, можно использовать и почти универсальную комбинацию для прекращения выполнения программ — Control+C. Заканчивая разговор об управляющих последовательностях, ещё раз подчеркну: все они относятся не к самой команде man, а к той программе-пейджеру, которая ею вызывается для просмотра.</p>
    <h3 id="toc89"><a id="RefHeading16201713816058"></a><a id="bkmRefHeading16201713816058"></a><a id="toc88"></a><a id="bkmtoc88"></a><a id="RefHeading4681136957987"></a><a id="bkmRefHeading4681136957987"></a><a id="bkmRefHeading4681136957987"></a><a id="bkmbkmRefHeading4681136957987"></a>Команда sudo</h3>
    <p class="Textbody">Команда sudo — вторая по важности команда в Mint. Это — основной способ получения прав администратора обычным пользователем. А по умолчанию — так просто единственный, ибо при инсталляции этого дистрибутива пароль root'а не задаётся и, соответственно, доступа к аккаунту «чистого» суперпользователя нет (хотя при желании его можно получить). Команда эта дополняется утилитами visudo и sudoedit. Это узкоспециализированные средства для редактирования общесистемных конфигурационных файлов (в том числе и конфига самой sudo) обычным пользователем. Главные особенности sudo таковы:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">во-первых, sudo по умолчанию требует указания пароля того пользователя, который получает права другого, а не пароля того, чьи права приобретаются; правда, это может быть изменено; </p>
      </li>
      <li>
        <p class="Textbody">Во-вторых, действие sudo распространяется по умолчанию только на одну команду — ту, которая указывается в качестве ее аргумента; хотя и такое поведение можно изменить с помощью соответствующих опций, о чём будет сказано позднее; </p>
      </li>
      <li>
        <p class="Textbody">в-третьих, sudo обеспечивает более гибкое разграничение доступа пользователей к административным правам — не только разрешая или запрещая получение оных, но и позволяя выполнять только определённый круг действий. </p>
      </li>
    </ol>
    <p class="Textbody">Этим достигается две цели: а) возможность выполнения пользователем административных действий без сообщения ему суперпользовательского пароля (и даже, как в Mint, при его отсуствтии), и б) снижение риска повредить систему вследствие забывчивости. Да, есть ещё и третья, дополнительная возможность, предоставляемая sudo — протоколирование действий, выполненных в режиме администратора.</p>
    <p class="Textbody">В элементарном виде применение команды sudo — элементарно же просто: требуется лишь указать в качестве ее аргумента имя команды, требующей исполнения, со всеми необходимыми последней опциями и аргументами. После этого запрашивается пароль запустившего её пользователя — и команда исполняется. Например, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo fdisk -l /dev/sda</span> </p>
    <p class="Textbody">данная от лица обычного пользователя, выведет информацию об указанном дисковом устройстве точно так же, как и данная root’ом.</p>
    <p class="Textbody">В должным образом настроенной оболочке Bash в отношении команд-аргументов и путей — аргументов последних, будет действовать автодополнение по нажатию клавиши Tab. Как добиться от Bash столь образцового поведения — говорилось в предыдущем очерке.</p>
    <p class="Textbody">Если от лица алминистратора нужно выполнить подряд несколько команд, делать это следует быстро — введенный первый раз пароль по умолчанию «действует» в течении 5 минут. То есть в течении этого времени в ответ на команду sudo пароль повторно запрашиваться не будет.</p>
    <p class="Textbody">Период действия пароля для команды sudo можно увеличить, уменьшить или вообще ликвидировать, чтобы аутентификация запрашивался всегда. Это достигается редактированием конфигурационного файла утилиты, к чему мы вернёмся чуть позже.</p>
    <p class="Textbody">Аналогичным образом пользователь может отредактировать общесистемный конфигурационный файл, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo nano -w /etc/fstab</span> </p>
    <p class="Textbody">Впрочем, для редактирования общесистемных конфигов предназначена специальная команда sudoedit (или просто sudo с опцией -e). Она не требует указания имени вызываемого для этой цели редактора: в качестве такового используется значение переменной EDITOR из окружения того пользователя, который ее вызвал. Если эта переменная не определена — а это обычно делается в профильных файлах регистрационной оболочки пользователя, — для редактирования вызывается редактор Vim (в своей упрощенной ипостаси, эмулирующей классический vi).</p>
    <p class="Textbody">Как это ни парадоксально, команда sudo не исключает запуска администраторского сеанса внутри обычного пользовательского. Потому что с ее помощью можно запустить su:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo su</span> </p>
    <p class="Textbody">И это — даже в тех дистрибутивах, где root-аккаунта как бы и нет; точнее, по умолчанию нет его пароля (к ним, как уже было сказано, относится Mint). Но и задать пароль «настоящего» администратора не запрещается — для этого достаточно дать команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo passwd</span> </p>
    <p class="Textbody">чтобы в дальнейшем использовать команду su обычным образом. Правда, не уверен, что это стоит делать. Потому что для перманентного владения правами адмнистратора команда sudo предусматривает «идеологически правильный» метод, и даже не один. Это — опции -s и -i, пролонгирующие, хотя и несколько по разному, действие команды sudo на неопределённый срок, вплоть до завершения «вторичного сеанса» командой exit.</p>
    <p class="Textbody">Опция -s, открывая вторичный сеанс root’а, сохраняет все переменные окружения первоначального пользователя. Однако, если к ней добавить опцию -H, то переменные эти будут заново считаны из профильных файлов домашнего каталога администратора, то есть /root, как при запуске интерактивного экземпляра шелла. Однако каталог, бывший текущим в момент ввода команды, при этом не изменится, как не изменится и вид приглашения командной строки.</p>
    <p class="Textbody">Опция же -i полностью воспроизводит root-окружение, запуская его командную оболочку как регистрационную (login shell). Разумеется, при этом и текущий каталог меняется на /root, а приглашение командной строки приобретает вид, описанный в соответствующей переменной профильного файла администраторского шелла, то есть /root/.bashrc. Правда, в Mint и его по умолчанию нет.</p>
    <p class="Textbody">На практике разница между обеими формами обретения перманентных прав администратора не велика. А вот то, что при использовании опций -H нахождение в перманентно административном режиме никак внешне не проявляется, чревато ошибками. И делает в большинстве случаев применение опции -i предпочтительным.</p>
    <p class="Textbody">Возможности sudo не ограничиваются запуском команд от лица администратора: задав опцию -u username, их можно выполнить и от лица того пользователя, чей логин задан в качестве её значения. Это может быть полезным при просмотре или копировании dot-файлов и dot-каталогов другого пользователя, часто открытых для чтения и изменения только их хозяину.</p>
    <p class="Textbody">К слову сказать, команду sudo можно запустить так, чтобы она запрашивала пароль пользователя, от имени которого будет выполняться команда (например, администратора), а не того, кто требует его полномочий. Для этого существует опция -targetpw. А чтобы сделать требование root’ового пароля постоянным, достаточно определить, например, псевдоним типа</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias sudo='sudo -targetpw'</span> </p>
    <p class="Textbody">Команда sudo имеет ещё немало опций — выше я привёл только те, которые мне приходилось использовать. Остальные легко посмотреть в man sudo. Из не перечисленных упомяну ещё опцию -b, предписывающую запускать «подсудную» команду в фоновом режиме. Она может быть полезна при выполнении долговременных действий, например, при копировании образов USB на флэшку командой dd.</p>
    <p class="Textbody">Таким образом, команда sudo даёт пользователю практически неограниченные полномочия как для любых общесистемных действий, так и для манипуляции чужими пользовательскими данными. В связи с этим зададимся вопросами:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">любой ли пользователь может получить права администратора через команду sudo, и </p>
      </li>
      <li>
        <p class="Textbody">все ли действия по администрированию он может ее посредством выполнить? </p>
      </li>
    </ul>
    <p class="Textbody">Если говорить о семействе Ubuntu (в том числе и дистрибутиве Mint), в котором механизм этот был впервые задействован из «коробки» — то «из коробки» же ответ на первый вопрос будет отрицательным, на второй — положительным. А вообще это зависит от настроек программы sudo, которые описываются в файле /etc/sudoers. И в нем можно задать правила, допускающие к исполнению определенных команд только отдельных пользователей. В обобщенном виде это выглядит так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">username        host = command</span> </p>
    <p class="Textbody">Здесь, как нетрудно догадаться, username — имя пользователя, для которого устанавливается данное правило, host — имя машины, с которой он может к этому правилу прибегнуть, command — конкретная команда, использование которой разрешается данному пользователю с данной машины. Команда должна быть дана с указанием полного абсолютного пути (то есть /sbin/fdisk, а не fdisk). Поле описания команд может включать несколько значений, разделенных запятыми, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">username        ALL = /sbin/fdisk,/bin/mount</span> </p>
    <p class="Textbody">В Ubuntu’идах по умолчанию правила доступа пользователей к административным привилегиям описываются так:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># User privilege specificationroot</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">ALL=(ALL) ALL</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"># Members of the admin group may gain root privileges</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">%admin  ALL=(ALL) ALL</span> </p>
    <p class="Textbody">То есть пользователь root, как ему и положено, может исполнять любые команды с любых хостов. А вот получить права его могут только пользователи, входящие в группу admin. Пользователь, создаваемый в ходе обычной установки, автоматически становится членом этой группы — и потому все административные права ему доступны без всяких дальнейших настроек. Однако прочие пользователи, чьи аккаунты будут созданы в последствие, этой привилегии лишены. Если, конечно, они не были специально включены в группу admin.</p>
    <p class="Textbody">В более иных дистрибутивах, не использующих sudo «из коробки», потребуется редактирование её конфигурационного файла — того самого /etc/sudoers, о котором упоминалось выше.</p>
    <p class="Textbody">Файл /etc/sudoers — обычный текстовый, и, соответственно, его можно редактировать в любом текстовом редакторе (или, скажем, средствами ed или sed). Однако при этом существует определённый риск что-нибудь напортачить (за счёт обычных опечаток), вплоть до того, что полностью закрыть самому себе доступ к привилегиям суперпользователя. Конечно, ситуации эти поправимы — например, через перезагрузку в однопользовательском режиме. Однако, лучше в них не попадать. И потому более надёжным средством модификации /etc/sudoers будет использование специально предназначенной для того утилиты — visudo.</p>
    <p class="Textbody">Утилита visudo не делает ничего сверхъестественного — она просто открывает /etc/sudoers в текстовом редакторе, описываемом переменной EDITOR суперпользователя (если таковая не определена, им будет опять же классический vi — отсюда и название) и позволяет его отредактировать обычным образом, после чего выйти из редактора с сохранением результатов штатными его средствами. Однако перед этим результат редактирования проверяется на корректность. И если обнаруживается нарушение синтаксиса, принятого для /etc/sudoers, выдается соответствующее предупреждение. После которого можно вернуться к редактированию, отказаться от сделанных изменений или все-таки принять их (разумеется, под личную ответственность).</p>
    <p class="Textbody">Утилита visudo не гарантирует стопроцентного успеха редактирования. Так как проверяет только соответствие синтаксиса, но не «правильность самих правил». То есть если ошибка будет допущена в указании пути к нужной для данного правила команде — эта команда через sudo не сработает.</p>
    <p class="Textbody">Впрочем, на деле это выглядит обычно гораздо проще и совсем не страшно. Так, можно было бы предоставить себе по блату возможность использовать sudo без пароля. Для этого потребовалось бы придать строке, описывающей привилегии группы admin такой вид:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">%admin        ALL=(ALL)       NOPASSWD: ALL</span> </p>
    <p class="Textbody">А можно ограничиться более «долгоиграющим» действием пароля, вписав изначально отсутствующую строку</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Defaults    timestamp_timeout=10</span> </p>
    <p class="Textbody">где значение таймаута указано в минутах. Если же изменить его на ноль --</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Defaults    timestamp_timeout=0</span> </p>
    <p class="Textbody">то пароль будет запрашиваться каждый раз при обращении к команде sudo.</p>
    <p class="Textbody">Можно, напротив, отключить тайаут на действие sudo, ввдя для него отрицательное значение:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Defaults    timestamp_timeout=-1</span> </p>
    <p class="Textbody">В этом случае пароль будет запрошен только при первом вызове этой команды.</p>
    <p class="Textbody">Более пристальное вглядывание в файл /etc/sudoers легко подскажет возможности дать определённым пользователям или группам только ограниченный набор прав. Впрочем, тут уже начинаются тонкости всамделишнего администрирования.</p>
    <h3 id="toc90"><a id="RefHeading16221713816058"></a><a id="bkmRefHeading16221713816058"></a><a id="toc89"></a><a id="bkmtoc89"></a><a id="RefHeading4701136957987"></a><a id="bkmRefHeading4701136957987"></a><a id="bkmRefHeading4701136957987"></a><a id="bkmbkmRefHeading4701136957987"></a>Создание файлов и каталогов</h3>
    <p class="Textbody">В следующих мини-очерках будут рассмотрены основные команды, предназначенные для файловых операций, вместе с их наиболее используемыми опциями. Чтобы не повторяться, напомню, что почти все описанные ниже команды имеют три стандартные опции (т.н. GNU Standard Options): --help для получения помощи, --version для вывода информации о текущей версии, и --[пробел], символизирующая окончание перечня опций (т.е. любой символ или их последовательность после неё интерпретируются как аргумент). Так что далее эти опции в описаниях команд фигурировать не будут.</p>
    <p class="Textbody">Для создания обычных (regular) файлов могут использоваться команды touch, cat и tee. Первая из указанных команд в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ touch filename</span> </p>
    <p class="Textbody">просто создает файл с именем filename и без всякого содержимого. Кроме того, с помощью специальных опций она позволяет устанавливать временные атрибуты файла, о чем я скажу чуть позже.</p>
    <p class="Textbody">Для чего может потребоваться пустой файл? Например, для создания скелета web-сайта с целью проверки целостности ссылок. Поскольку число аргументов команды touch не ограничено ничем (вернее, ограничено только максимальным количеством символов в командной строке), это можно сделать одной командой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ touch index.html about.html content.html [...]</span> </p>
    <p class="Textbody">Можно, воспользовавшись приемом группировки аргументов, заполнить файлами все подкаталоги текущего каталога:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ touch dirname1/{filename1,filename2}</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        dirname2/{filename3,filename4}</span> </p>
    <p class="Textbody">и так далее. Правда, сама команда touch создавать подкаталоги не способна — это следует сделать предварительно командой mkdir (о которой — чуть ниже).</p>
    <p class="Textbody">Для создания пустого регулярного файла может быть использована также команда cat (хотя основное ее назначение — слияние нескольких файлов, о чем будет говориться со временем). Для этого нужно просто перенаправить ее вывод в файл:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cat &gt; filename</span> </p>
    <p class="Textbody">затем создать новую строку (нажатием клавиши Enter) и ввести символ конца файла (комбинацией клавиш Control+Z). Разумеется, предварительно в этот файл можно и ввести какой-нибудь текст, однако это уже относится к управлению контентом, о чем речь будет впереди.</p>
    <p class="Textbody">Интересно создание файлов с помощью команды tee. Смысл ее — в раздвоении выходного потока, выводимого одновременно и на стандартный вывод, и в файл, указанный в качестве ее аргумента. То есть если использовать ее для создания файла с клавиатуры, это выглядит, будто строки удваиваются на экране. Но это не так: просто весь вводимый текст копируется одновременно и на экран, и в файл. И потому ее удобно применять в командных конструкциях, когда требуется одновременно и просмотреть результаты исполнения какой-либо команды, и запечатлеть их в файле:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls dir | tee filename</span> </p>
    <p class="Textbody">По умолчанию команда tee создает новый файл с указанным именем, или перезаписывает одноименный, если он существовал ранее. Однако данная с опцией -a, она добавляет новые данные в конец существующего файла.</p>
    <p class="Textbody">Команда mkdir создает файл особого типа — каталог, содержимым которого является список входящих в него файлов. Очевидно, что список этот в момент создания каталога должен быть пуст, однако это не совсем так: любой, даже пустой, каталог содержит две ссылки — на каталог текущий, обозначаемый как ./ (т.е. сам на себя) и на каталог родительский, ../ (т.е тот, в список файлов которого он включается в момент создания).</p>
    <p class="Textbody">Команда mkdir требует обязательного аргумента — имени создаваемого каталога. Аргументов может быть больше одного — в этом случае будет создано два или больше поименованных каталогов. По умолчанию они создаются как подкаталоги каталога текущего. Можно создать также подкаталог в существующем подкаталоге:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mkdir parentdir/newdir</span> </p>
    <p class="Textbody">Если же требуется создать подкаталог в каталоге, отличном от текущего, — путь к нему требуется указать в явном виде, в относительной форме:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mkdir ../dirname1/dirname2</span> </p>
    <p class="Textbody">или в форме абсолютной:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mkdir /home/username/dirname1/dirname2</span> </p>
    <p class="Textbody">В произвольном, отличном от текущего, каталоге можно одной командой создать несколько подкаталогов, для чего нужно прибегнуть к группировке аргументов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mkdir ../parentdir/{dirname1,dirname2,...,dirname#}</span> </p>
    <p class="Textbody">Такой прием позволяет одной командой создать дерево каталогов проекта. Например, скелет web-сайта, который потом можно наполнить пустыми файлами с помощью команды touch.</p>
    <p class="Textbody">А опций у команды mkdir — всего две (за исключением стандартных опций GNU): --mode (или -m) для установки атрибутов доступа и --parents (или -p) для создания как требуемого каталога, так и родительского по отношению к нему (если таковой ранее не существовал). Первая опция используется в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mkdir --mode=### dirname</span> </p>
    <p class="Textbody">или</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mkdir -m ### dirname</span> </p>
    <p class="Textbody">Здесь под ### понимаются атрибуты доступа для владельца файла, группы и прочих, заданные в численной нотации (например, 777 — полный доступ на чтение, изменение и исполнение для всех). Не возбраняется и использование символьной нотации: команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mkdir -m a+rwx dirname</span> </p>
    <p class="Textbody">создаст каталог с теми же атрибутами полного доступа для всех.</p>
    <p class="Textbody">Опция --parents (она же -p) позволяет создавать иерархическую цепочку подкаталогов любого уровня вложенности. Например,</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mkdir -p dirlevel1/dirlevel2/dirlevel3</span> </p>
    <p class="Textbody">в один заход создаст в текущем каталоге цепочку вложенных друг друга подкаталогов. Разумеется, и здесь с помощью группировки аргументов можно создать несколько одноранговых подкаталогов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mkdir -p dirlevel1/dirlevel2/{dirlevel31,...,dirlevel3#}</span> </p>
    <h3 id="toc91"><a id="RefHeading16241713816058"></a><a id="bkmRefHeading16241713816058"></a><a id="toc90"></a><a id="bkmtoc90"></a><a id="RefHeading4721136957987"></a><a id="bkmRefHeading4721136957987"></a><a id="bkmRefHeading4721136957987"></a><a id="bkmbkmRefHeading4721136957987"></a>Аттрибуция файлов</h3>
    <p class="Textbody">Следующая группа команд предназначена для атрибуции файлов. В ней — chmod, chown, chgrp, umask, а также уже затронутая ранее команда touch.</p>
    <p class="Textbody">Команды chown и chgrp служат для изменения атрибутов принадлежности файла — хозяину и группе: очевидно, что все, не являющиеся хозяином файла, и не входящие в группу, к которой файл приписан, автоматически попадают в категорию прочих (other).</p>
    <p class="Textbody">Формат команды chown — следующий:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chown newowner filename</span> </p>
    <p class="Textbody">По соображениям безопасности, достаточно очевидным, изменить хозяина файла может только суперпользователь. Пользователь обычный в подавляющем большинстве случаев автоматически становится хозяином всех им созданных (и скопированных) файлов, и избавиться от этого бремени, как и от родительского долга, не в состоянии.</p>
    <p class="Textbody">А вот изменить групповую принадлежность своих файлов (т.е. тех, в атрибутах принадлежности он прописан как хозяин) пользователь вполне может. Команда:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chgrp newgroup filename</span> </p>
    <p class="Textbody">от его лица припишет файл filename к группе newgroup. Однако и здесь есть ограничение — результат будет достигнут, только если хозяин файла является членом группы newgroup, иначе опять придется прибегнуть к полномочиям администратора.</p>
    <p class="Textbody">Можно также одной командой сменить (только суперпользователю, конечно) и хозяина файла, и группу, к которой он приписан. Делается это так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chown newowner:newgroup filename</span> </p>
    <p class="Textbody">Или так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chown newowner.newgroup filename</span> </p>
    <p class="Textbody">Где, понятное дело, под именем newowner выступает новый хозяин файла, а под именем newgroup — новая группа, к которой он приписан.</p>
    <p class="Textbody">В обеих командах вместо имени хозяина и группы могут фигурировать их численные идентификаторы (UID и GID, соответственно). Это имеет смысл, например, при совместном использовании файлов в разных операционных системах. Так, даже единственный пользователь имя_рек в каком-либо варианте Linux и в BSD по умолчанию имеет разные идентификаторы, и чтобы сделать его владельцем неких файлов и там, и там, именно численный идентификатор должен фигурировать в качестве параметра команды chown.</p>
    <p class="Textbody">Для команд chown и chgrp поддерживается один и тот же набор опций. Наиболее интересны (и важны) две из них. Опция --reference позволяет определить хозяина файла и его принадлежность к группе не явным образом, а по образу и подобию файла, имя которого выступает в качестве значения опции. Так, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chown --reference=ref_filename filename</span> </p>
    <p class="Textbody">установит для файла filename те же атрибуты принадлежности (хозяина и группу), что были ранее у файла ref_filename. Это весьма полезно при массовой реатрибуции файлов, полученных из разных источников.</p>
    <p class="Textbody">Опция -R (или --recursive) распространяет действие обеих команд не только на файлы текущего каталога (излишне напоминать, что в качестве аргументов команд могут использоваться маски типа *, *.ext, name.* и т.д.),<br />но и на все вложенные подкаталоги, вместе с входящими в них файлами. То есть пользователь может поменять групповую принадлежность всех файлов в своем домашнем каталоге одной командой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chgrp -R newgroup ~/*</span> </p>
    <p class="Textbody">А суперпользователь тем же способом может установить единообразные атрибуты принадлежности «по образцу» для всех компонентов любого каталога:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ chown -R --reference=ref_filename</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        /somepath/somecat/*</span> </p>
    <p class="Textbody">Как и следует из ее имени, команда chmod предназначена для смены атрибутов доступа — чтения, изменения и исполнения. В отношении единичного файла делается это просто:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chmod [атрибуты] filename</span> </p>
    <p class="Textbody">Атрибуты доступа могу устанавливаться с использование как символьной, так и цифровой нотации. Первый способ — указание, для каких атрибутов принадлежности (хозяина, группы и всех остальных) какие атрибуты доступа задействованы. Атрибуты принадлежности обозначаются символами u (от user) для хозяина файла, g (от group) — для группы, o (от other) для прочих и a (от all) — для всех категорий принадлежности вообще. Атрибуты доступа символизируются литерами r (от read), дающей право чтения, w (от write) — право изменения и x (от execute) — право исполнения.</p>
    <p class="Textbody">Атрибуты принадлежности соединяются с атрибутами доступа символами + (присвоение атрибута доступа), - (отнятие атрибута) или = (присвоение только данного атрибута доступа с одновременным отнятием всех остальных). Одновременно в строке можно указать (подряд, без пробелов) более чем один из атрибутов принадлежности и несколько (или все) атрибуты доступа.</p>
    <p class="Textbody">Для пояснения сказанного приведу несколько примеров. Так, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chmod u+w filename</span> </p>
    <p class="Textbody">установит для хозяина (u) право изменения (+w) файла filename, а команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chmod a-x filename</span> </p>
    <p class="Textbody">отнимет у всех пользователей вообще (a) право его исполнения (-x). В случае, если некоторый атрибут доступа присваивается всем категориям принадлежности, символ a можно опустить. Так, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chmod +x filename</span> </p>
    <p class="Textbody">в противоположность предыдущей, присвоит атрибут исполнения файла filename всем категориям принадлежности (и хозяину, и группе, и прочим).</p>
    <p class="Textbody">С помощью команды</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chmod go=rx filename</span> </p>
    <p class="Textbody">можно присвоить группе принадлежности файла filename и всем прочим (не хозяину и не группе) право на его чтение и исполнение с одновременным отнятием права изменения.</p>
    <p class="Textbody">Наконец, команда chmod в состоянии установить и дополнительные атрибуты режима для файлов, такие, как биты SUID и GUID, или, скажем, атрибут sticky.</p>
    <p class="Textbody">Приведенные примеры можно многократно умножить, но, думается, их достаточно для понимания принципов работы команды chmod с символьной нотацией атрибутов.</p>
    <p class="Textbody">Цифровая нотация — ещё проще. При ней достаточно указать сумму присваиваемых атрибутов в восьмеричном исчислении (4 — атрибут чтения, 2 — атрибут изменения и 1 — атрибут исполнения; 0 символизирует отсутствие любых атрибутов доступа) для хозяина (первая позиция), группы (вторая позиция) и прочих (третья позиция). Все атрибуты доступа, оставшиеся вне этой суммы, автоматически отнимаются у данного файла. То есть команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chmod 000 filename</span> </p>
    <p class="Textbody">означает снятие с файла filename всех атрибутов доступа для всех категорий принадлежности (в том числе и хозяина) и эквивалентна команде</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chmod =rwx filename</span> </p>
    <p class="Textbody">в символьной нотации. А команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chmod 777 filename</span> </p>
    <p class="Textbody">напротив, устанавливает для всех полный доступ к файлу filename. Для установки дополнительных атрибутов доступа в численной нотации потребуется указать значение четвертого, старшего, регистра. Так, команда для рассмотренного выше примера — присвоения атрибута суидности исполнимому файлу X-сервера, — в численной нотации будет выглядеть как</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chmod 4711 /usr/X11R6/bin/XFree86</span> </p>
    <p class="Textbody">Как и для команд chown и chgrp, наиболее значимые опции команды chmod — это --reference и -R. И смысл их тот же самый. Первая устанавливает для файла (файлов) атрибуты доступа, идентичные таковым референсного файла, вторая — распространяет действие команды на все вложенные подкаталоги и входящие в них файлы.</p>
    <p class="Textbody">Рекурсивное присвоение атрибутов доступа по образцу требует внимания. Так, если рекурсивно отнять для всего содержимого домашнего каталога атрибут исполнения (а он без соблюдения некоторых условий монтирования автоматом присваивается любым файлам, скопированным с носителей файловой структуры FAT или ISO9660 без расширения RockRidge, что подчас мешает), то тем самым станет невозможным вход в любой из вложенных подкаталогов. Впрочем, в параграфе про утилиту find будет показан один из способов борьбы с таким безобразием.</p>
    <p class="Textbody">Как было упомянуто в предшествующей главе, для всех вновь создаваемых данным пользователем файлов можно установить некие умолчальные атрибуты доступа. Этой цели служит команда umask — в отличие от прочих, не самостоятельная утилита, а встроенная команда оболочки. Данная без аргумента, она выведет текущее значение субтрактивных (то есть отнимаемых от суммы) прав доступа для новообразуемых файлов:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ umask</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">22</span> </p>
    <p class="Textbody">Вывод прав дается в символьной нотации, нули (то есть отсутствие «отъёма» прав у кого-либо) игнорируется. Если же в качестве аргумента указать «отнимаемые» права — все вновь создаваемые файлы будут иметь новые атрибуты доступа. Например, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ umask 000</span> </p>
    <p class="Textbody">приведет к тому, что новые файлы будут иметь всю совокупность атрибутов доступа (чтения, изменения и исполнения) для хозяина, группы и прочих.</p>
    <p class="Textbody">Действие команды umask, данной таким образом, распространяется только на текущий сеанс работы. Поэтому обычно она включается в профильный файл пользовательской командной оболочки, определяя умолчальные права доступа на вечные времена.</p>
    <p class="Textbody">Кроме атрибутов принадлежности и доступа, файлам свойственны ещё и атрибуты времени — времени доступа (atime), времени изменения метаданных (ctime) и времени изменения данных (mtime) файла. Они устанавливаются автоматически, в силу самого факта открытия файла (atime), смены любых атрибутов, например, доступа (ctime) или редактирования содержимого файла (mtime).</p>
    <p class="Textbody">Однако бывают ситуации, когда автоматически установленные временные атрибуты требуется изменить. Причиной может быть сбой системных часов, в результате которого временные атрибуты создаваемых и модифицируемых файлов перестанут соответствовать действительности.</p>
    <p class="Textbody">Казалось бы, чего страшного? Ан нет, фактор времени играет в Unix-системах очень существенную роль. Во-первых, команда make (а под ее управлением компилируются программы из исходников) проверяет временные атрибуты файлов (в первую очередь — атрибут mtime) и при их несоответствии может работать с ошибками. Ну и более обычная ситуация — на основе временных меток файлов можно эффективно осуществлять, скажем, резервное копирование. И потому желательно, чтобы они отражали реальное время создания и модификации файла.</p>
    <p class="Textbody">Так вот, для изменения временных атрибутов файлов и предназначена в первую очередь команда touch, которую ранее мы использовали просто для создания пустого файла. Данная же с именем существующего файла в качестве аргумента -</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ touch exist_file</span> </p>
    <p class="Textbody">она присвоит всем его временным атрибутам (atime, ctime, mtime) значения текущего момента времени. Изменение временных атрибутов можно варьировать с помощью опций. Так, если указать только одну из опций -a, -c, или -m, то текущее значение времени будет присвоено только атрибуту atime, ctime или mtime, соответственно. Если при этом использовать ещё и опцию -d [значение], то любому из указанных атрибутов (или им всем) можно присвоить любую временную метку, в том числе и из далёкого будущего. А посредством опции -r filename файл-аргумент получит временные атрибуты, идентичные таковым референсного файла filename.</p>
    <h3 id="toc92"><a id="RefHeading16261713816058"></a><a id="bkmRefHeading16261713816058"></a><a id="toc91"></a><a id="bkmtoc91"></a><a id="RefHeading4741136957987"></a><a id="bkmRefHeading4741136957987"></a><a id="bkmRefHeading4741136957987"></a><a id="bkmbkmRefHeading4741136957987"></a>Навигация по файловой системе</h3>
    <p class="Textbody">Следующее, что необходимо применителю после создания файлов — ориентация среди существующего их изобилия.</p>
    <p class="Textbody">Для начала при неплохо определиться со своим текущим положением в файловой системе. Этому послужит команда pwd. В ответ на нее выводится полный путь к текущему каталогу. Например, если текущим является домашний каталог пользователя, в ответ на:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ pwd</span> </p>
    <p class="Textbody">последует</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/home/username</span> </p>
    <p class="Textbody">Команда pwd имеет всего две опции: -L и -P. Первая выводит т.н. логический путь к текущему каталогу. То есть, таковым является, скажем, каталог /usr/src/vboxhost-4.3.20, являющий собой символическую ссылку на каталог /usr/share/virtualbox/src/vboxhost, то в ответ на</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ pwd -L</span> </p>
    <p class="Textbody">так и будет выведено</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/usr/src/vboxhost-4.3.20</span> </p>
    <p class="Textbody">Впрочем, тот же ответ последует и на команду pwd без опций вообще. Если же дать эту команду в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ pwd -P</span> </p>
    <p class="Textbody">то будет выведен путь к физическому каталогу, на который ссылается текущий, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/usr/share/virtualbox/src/vboxhost</span> </p>
    <p class="Textbody">Далее, по каталогам неплохо как-то перемещаться. Что делается командой cd. В отличие от прочих команд, рассматриваемых в этом разделе, это — внутренняя команда, встроенная во все командные оболочки — бесполезно было бы искать соответствующий ей исполняемый файл. Однако это не уменьшает ее важности. Использование ее очень просто —</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cd pathname</span> </p>
    <p class="Textbody">где pathname — путь к искомому каталогу в абсолютной (относительно корня) или относительной (относительно текущего каталога) форме.</p>
    <p class="Textbody">Определить местоположение команды (и вообще исполняемых файлов) в структуре файловой системы можно с помощью команды which (это также встроенная команда оболочки). В качестве аргумента ее можно указать одно или несколько имен файлов, в ответ на что будет выведен полный путь к каждому из них:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ which tcsh zsh bash</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/bin/tcsh</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/bin/zsh</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/bin/bash</span> </p>
    <p class="Textbody">При наличии одноимённых исполняемых файлов в разных каталогах по умолчанию будет выведен путь только к первому из них: для вывода всех файлов-«тезок» можно прибегнуть к опции -a. При этом не важно, будут это жёсткие или символические ссылки.</p>
    <p class="Textbody">Более широкие возможности поиска — у команды whereis. По умолчанию, без опций, она для заданного в качестве аргумента имени выводит список бинарных файлов, man-страниц и каталогов с исходными текстами:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ whereis zsh</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">zsh: /bin/zsh /etc/zsh /usr/lib/zsh /usr/share/zsh</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/usr/man/man1/zsh.1.gz /usr/share/man/man1/zsh.1.gz</span> </p>
    <p class="Textbody">Соответствующими опциями можно задать поиск файлов одного из этих типов: -b — бинарных, -m — страниц руководств, -s — каталогов с исходниками. Дополнительные опции -B, -M, -S (в сочетании с опцией -f) позволяют определить исходные каталоги для их поиска.</p>
    <p class="Textbody">Команды locate и mlocate осуществляют поиск всех файлов и каталогов, содержащих компонент имени, указанный в качестве аргумента и осуществляют вывод содержимого найденных каталогов. Так, в ответ на команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ locate zsh</span> </p>
    <p class="Textbody">будет выведен список вроде следующего:</p>
    <p class="Textbody"><span style="background-color:#dddddd">/bin/zsh</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/bin/zsh-4.0.6</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/etc/zsh</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/etc/zsh/zlogin</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/etc/zsh/zshenv</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/etc/zsh/zshrc</span> </p>
    <p class="Textbody">и так далее. Команда mlocate действует точно так же. Обе они при этом обращаются к базе данных /var/lib/mlocate/mlocate.db. Исходно эта база данных пуста — и перед использованием команды locate или mlocate должна быть наполнена содержанием. Для этого предназначен сценарий /usr/bin/updatedb.mlocate. Он извлекает сведения из базы данных установленных пакетов — /var/lib/dpkg. В Mint этот сценарий автоматически запускается ежедневно посредством cron, обеспечивая регулярное обновление поисковой базы.</p>
    <h3 id="toc93"><a id="RefHeading16281713816058"></a><a id="bkmRefHeading16281713816058"></a><a id="toc92"></a><a id="bkmtoc92"></a><a id="RefHeading4761136957987"></a><a id="bkmRefHeading4761136957987"></a><a id="bkmRefHeading4761136957987"></a><a id="bkmbkmRefHeading4761136957987"></a>Информация о файлах</h3>
    <p class="Textbody">Наиболее универсальным средством получения практически исчерпывающей информации о файлах является команда ls. Однако для этой цели существуют и другие команды.</p>
    <p class="Textbody">Общая форма запуска команды ls —</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls [options] names</span> </p>
    <p class="Textbody">где в качестве аргумента names могут выступать имена файлов или каталогов в любом количестве. Команда эта имеет многочисленные опции, основные из которых мы и рассмотрим.</p>
    <p class="Textbody">Начать с того, что команда ls, данная без всяких опций, по умолчанию выводит только имена файлов, причём опуская т.н. dot-файлы, имена которых начинаются с точки (это — некие аналоги скрытых файлов в MS DOS и Windows). Кроме того, если в качестве аргумента указано имя каталога (или аргумент не указан вообще, что подразумевает текущий каталог), из списка имен его файлов не выводятся текущий (.) и родительский (..) каталог.</p>
    <p class="Textbody">Для вывода всех без исключения имен файлов (в том числе и скрытых) предназначена опция -a. Смысл опции -A близок — она выводит список имен всех файлов, за исключением символов текущего (.) и родительского (..) каталога.</p>
    <p class="Textbody">Кроме имени, любой файл идентифицируется своим номером inode. Для его вывода используется опция -i:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ ls -i</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">12144 content.html</span> </p>
    <p class="Textbody">и так далее. Как и многие другие, команда ls обладает способностью рекурсивной обработки аргументов, для чего предназначена опция -R, выводящая список имен файлов не только текущего каталога, но и всех вложенных подкаталогов:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ ls -R</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">unixforall:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">about/  apps/     diffimages/  distro/  signature.html  sys/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">anons/  content/  difftext/    gentoo/  statistics/     u4articles/</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">unixforall/about:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">about_lol.html  about_lol.txt  index.html</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">unixforall/anons:</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">anons_dc.html</span> </p>
    <p class="Textbody">Опция же -d, напротив, запрещает вывод содержимого вложенных подкаталогов.</p>
    <p class="Textbody">В выводе команды ls по умолчанию имена файлов разных типов даются абсолютно одинаково. Для их визуального различия используется опция -F, завершающая имена каталогов символом слэша, исполнимых файлов — символом звездочки, символических ссылок — «собакой»; имена регулярных файлов, не имеющих атрибута исполнения, никакого символа не включают:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ ls -F</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">dir1/   dir2/   dir3@   file1   file2*  file3@</span> </p>
    <p class="Textbody">Другое средство для визуального различия типов файлов — колоризация, для чего применяется опция -G. Цвета шрифта, воспроизводящего имена, по умолчанию — синий для каталогов, лиловый (magenta) для символических ссылок, красный — исполнимых файлов, и так далее. Для файлов устройств, исполнимых файлов с атрибутом «суидности», каталогов, имеющих атрибут sticky, дополнительно колоризуется и фон, на котором выводится шрифта, воспроизводящий их имена. Подробности можно посмотреть в секции ENVIRONMENT man-страницы для команды ls. Впрочем, колоризация работает не на всех типах терминалов (и не во всех командных оболочках).</p>
    <p class="Textbody">По умолчанию команда ls выводит список файлов в порядке ASCII-кодов первого символа имени. Однако есть возможность его сортировки в порядке времени модификации (-t), изменения статуса (-c) или времени доступа (-tu), а также в порядке, обратном любому из перечисленных (-r). Кроме того, опция -f отменяет какую-либо сортировку списка вообще.</p>
    <p class="Textbody">Информацию об объёме файлов можно получить, используя опцию -s, выводящую для имени каждого файла его размер в блоках, а также суммарные объём всех выведенных файлов:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ ls -s ../book</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">total 822</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">656 book.html</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">4 content1.html</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">86 var_part2.html</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">24 command.html</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">38 part2.html</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">6 command.txt</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">8 shell_tmp.html</span> </p>
    <p class="Textbody">Добавление к опции -s ещё и опции -k (то есть ls -sk) выведет всю ту же информацию в килобайтах.</p>
    <p class="Textbody">Как можно видеть из всех приведённых выше примеров, списки файлов по команде ls выводится в многоколоночном виде (чему соответствует опция -C, однако указывать ее нет необходимости — многоколоночный вид принят для краткого формата по умолчанию). Но можно задать и одноколоночное представление списка посредством опции -1:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ ls -1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dir1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dir2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dir3</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">file1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">file2</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">file3</span> </p>
    <p class="Textbody">До сих пор речь шла о кратком формате вывода команды ls. Однако более информативным является т.н. длинный ее формат, вывод в котором достигается опцией -l и автоматически влечет за собой одноколоночное представление списка:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ ls -l</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">total 8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x  2 alv  alv  512  8 май 18:04 dir1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x  3 alv  alv  512  8 май 17:43 dir2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">lrwxr-xr-x  1 alv  alv    4  9 май 07:59 dir3 -&gt; dir2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">-rw-r--r--  1 alv  alv   14  8 май 10:39 file1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">-rwxr-xr-x  1 alv  alv   30  9 май 08:02 file2</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">lrwxr-xr-x  1 alv  alv    2  8 май 10:57 file3 -&gt; f1</span> </p>
    <p class="Textbody">Можно видеть, что по умолчанию в длинном формате выводятся:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">сведения о типе файла (- — регулярный файл, d — каталог, l — символическая ссылка, c — файл символьного устройства, b — файл блочного устройства) и атрибуты доступа для различных атрибутов принадлежности (о чем было сказано достаточно); </p>
      </li>
      <li>
        <p class="Textbody">количество жёстких ссылок на данный идентификатор inode; </p>
      </li>
      <li>
        <p class="Textbody">имя пользователя — владельца файла, и группы пользователей, которой файл принадлежит; </p>
      </li>
      <li>
        <p class="Textbody">размер файла в блоках; </p>
      </li>
      <li>
        <p class="Textbody">время модификации файла с точностью до месяца, дня, часа и минуты (в формате, принятом в данной locale); </p>
      </li>
      <li>
        <p class="Textbody">имя файла и (для символических ссылок) имя файла-источника. </p>
      </li>
    </ul>
    <p class="Textbody">Однако это ещё не всё. Добавив к команде ls -l ещё и опцию -i, можно дополнительно получить идентификатор inode каждого файла, опция -n заменит имя владельца и группу на их численные идентификаторы (UID и GUID, соответственно), а опция -T выведет в поле времени модификации ещё и годы, и секунды:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ ls -linT</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">total 8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">694402 drwxr-xr-x  2 1000  1000  512  8 май 18:04:56 2002 dir1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">694404 drwxr-xr-x  3 1000  1000  512  8 май 17:43:31 2002 dir2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">673058 lrwxr-xr-x  1 1000  1000    4  9 май 07:59:08 2002 dir3 -&gt; dir2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">673099 -rw-r--r--  1 1000  1000   14  8 май 10:39:38 2002 file1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">673059 -rwxr-xr-x  1 1000  1000   30  9 май 08:02:23 2002 file2</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">673057 lrwxr-xr-x  1 1000  1000    2  8 май 10:57:07 2002 file3 -&gt; f1</span> </p>
    <p class="Textbody">Разумеется, никто не запрещает использовать в длинном формате и опции визуализации (-F и -G), и опции сортировки (-r, t, tu), и любые другие, за исключением опции -C — указание ее ведет к принудительному выводу списка в многоколоночной форме, что естественным образом подавляет длинный формат представления.</p>
    <p class="Textbody">Я столь подробно остановился на описании команды ls потому, что это — основное средство визуализации файловых систем любого Unix, при умелом использовании ничуть не уступающее развитым файловым менеджерам (типа Midnight Commander или Konqueror) по своей выразительности и информативности. И отнюдь не требующее для достижения таковых вбивания руками многочисленных опций: со временем будет показано, что соответствующей настройкой последних можно добиться любого «умолчального» вывода команды ls.</p>
    <p class="Textbody">Существуют и другие команды для получения информации о файлах. Например, команда под характерным именем file с аргументом в виде имени файла в состоянии определить тип его, а также характер содержания с большой детальностью. Так, для регулярных файлов она распознает:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">исполняемые бинарные файлы с указанием их формата (например, ELF), архитектуры процессора, для которых они скомпилированы, характер связи с разделяемыми библиотеками (статический или динамический); </p>
      </li>
      <li>
        <p class="Textbody">исполняемые сценарии с указанием оболочки, для которой они созданы; </p>
      </li>
      <li>
        <p class="Textbody">текстовые и html-документы, часто с указанием используемого набора символов. </p>
      </li>
    </ul>
    <p class="Textbody">Последнему, впрочем, для русскоязычных документов доверять особо не следует: кодировка KOI8-R в них вполне может быть обозвана ISO-8859.</p>
    <p class="Textbody">Определяет она также каталоги, символические ссылки, специальные файлы устройств, указывая для последних старшие и младшие номера устройств.</p>
    <p class="Textbody">Наконец, команда stat (это — встроенная команда оболочки), с именем файла в качестве аргумента, выводит большую часть существенных сведений о файле в удобном для восприятия виде, например, включая идентификатор inode, режим доступа (в символьной форме), идентификаторы владельца и группы, временные атрибуты, количество жёстких и символических ссылок.</p>
    <h3 id="toc94"><a id="RefHeading16301713816058"></a><a id="bkmRefHeading16301713816058"></a><a id="toc93"></a><a id="bkmtoc93"></a><a id="RefHeading4781136957987"></a><a id="bkmRefHeading4781136957987"></a><a id="bkmRefHeading4781136957987"></a><a id="bkmbkmRefHeading4781136957987"></a>Манипулирование файлами</h3>
    <p class="Textbody">Перейдем к манипуляциям с существующими файлами — копированию, перемещёнию, переименованию, удалению.</p>
    <p class="Textbody">Начнем с копирования — это выполняется очень простой командой, cp, имеющей, однако, весьма разнообразные аспекты применения. В самом простом своем виде она требует всего двух аргументов — имени файла-источника на первом месте и имени целевого файла — на втором:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cp file_source file_target</span> </p>
    <p class="Textbody">Этим в текущем каталоге создается новый файл (file_target), идентичный по содержанию копируемому (file_source). То есть область данных первого будет дублировать таковую последнего. Однако области метаданных у них будут различны изначально. Целевой файл — это именно новый файл, со своим иднетификатором inode, заведомо иными временными атрибутами; его атрибуты доступа и принадлежности в общем случае также не обязаны совпадать с таковыми файла-источника.</p>
    <p class="Textbody">Новый файл может быть создан и в произвольном каталоге, к которому пользователь имеет соответствующий доступ: для этого следует только указать полный путь к нему:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cp file_source dir/subdir/file_target</span> </p>
    <p class="Textbody">Если в качестве второго аргумента команды указано просто имя каталога, то новый файл будет создан в нем с именем, идентичным имени файла-источника. Однако подчеркну, что в любом случае копирования создается именно новый файл, никак после этого не связанный с файлом исходным.</p>
    <p class="Textbody">Если в качестве последнего аргумента выступает имя каталога, он может предваряться любым количеством аргументов — имен файлов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cp file1 file2 ... file3 dir/</span> </p>
    <p class="Textbody">В этом случае в целевом каталоге dir/ будут созданы новые файлы,<br />идентичные по содержанию файлам file1, file2 и т.д.</p>
    <p class="Textbody">Если в целевом (или текущем) каталоге уже имеется файл с именем, совпадающим с именем вновь создаваемого файла, он в общем случае будет без предупреждения заменен новым файлом. Единственное средство для предотвращения этого — задание опции -i (от interactive) — при ее наличии последует запрос<br />на перезапись существующего файла:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ cp -i file1 file2</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">overwrite file2? (y/n [n])</span> </p>
    <p class="Textbody">Как говорилось в предыдущем очерке, командная оболочка моетт быть настроена так, чтобы по умолчанию не допускать перезаписи существующих файлов. Однако если такая потребность осознанно возникнет, это можно выполнить с помощью опции -f (от force). К слову сказать, она также аннулирует действие опции -i, например, при использовании ее в псевдониме команды cp.</p>
    <p class="Textbody">Имя каталога может выступать и в качестве первого аргумента команды cp. Однако это потребует опции -R (иногда допустима и опция -r — в обоих случаях от recursive). В этом случае второй аргумент также будет воспринят как имя каталога, который не только будет создан при этом, но в нем также будет рекурсивно воспроизведено содержимое каталога источника (включая и вложенные подкаталоги).</p>
    <p class="Textbody">При копировании файлов, представляющих собой символические ссылки, они будут преобразованы в регулярные файлы, копирующие содержимое файлов — источников ссылки. Однако при рекурсивном копировании каталогов, содержащих символические ссылки, возможно их воспроизведение в первозданном виде. Для этого вместе с опцией -R должна быть указана одна из опций -H или -L. Однако обе они при отсутствии -R игнорируются.</p>
    <p class="Textbody">Как уже было сказано, создаваемые при копировании целевые файлы по умолчанию получают атрибуты доступа и времени, не зависящие от таковых файла-источника. Обычно они определяются значением переменной umask, заданной глобально, в профильном файле командной оболочки пользователя. Однако при желании атрибуты исходного файла можно сохранить в файле целевом — для этого предназначена опция -p. Разумеется, атрибуты эти будут сохранены только в том случае, это это допустимо целевой файловой системой: не следует ожидать, что атрибуты доступа и принадлежности будут сохранены при копировании на носитель с файловой системой FAT.</p>
    <p class="Textbody">Для выполнения операции копирования файла он должен иметь атрибут чтения для пользователя, выполняющего копирование; кроме того, последний должен обладать правом на изменение каталога, в который производится копирование.</p>
    <p class="Textbody">Следующие две часто используемые файловые операции — переименование и перемещёние, — выполняются одной командой, mv.</p>
    <p class="Textbody">Как и при копировании, при перемещёнии и переименовании одноименные файлы, ранее существовавшие в целевом каталоге, затираются, замещаясь файлами-источниками без предупреждения. Чтобы этого не случилось, используется опция -i, требующая запрос на подтверждение действия. Напротив, опция -f в принудительном порядке перезаписывает существующий файл.</p>
    <p class="Textbody">Операции копирования и перемещёния/переименования выглядят сходными, однако по сути своей глубоко различны. Начать с того, что команда mv не совершает никаких действий с перемещаемыми или переименовываемыми файлами — она модифицирует каталоги, к которым приписаны имена этих файлов. Это имеет два важных следствия. Во-первых, при перемещёнии/переименовании файлы сохраняют первозданными атрибуты доступа, принадлежности и даже времени изменения метаданных (ctime) и модификации данных (mtime) — ведь ни те, ни другие при перемещёнии/переименовании файла не изменяются.</p>
    <p class="Textbody">Во-вторых, для выполнения этих действий можно не иметь никаких вообще прав доступа к файлам — достаточно иметь право на изменение каталогов, в которых они переименовываются или перемещаются: ведь имя файла фигурирует только в составе каталога, и нигде более.</p>
    <p class="Textbody">Файлы приходится не только создавать, но иногда и удалять. Смысл удаления файлов аналогичен их перемещнию — с самими файлами при этом ничего не происходит, а изменяются содержащие их каталоги. Удаление файлов выполняется командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ rm filename</span> </p>
    <p class="Textbody">в которой аргументов, означающих имена подлежащих удалению файлов, может быть произвольное количество. Как и при перемещёнии, при этом не затрагиваются ни метаданные, ни данные файлов, а только удаляются их имена из родительских каталогов. И потому для удаления файлов опять же не обязательно иметь какие-либо права в их отношении — достаточно прав на изменение содержащих их каталогов.</p>
    <p class="Textbody">Командой rm файлы-аргументы будут удалены в общем случае без предупреждения. Подобно командам cp и mv, для команды rm предусмотрены опции -i (запрос на подтверждение) и -f (принудительное удаление вне зависимости от настроек оболочки).</p>
    <p class="Textbody">Интересный момент — удаление случайно созданных файлов с именами, «неправильными» с точки зрения системы или командной оболочки. Примером этого могут быть имена, начинающиеся с символа дефиса. Если попробовать сделать это обычным образом</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ rm -file</span> </p>
    <p class="Textbody">в ответ последует сообщение об ошибке типа</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">rm: illegal option — l</span> </p>
    <p class="Textbody">то есть имя файла будет воспринято как опция. Для предотвращения этого такое «неправильное» имя следует предварить символом двойного дефиса и пробелом, означающими конец списка опций:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ rm — -file</span> </p>
    <p class="Textbody">В принципе, команда rm ориентирована на удаление обычных и прочих файлов, но не каталогов. Однако с опцией -d она в состоянии справиться и с этой задачей — в случае, если удаляемый каталог пуст. Наконец, опция -R (или -r) производит рекурсивное удаление каталогов со всеми их файлами и вложенными подкаталогами.</p>
    <p class="Textbody">Это делает использование опции -R весьма опасным: возможно, набивший оскомину пример</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ rm -R /</span> </p>
    <p class="Textbody">когда при наличии прав суперпользователя уничтожается вся файловая система, и утрирован, но в локальном масштабе такая операция более чем реальна.</p>
    <p class="Textbody">Специально для удаления каталогов предназначена команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ rmdir</span> </p>
    <p class="Textbody">которая способна удалить только пустой каталог. Кроме того, с опцией -p она может сделать это и в отношении каталогов родительских — но также только в том случае, если они не содержат файлов.</p>
    <p class="Textbody">Кроме простого копирования файлов, существует команда для копирования с преобразованием — dd. Обобщенный ее формат весьма прост:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ dd [options]</span> </p>
    <p class="Textbody">то есть она просто копирует файл стандартного ввода в файл стандартного вывода, а опции описывают условия преобразования входного потока данных в выходной. Реально основными опциями являются if=file1, подменяющая стандартный ввод указанным файлов, и of=file2, проделывающая ту же операцию со стандартным выводом.</p>
    <p class="Textbody">А далее — прочие условия преобразования, весьма обильные. Большинство из них принимают численные значения в блоках:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">опции ibs=n и obs=n устанавливают размер блока для входного и выходного потоков, bs=n — для обоих сразу; </p>
      </li>
      <li>
        <p class="Textbody">опция skip=n указывает, сколько блоков нужно пропустить перед записью входного потока; </p>
      </li>
      <li>
        <p class="Textbody">опция count=n предписывает скопировать из входного потока лишь указанное количество блоков, отсчитываемых с начала файла-источника. </p>
      </li>
    </ul>
    <p class="Textbody">Сфера применения команды dd далеко выходит за рамки простого копирования файлов. Например, именно с ее помощью изготавливаются загрузочные флешки и SD-карты, точные копии CD в файловой системе на винчестере, преобразуются шрифтовые файлы из одного формата в другой, и ещё многое. Эта же команда может применяться для резервного копирования данных.</p>
    <h3 id="toc95"><a id="RefHeading16321713816058"></a><a id="bkmRefHeading16321713816058"></a><a id="toc94"></a><a id="bkmtoc94"></a><a id="RefHeading4801136957987"></a><a id="bkmRefHeading4801136957987"></a><a id="bkmRefHeading4801136957987"></a><a id="bkmbkmRefHeading4801136957987"></a>Архивация…</h3>
    <p class="Textbody">Для пользователя Windows, привыкшего к программам типа Zip/WinZip и Rar/WinRar, архивация и компрессия неразрывны, как лошади в упряжке. Однако это — вполне разные действия.</p>
    <p class="Textbody">Архивация — это сборка группы файлов или каталогов в единый файл, содержащий не только данные файлов-источников, но и информацию о них — имена файлов и каталогов, к которым они приписаны, атрибуты принадлежности, доступа и времени, что позволяет восстановить как данные, так и их структуру из архива в первозданном виде. Компрессия же предназначена исключительно для уменьшения объёма, занимаемого файлами на диске (или ином носителе).</p>
    <p class="Textbody">Для архивации и компрессии предназначены самостоятельные команды. Хотя архивацию и компрессию можно объединить в одной конструкции или представить так, будто они выполняются как бы в едином процессе.</p>
    <p class="Textbody">Традиционное и самое распространённое средство архивации в Unix-системах — утилита tar. Обобщенный формат ее таков:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar [options] archiv_name [arguments]</span> </p>
    <p class="Textbody">где archiv_name — обязательный аргумент, указывающий на имя архивного файла, с которым производятся действия, определяемые главными опциями. Формы указания опций для команды tar очень разнообразны. Исторически первой была краткая форма без предваряющего дефиса, что поддерживается и поныне. Однако в текущих версиях команды в целях единообразия утверждена краткая форма с предваряющим дефисом или дублирующая ее полная форма, предваряемая двумя дефисами. Некоторые опции (например --help — получение справки об использовании команды) предусмотрены только в полной форме.</p>
    <p class="Textbody">Главные опции и указывают на то, какие действия следует выполнить над архивом в целом:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">создание архива (опция c, -c или --create); </p>
      </li>
      <li>
        <p class="Textbody">просмотр содержимого существующего архива (опция t, -t или --list); </p>
      </li>
      <li>
        <p class="Textbody">распаковка архива (опция x, -x, --extract или --get). </p>
      </li>
    </ul>
    <p class="Textbody">Легко понять, что при работе с архивом как целым одна из этих главных (т.н. функциональных) опций обязательна. При манипулировании же фрагментами архива они могут подменяться другими функциональными опциями, как то:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">r (или --append) - добавление новых файлов в конец архива; </p>
      </li>
      <li>
        <p class="Textbody">u (или --update) - обновление архива с добавлением не только новых, но и модифицированных (с меньшим значением атрибута mtime) файлов; </p>
      </li>
      <li>
        <p class="Textbody">-A (--catenate или --concatenate) - присоединение одного архива к другому; </p>
      </li>
      <li>
        <p class="Textbody">--delete - удаление именованных файлов из архива; </p>
      </li>
      <li>
        <p class="Textbody">--compare - сравнение архива с его источниками в файловой системе. </p>
      </li>
    </ul>
    <p class="Textbody">Прочие (очень многочисленные) опции можно отнести в разряд дополнительных — они определяют условия выполнения основных функций команды. Однако одна из таких дополнительных опций — f (-f или --file), значение которой — имя файла (в том числе файла устройства, и не обязательно на локальной машине), также является практически обязательной. Дело в том, что команда tar (от tape archiv) изначально создавалась для прямого резервного копирования на стриммерную ленту, и именно это устройство подразумевается в качестве целевого по умолчанию. Так что если это не так (а в нынешних условиях — не так почти наверняка), имя архивного файла в качестве значения опции f следует указывать явно.</p>
    <p class="Textbody">Проиллюстрируем сказанное несколькими примерами. Так, архив из нескольких файлов текущего каталога создается следующим образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar cf arch_name.tar file1 ... file#</span> </p>
    <p class="Textbody">Если задать дополнительную опцию v, ход процесса будет отображаться на экране — это целесообразно, и в дальнейших примерах эта опция будет использоваться постоянно.</p>
    <p class="Textbody">С помощью команды tar можно заархивировать и целый каталог, включая его подкаталоги любого уровня вложенности, причём - двояким образом. Так, если дать команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar cvf arch_name.tar *</span> </p>
    <p class="Textbody">файлы каталога текущего каталога (включая подкаталоги) будут собраны в единый архив, но без указания имени каталога родительского. А командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar cvf arch_name.tar dir</span> </p>
    <p class="Textbody">каталог dir будет упакован с полным сохранением его структуры.</p>
    <p class="Textbody">С помощью команды</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar xvf arch_name.tar</span> </p>
    <p class="Textbody">будет выполнена обратная процедура — распаковка заархивированных файлов в текущий каталог. Если при архивировании в качестве аргумента было указано имя каталога, а не набора файлов (пусть даже в виде шаблона) - этот каталог будет восстановлен в виде корневого для всех<br />разархивируемых файлов.</p>
    <p class="Textbody">При извлечении файлов из архива никто не обязывает нас распаковывать весь архив — при необходимости это можно сделать для одного нужного файла, следует только указать его имя в качестве аргумента:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar xvf arch_name.tar filename</span> </p>
    <p class="Textbody">Правда, если искомый файл находился до архивации во вложенном подкаталоге, потребуется указать и путь к нему — от корневого для архива каталога, который будет различным для двух указанных схем архивации. Ну а для просмотра того, каким образом был собран наш архив, следует воспользоваться командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar tf arch_name.tar</span> </p>
    <p class="Textbody">Если архив собирался по первой схеме (с именами файлов в качестве аргументов, вывод ее будет примерно следующим:</p>
    <p class="Textbody"><span style="background-color:#dddddd">dir2/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dir2/file1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">example</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">new</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">newfile</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">tee.png</span> </p>
    <p class="Textbody">При втором способе архивации мы увидим на выводе нечто вроде</p>
    <p class="Textbody"><span style="background-color:#dddddd">dir1/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dir1/example</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dir1/new</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dir1/newfile</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dir1/tee.png</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dir1/dir2/</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">dir1/dir2/file1</span> </p>
    <p class="Textbody">В данном примере опция v была опущена. Включение ее приведет к тому, что список файлов будет выведен в длинном формате, подобном выводу команды ls -l:</p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x alv/alv      0 10 май 11:03 2002 dir2/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">-rw-r--r-- alv/alv      0 10 май 11:03 2002 dir2/file1</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">Команда tar имеет ещё множество дополнительных опций, призванных предотвращать перезапись существующих файлов, осуществлять верификацию архивов, учитывать при архивации разного рода временные атрибуты, вызывать для исполнения другие программы. К некоторым опциям я ещё вернусь после рассмотрения команд компрессии, другие же предлагается изучить самостоятельно, воспользовавшись страницей экранной документации man tar.</p>
    <p class="Textbody">Здесь уместно добавить пару слов об утилите ar, предназначенной для создания архивов, их модификации, частичной экстракции из них файлов и полного развёртывания. Подобно tar, это — чистый архиватор, не выполняющий никакой компрессии. И, насколько я знаю, практически не используемый для архивирования данных, в частности, для резервного копирования. Но исторически сложилось так, что именно утилитой ar в конечном счёте упаковываются компоненты пакетов deb-формата, используемого в Mint (и многих других дистрибутивах).</p>
    <h3 id="toc96"><a id="RefHeading16341713816058"></a><a id="bkmRefHeading16341713816058"></a><a id="toc95"></a><a id="bkmtoc95"></a><a id="RefHeading4821136957987"></a><a id="bkmRefHeading4821136957987"></a><a id="bkmRefHeading4821136957987"></a><a id="bkmbkmRefHeading4821136957987"></a>… и компрессия</h3>
    <p class="Textbody">Утилита gzip — это традиционный компрессор Unix-систем, сменивший в сей роли более старую утилиту compress. Простейший способ её использования таков:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ gzip filename</span> </p>
    <p class="Textbody">где в качестве аргументов будет выступать имя файла. При этом (внимание!) исходный несжатый файл подменяется своей сжатой копией, которой автоматически присваивается расширение *.gz.</p>
    <p class="Textbody">В качестве аргументов может выступать и произвольное количество имен файлов — каждый из них будет заменен сжатым файлом *.gz. Более того, посредством опции -r может быть выполнено рекурсивное сжатие файлов во всех вложенных подкаталогах. Подчеркну, однако, что никакой архивации команда gzip не производит, обрабатывая за раз только единичный файл. Фактически форма</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ gzip file1 file2 ... file#</span> </p>
    <p class="Textbody">просто эквивалент последовательности команд</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ gzip file1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">$ gzip file2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ gzip file#</span> </p>
    <p class="Textbody">Правда, объединение компрессированных файлов возможно методом конкатенации (с помощью команды cat) или посредством архивирования командой tar.</p>
    <p class="Textbody">Команда gzip имеет и другие опции, указываемые в краткой (однобуквенной) или полной нотации. В отличие от tar, знак дефиса (или, соответственно, двойного дефиса) обязателен в обоих случаях. Так, опциями -1 … -9 можно задать степень сжатия и, соответственно, время исполнения процедуры: -1 соответствует минимальному, но быстрому сжатию, -9 - максимальному, но медленному. По умолчанию в команде gzip используется опция -6, обеспечивающая разумный компромисс между скоростью и компрессией.</p>
    <p class="Textbody">Благодаря опции -d (--decompress) команда gzip может выполнить развертывание сжатого файла, заменяя его оригиналом без расширения *.gz. Хотя в принципе для этого предназначена команда gunzip:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ gunzip file.gz</span> </p>
    <p class="Textbody">Использование этой команды настолько прозрачно, что я задерживаться на ней не буду. Замечу только, что утилита gzip интегрирована в архиватор tar, вызвываясь из него опцией z. То есть для создания компрессированного архива потребуется такая команда:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar czf archive.tar.gz path2/</span> </p>
    <p class="Textbody">А для декомпрессии и развёртывания архива — такая:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar xzf archive.tar.gz</span> </p>
    <p class="Textbody">В обоих случаях не принесёт вреда добавление опции v — она обеспечит вывод на экран сообщеня о ходе процесса.</p>
    <p class="Textbody">В относительно недавнее время некоторое распространение получил компрессор bzip2, обеспечивающий большую (на 10-15%) степень сжатия, хотя и менее быстродействующий. Использование его практически идентично gzip, с деталями его можно ознакомиться с помощью страницы экранной документации man bzip2.</p>
    <p class="Textbody">Итоговый компрессированный файл получает имя вида *.bz2 и может быть распакован командой bunzip2 (или командой bzip2 -d). Следует только помнить, что форматы *.gz и *.bz2 не совместимы между собой. Соответственно, первый не может быть распакован программой bunzip2, и наоборот.</p>
    <p class="Textbody">Как и gzip, утилита bzip2 может быть вызвана из архиватора tar — при создании компрессированного архива так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar cjf archive.tar.bz2 path2/</span> </p>
    <p class="Textbody">А при развёртывании оного — эдак:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar xjf archive.tar.bz2</span> </p>
    <p class="Textbody">Особо задерживаться на этой утилите не хочется ещё и потому, что, мне кажется, вскоре она выйдет из употребеления. Ибо, обеспечивая меньшую степень сжатия по сравнению с форматом xz (о котором сейчас будет речь), bzip2 отнюдь не превосходит его по скорости компрессии и декомпрессии. И там, где критично именно время упаковки (а также универсальность), будет по прежнему использоваться старый добрый gzip. Там же, где на первый план выходит степень сжатия, карты в руки новому формату xz. Который, кстати, на мощных машинах по скорости создания и распаковки вплотную приближается к gzip.</p>
    <p class="Textbody">Реализацией формата xz является набор утилит XZ Utils, основанный на алгоритме LZMA (Lempel-Ziv-Markov chain-Algorithm). Сам по себе метод сжатия LZMA существует достаточно давно: он был разработан нашим соотечественником Игорем Павловым с использованием достижений предшественников, разработавших алгоритмы LZ77, LZ78 и LZV — что, впрочем, могло бы составить предмет отдельной истории, которую когда-нибудь кто-нибудь напишет.</p>
    <p class="Textbody">А метод LZMA был задействован его автором в собственной же разработке — утилите компрессии 7-Zip для Windows, быстро снискавшей славу несравненного «сжимателя» файлов. Инструментарий для разработки программ, использующих данный метод (LZMA SDK) распространялся сначала на условиях лицензии GPL, что позволяло использовать его в соответствующих проектах (например, в GNU tar). Однако в конце 2008 года Игорь Павлов превратил его в общественное достояние (Public Domain). Вслед за чем был создан основанный на этом методе пакет LZMA Utils, немедленно встроенный в tar. Что сделало этот метод компрессии столь же простым и обыденным, как gzip или bzip2. И с тех пор эта возможность, после установки соответствующего пакета, присутствует во всех дистрибутивах Linux.</p>
    <p class="Textbody">Правда, вслед за тем появился LZMA2, улучшенная версия того же алгоритма, обеспечивающий более высокую степень сжатия и лучшую поддержку многопоточности. А на его основе был создан пакет XZ Utils — именно он в настоящее время используется в Mint по умолчанию. И включает в себя такие команды:</p>
    <p class="Textbody">xz — компрессор и, при указании опции --decompress, декомпрессор;</p>
    <p class="Textbody">unxz — собственно декомпрессор;</p>
    <p class="Textbody">xzcat осуществляет декомпрессию на стандартный вывод;</p>
    <p class="Textbody">xzmore и xzless — pager'ы для lzma-компрессированных текстовых файлов;</p>
    <p class="Textbody">xzgrep, xzegrep, xzfgrep — поиск текстовых фрагментов в xz-компрессированных файлах.</p>
    <p class="Textbody">Последние три утилиты работают аналогично командам xzgrep, xzegrep, xzfgrep, применённым к некомпрессированным файлам. А команда xzcat является аналогом утилиты cat. Об этих четырёх командах будет подробно говориться в ближайших разделах.</p>
    <p class="Textbody">Утилиты пакета XZ Utils могут, с некоторыми ограничениями, работать с файлами, запакованными старым методом LZMA1 (но не наоборот). Хотя сами по себе пакеты XZ Utils и LZMA Utils между собой конфликтуют.</p>
    <p class="Textbody">Разумеется, поддержка XZ была немедленно встроена и в tar. Так что теперь для применения компрессии LZMA2 при создании tar-архива достаточно указать соответствующую опцию:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar --create --xz --file filename.tar.xz path2/arch_dir</span> </p>
    <p class="Textbody">Или, в более употребимой простыми людьми краткой форме, так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar cJf filename.tar.lzma path2/arch_dir</span> </p>
    <p class="Textbody">где опция J и представляет собой алиас для полной формы -xz. Если присваивать архивному файлу суффикс по правилам утилиты tar, опцию J можно заменить на a (что эквивалентно полной форме --auto-compress), обеспечивающей определение типа компрессии по «расширению» *.xz. Более того, скажу по секрету: если архив именован по правилам, то можно опустить даже опцию --auto-compress — она и так будет задействована по умолчанию.</p>
    <p class="Textbody">Распаковка xz-компрессированного архива выполняется в обратном порядке:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar xJf filename.tar.xz</span> </p>
    <p class="Textbody">или<br />$ tar xaf filename.tar.xz</p>
    <p class="Textbody">Метод LZMA и особенно LZMA2 вследствие эффективности компрессии быстро нашёл себе применение в сборке дистрибутивных пакетов: именно с его помощью в настоящее время сжимаются deb-пакеты Mint (и всех других дистрибутивов, использующих этот формат пакетов).</p>
    <h3 id="toc97"><a id="RefHeading16361713816058"></a><a id="bkmRefHeading16361713816058"></a><a id="toc96"></a><a id="bkmtoc96"></a><a id="RefHeading4841136957987"></a><a id="bkmRefHeading4841136957987"></a><a id="bkmRefHeading4841136957987"></a><a id="bkmbkmRefHeading4841136957987"></a>Утилита find и xargs при ней</h3>
    <p class="Textbody">На этих страницах речь пойдет о пакете, известном в проекте GNU как findutils. И в первую голову — о команде find (как, впрочем, и о тесно связанной с ней команде xargs). Столь высокая честь выпадает им потому, что посредством этих двух команд можно выполнить если не все, то изрядную задач, возникающих при работе с файлами.</p>
    <p class="Textbody">Итак, апофеоз командного файлового менеджмента — утилита find. Строго говоря, вопреки своему имени, команда эта выполняет не поиск файлов как таковой, но — рекурсивный обход дерева каталогов, начиная с заданного в качестве аргумента, отбирает из них файлы в соответствие с некоторыми критериями и выполняет над отбракованным файловым хозяйством некоторые действия. Именно эту ее особенность подчеркивает резюме команды find, получаемое (в некоторых системах) посредством</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ whatis find</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">find(1)                  — walk a file hierarchy</span> </p>
    <p class="Textbody">что применительно случаю можно перевести как «прогулка по файловой системе».</p>
    <p class="Textbody">Команда find по своему синтаксису существенно отличается от большинства прочих Unix-команд. В обобщенном виде формат ее можно представить следующим образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find аргумент [опция_поиска] [значение] [опция_действия]</span> </p>
    <p class="Textbody">В качестве аргумента здесь задается путь поиска, то есть каталог, начиная с которого следует совершать обход файловой системы, например, корень ее:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ find / [опция_поиска] [значение]</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        [опция_действия]</span> </p>
    <p class="Textbody">или домашний каталог пользователя:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ find ~/ [опция_поиска] [значение]</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        [опция_действия]</span> </p>
    <p class="Textbody">Опция поиска — критерий, по которому следует отбирать файл (файлы) из определенных в аргументе частей файловой системы. В качестве таковых могут выступать имя файла (-name), его тип (-type), атрибуты принадлежности, доступа или времени.</p>
    <p class="Textbody">Ну а опция действия определяет, что же надлежит сделать с отобранными файлом или файлами. А сделать с ними, надо заметить, можно немало — начиная с вывода на экран (-print, опция действия по умолчанию) и кончая передачей в качестве аргументов любой другой команде (-exec).</p>
    <p class="Textbody">Как можно видеть из примера, опция поиска и опция действия предваряются знаком дефиса, значение первой отделяется от ее имени пробелом.</p>
    <p class="Textbody">Однако начнём по порядку. Опции поиска команды find позволяют выполнить отбор файлов по следующим критериям (символ дефиса перед опциями ниже опущен, но не следует забывать его ставить):</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">name — поиск по имени файла или по маске имени; в последнем случае метасимволы маски должны обязательно экранироваться (например, — name \*.tar.gz) или заключаться в кавычки (одинарные или двойные, в зависимости от ситуации); этот критерий чувствителен к регистру, но близкий по смыслу критерий iname позволяет производить поиск по имени без различения строчных и заглавных букв; </p>
      </li>
      <li>
        <p class="Textbody">type — поиск по типу файла; этот критерий принимает следующие значения: f (регулярный файл), d (каталог), s (символическая ссылка), b (файл блочного устройства), c (файл символьного устройства); </p>
      </li>
      <li>
        <p class="Textbody">user и group — поиск по имени или идентификатору владельца или группы, выступающим в качестве значения критерия; существует также критерии nouser и nogroup — они отыскивают файлы, владельцев и групповой принадлежности не имеющие (то есть тех, учетные записи для которых отсутствую в файлах /etc/passwd и /etc/group); последние два критерия в значениях, разумеется, не нуждаются; </p>
      </li>
      <li>
        <p class="Textbody">size — поиск по размеру, задаваемому в виде числа в блоках или в байтах — в виде числа с последующим символом c; возможны значения n (равно n блоков), +n (более n блоков), -n (менее n блоков); </p>
      </li>
      <li>
        <p class="Textbody">perm — поиск файлов по значениям их атрибутов доступа, задаваемых в символьной форме; </p>
      </li>
      <li>
        <p class="Textbody">atime, ctime, mtime — поиск файлов с указанными временными атрибутами; значения временных атрибутов указываются в сутках (точнее, в периодах, кратных 24 часам); возможны формы значений этих атрибутов: n (равно указанному значению n*24 часа), +n (ранее n*24 часа), -n (позднее n*24 часа); </p>
      </li>
      <li>
        <p class="Textbody">newer — поиск файлов, измененных после файла, указанного в качестве значения критерия (то есть имеющего меньшее значение mtime); </p>
      </li>
      <li>
        <p class="Textbody">maxdepth и mindepth позволяют конкретизировать глубину поиска во вложенных подкаталогах — меньшую или равную численному значению для первого критерия и большую или равную — для второго; </p>
      </li>
      <li>
        <p class="Textbody">depth — производит отбор в обратном порядке, то есть не от каталога, указанного в качестве аргумента, а с наиболее глубоко вложенных подкаталогов; смысл этого действия — получить доступ к файлам в каталоге, для которого пользователь не имеет<br />права чтения и исполнения; </p>
      </li>
      <li>
        <p class="Textbody">prune — позволяет указать подкаталоги внутри пути поиска, в которых отбора файлов производить не следует. </p>
      </li>
    </ul>
    <p class="Textbody">Кроме этого, существует ещё одна опция поиска — fstype, предписывающая выполнять поиск только в файловой системе указанного типа; очевидно, что она может сочетаться с любыми другими опциями поиска. Например, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find / -fstype ext3 -name zsh*</span> </p>
    <p class="Textbody">будет искать файлы, имеющие отношение к оболочке Z-Shell, начиная с корня, но только — в пределах тех разделов, на которых размещёна файловая система Ext3fs (на моей машине — это именно чистый корень, за вычетом каталогов /usr, /opt, /var, /tmp и, конечно же, /home.</p>
    <p class="Textbody">Критерии отбора файлов могут группироваться практически любым образом. Так, в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find ~/ -name *.tar.gz newer filename</span> </p>
    <p class="Textbody">она выберет в домашнем каталоге пользователя все компрессированные архивы, созданные после файла с именем filename. По умолчанию между критериями отбора предполагается наличие логического оператора AND (логическое «И»). То есть будут отыскиваться файлы, удовлетворяющие и маске имени, и соответствующему атрибуту времени. Если требуется использование оператора OR (логическое «ИЛИ»), он должен быть явно определен в виде дополнительной опции -o между опциями поиска. Так, команда:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find ~/ -mtime -2 -o newer filename</span> </p>
    <p class="Textbody">призвана отобрать файлы, созданные менее двух суток назад, или же — позднее, чем файл filename.</p>
    <p class="Textbody">Особенность GNU-реализации команды find (как, впрочем, и ее тезки из числа BSD-утилит) — то, что она по умолчанию выводит список отобранных в соответствии с заданными критериями файлов на экран, не требуя дополнительных опций действия. Однако, как говорят, в других Unix-системах (помнится, даже и в некоторых реализациях Linux мне такое встречалось) указание какой-либо из таких опций — обязательно. Так что рассмотрим их по порядку.</p>
    <p class="Textbody">Для выведения списка отобранных файлов на экран в общем случае предназначена опция -print. Вывод этот имеет примерно следующий вид:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ find . -name f* -print</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">./file1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">./file2</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">./dir1/file3</span> </p>
    <p class="Textbody">Сходный смысл имеет и опция -ls, однако она выводит более полные сведения о найденных файлах, аналогично команде ls с опциями -dgils:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ find / -fstype ext3 -name zsh -ls</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">88161  511 -rwxr-xr-x   1 root  root    519320 Ноя 23 15:50 /bin/zsh</span> </p>
    <p class="Textbody">Важное, как мне кажется, замечание. Если команда указанного вида будет дана от лица обычного пользователя (не root-оператора), кроме приведенной выше строки вывода, последуют многочисленные сообщения вроде</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">find: /root: Permission denied</span> </p>
    <p class="Textbody">указывающие на каталоги, закрытые для просмотра обычным пользователем, и весьма мешающие восприятию результатов поиска. Чтобы подавить их, следует перенаправить вывод сообщения об ошибках в файл /dev/null, то есть указать им «Дорогу никуда»:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find / -fstype ext3 -name zsh -ls 2&gt; /dev/null</span> </p>
    <p class="Textbody">Идем далее. Опция -delete уничтожит все файлы, отобранные по указанным критериям. Так, командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find ~ -atime +100 -delete</span> </p>
    <p class="Textbody">будут автоматически стерты все файлы, к которым не было обращения за последние 100 дней (из молчаливого предположения, что раз к ним три месяца не обращались — значит, они и вообще не нужны). Истреблению подвергнутся файлы в подкаталогах любого уровня вложенности — но не<br />включающие их подкаталоги (если, конечно, последние сами не подпадают под критерии отбора).</p>
    <p class="Textbody">И, наконец, опция -exec — именно ею обусловлено величие утилиты find. В качестве значения ее можно указать любую команду с необходимыми опциями — и она будет выполнена над отобранными файлами, которые будут рассматриваться в качестве ее аргументов. Проиллюстрируем это на примере.</p>
    <p class="Textbody">Использовать для удаления файлов опцию -delete, как мы это только что сделали — не самое здоровое решение, ибо файлы при этом удаляются без запроса, и можно случайно удалить что-нибудь нужное. И потому достигнем той же цели следующим образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find ~/ -atime +100 -exec rm -i {} ;</span> </p>
    <p class="Textbody">В этом случае (вне зависимости от настроек псевдонимов командной оболочки) на удаление каждого отобранного файла будет запрашиваться подтверждение.</p>
    <p class="Textbody">Обращаю внимание на последовательность символов {} \; (с пробелом между закрывающей фигурной скобкой и обратным слэшем) в конце строки. Пара фигурных скобок {} символизирует, что свои аргументы исполняемая команда (в примере — rm) получает от результатов отбора команды find, точка с запятой означает завершение команды-значения опции -exec, а обратный слэш экранирует ее специальное значение от интерпретации командной оболочкой.</p>
    <p class="Textbody">Кроме опции действия -exec, у команды find есть ещё одна, близкая по смыслу, опция — -ok. Она также вызывает некую произвольную команду, которой в качестве аргументов передаются имена файлов, отобранные по критериям, заданным опцией (опциями) поиска. Однако перед выполнением каждой операции над каждым файлом запрашивается подтверждение.</p>
    <p class="Textbody">Приведенный на предыдущей странице пример, хотя и вполне жизненный, достаточно элементарен. Рассмотрим более сложный случай — собирание в один каталог всех скриншотов в формате PNG, разбросанных по древу домашнего каталога:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find ~/ -name *.png -exec cp {} imagesdir ;</span> </p>
    <p class="Textbody">В результате все png-файлы будут изысканы и скопированы (или — перемещёны, если воспользоваться командой mv вместо cp) в одно место.</p>
    <p class="Textbody">А теперь — вариант решения задачи, которая казалась мне некогда трудно разрешимой: рекурсивное присвоение необходимых атрибутов доступа в разветвленном дереве каталогов — различных для регулярных файлов и каталогов.</p>
    <p class="Textbody">Зачем и отчего это нужно? Поясню на примере. Как-то раз, обзаведясь огромным по тем временам (40 Гбайт) винчестером, я решил собрать на него все нужные мне данные, рассеянные по дискам CD-R/RW (суммарным объёмом с полкубометра) и нескольким сменным винчестерам, одни из которых были отформатированы в FAT16, другие — в FAT32, третьи — вообще в ext2fs (к слову сказать, рабочей моей системой в тот момент была FreeBSD). Сгрузив все это богачество в один каталог на новом диске, я создал в нем весьма неприглядную картину.</p>
    <p class="Textbody">Ну, во-первых, все файлы, скопированные с CD и FAT-дисков, получили (исключительно из-за неаккуратности монтирования, с помощью должных опций этого можно было бы избежать, но — спешка, спешка...) биты исполняемости, хотя были это лишь файлы данных. Казалось бы, мелочь, но иногда очень мешающая; в некоторых случаях это не позволяет, например, просмотреть html-файл в Midnight Commander простым нажатием Enter. Во-вторых, для некоторых каталогов, напротив, исполнение не было предусмотрено ни для кого — то есть я же сам перейти в них не мог. В третьих, каталоги (и файлы) с CD часто не имели атрибута изменения — а они нужны мне были для работы (в т.ч. и редактирования). Конечно, от всех этих артефактов можно было бы избавиться, предусмотрев должные опции монтирования накопителей (каждого накопителя — а их число, повторяю, измерялось уже объёмом занимаемого пространства), да я об этом и не подумал — что выросло, то выросло. Так что ситуация явно требовала исправления, однако проделать вручную такую работу над данными более чем в 20 Гбайт виделось немыслимым.</p>
    <p class="Textbody">Да так оно, собственно, и было бы, если б не опция -exec утилиты find. Каковая позволила изменить права доступа требуемым образом. Итак, сначала отбираем все регулярные файлы и снимаем с них бит исполнения для всех, заодно присваивая атрибут изменения для себя, любимого:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ find ~/dir_data -type f</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        -exec chmod a-x,u+w {} ;</span> </p>
    <p class="Textbody">Далее — поиск каталогов и обратная процедура над итоговой выборкой:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ find ~/dir_data -type d</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        -exec chmod a+xr,u+w {} ;</span> </p>
    <p class="Textbody">И дело — в шляпе, все права доступа стали единообразными (и теми, что мне нужны). Именно после этого случая я, подобно митьковскому Максиму, проникся величием философии марксизма (пардон, утилиты find). А ведь это ещё не предел ее возможностей — последний устанавливается только встающими задачами и собственной фантазией...</p>
    <p class="Textbody">Так, с помощью команды find легко наладить периодическое архивирование результатов текущей работы. Для этого перво-наперво создаем командой tar полный архив результатов своей жизнедеятельности:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tar cvf alldata.tar ~/*</span> </p>
    <p class="Textbody">А затем в меру своей испорченности (или, напротив, аккуратности), время от времени запускаем команду</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ find ~/ -newer alldata.tar</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        -exec tar uvf alldata.tar {} ;</span> </p>
    <p class="Textbody">ещё один практически полезный вариант использования команды find в мирных целях — периодическое добавление отдельно написанных фрагментов к итоговому труду жизни (например, собственным мемуарам). Впрочем, чтобы сделать это, необходимо сначала ознакомиться с командами обработки файлов, к которым мы вскоре обратимся.</p>
    <p class="Textbody">А пока — об ограничении возможностей столь замечательной сцепки команды find с опцией действия -exec (распространяющиеся и на опцию -ok). Оно достаточно очевидно: вызываемая любой из этих опций команда выполняется в рамках самостоятельного процесса, что на слабых машинах, как говорят, приводит к падению производительности (должен заметить, что на машинах современных заметить этого практически невозможно).</p>
    <p class="Textbody">Тем не менее, ситуация вполне разрешима. И сделать это призвана команда xargs. Она определяется как построитель и исполнитель командной строки со стандартного ввода. А поскольку на стандартный ввод может быть направлен вывод команды find — xargs воспримет результаты ее работы как аргументы какой-либо команды, которую, в свою очередь, можно рассматривать как аргумент ее самоё (по умолчанию такой командой-аргументом является /bin/echo).</p>
    <p class="Textbody">Использование команды xargs не связано с созданием изобилия процессов (дополнительный процесс создается только для нее самой). Однако она имеет другое ограничение — лимит на максимальную длину командной строки. Во всех BSD-системах, которые мне довелось видеть, этот лимит составляет 65536, что определяется командой следующего вида:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sysctl -a | grep kern.argmax</span> </p>
    <p class="Textbody">И способы изменить этот лимит мне не известны — был бы благодарен за соответствующую информацию.</p>
    <h3 id="toc98"><a id="RefHeading16381713816058"></a><a id="bkmRefHeading16381713816058"></a><a id="toc97"></a><a id="bkmtoc97"></a><a id="RefHeading4861136957987"></a><a id="bkmRefHeading4861136957987"></a><a id="bkmRefHeading4861136957987"></a><a id="bkmbkmRefHeading4861136957987"></a>Команды обработки текстов: введение</h3>
    <p class="Textbody">Только что речь шла о командах, которые манипулируют файлами как целыми, не затрагивая их содержания (и, в общем случае, от такового не зависящих). Ныне же речь пойдет о командах, создающих и изменяющих внутреннее содержание файлов, правда, только текстовых.</p>
    <p class="Textbody">Конечно, само по себе манипулирование файлами (копирование, перемещёние и т.д.) также подразумевает изменение содержания некоторых файлов, но только одного-единственного типа (а именно - каталогов), однако собственно внутренняя сущность обычных файлов при этом не изменяется. Предметом же настоящей интермедии будут штатные средства POSIX-систем, позволяющие в той или иной мере учитывать контент файлов и манипулировать им. Разумеется, манипулирование контентом возможно только для регулярных файлов. При этом многие их разновидности (бинарные файлы, файлы графических форматов и word-процессоров) требуют для изменения своего содержания специальных средств - а именно, компиляторов и прикладных программ, в которых они создавались. Однако здесь о них разговора не будет - ибо целью моей было продемонстрировать мощь обычных команд для решения многих пользовательских задач. Правда, на самом деле команды модификации контента действенны преимущественно для файлов текстовых.</p>
    <p class="Textbody">Однако круг объектов таких команд не столь уж узок, как может показаться. Ведь именно в виде обычных текстовых файлов в ОС POSIX-семейства хранится масса общесистемной информации, исполняемых сценариев, баз данных атрибутов самых разных объектов. Далее - собственно нарративные тексты любого содержания: ведь чисто текстовый формат для них куда роднее, чем всякого рода *.doc и *rtf. Ну и никем не возбраняется использовать такие команды в отношении текстов с разметкой - HTML ли, XML, TeX или ещё чего. Так что поле приложения рассматриваемых команд - достаточно обширно.</p>
    <h3 id="toc99"><a id="RefHeading16401713816058"></a><a id="bkmRefHeading16401713816058"></a><a id="toc98"></a><a id="bkmtoc98"></a><a id="RefHeading4881136957987"></a><a id="bkmRefHeading4881136957987"></a><a id="bkmRefHeading4881136957987"></a><a id="bkmbkmRefHeading4881136957987"></a>Просмотр файлов</h3>
    <p class="Textbody">Однако прежде чем как-то манипулировать контентом файлов, желательно этот самый контент некоторым образом просмотреть. И тут можно вспомнить о команде cat, посредством которой мы некогда создавали файлы. Данная с именем файла в качестве аргумента, она выведет его содержимое на экран. Можно использовать и конструкцию перенаправления:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cat &lt; filename</span> </p>
    <p class="Textbody">Не смотря на то, что в принципе это разные вещи, результат будет тот же - вывод содержимого файла на экран.</p>
    <p class="Textbody">Недостаток команды cat как средства просмотра - невозможность перемещёния<br />по телу файла: выведя содержимое, она завершает свою работу. Конечно, «пролистывание» выведенного возможно, но - средствами системной консоли, а не самой команды.</p>
    <p class="Textbody">Поэтому обычно для просмотра содержимого файлов используются специальные программы постраничного просмотра - т.н. pager'ы, очередной пример того, что передача этого термина исконно русским словом «пейджер» (а мне попадалось и такое) может создать совершенно превратное представление о сути дела.</p>
    <p class="Textbody">В Unix-системах имеется две основные программы pager'а - more и less. Первая из них допускает только однонаправленный (вперед) просмотр и имеет слабые интерактивные возможности. Почему ныне и представляет лишь исторический интерес, так что о ней я говорить не буду. Тем более, что в современных свободных POSIX-системах она как таковая отсутствует: файл с именем /usr/bin/more, который можно обнаружить во FreeBSD и некоторых дистрибутивах Linux, на самом деле представляет собой жёсткую или символическую ссылку на ту же самую программу, что и команда less. Хотя эта программа проявляет несколько различные свойства, в зависимости от того, какой из указанных команд она вызвана, функции ее от этого не меняются. Так что дальше я буду говорить только о команде less.</p>
    <p class="Textbody">Самый простой способ вызова команды</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ less filename</span> </p>
    <p class="Textbody">после чего на экран выводится содержимое файла, указанного в качестве аргумента, по которому можно перемещаться в обоих направлениях, как построчно, так и постранично. В нижней строке экрана можно видеть символ двоеточия - приглашения для ввода команд различного назначения. В частности, нажатие клавиши h выводит справку по использованию less, а клавиши q - выход из программы просмотра (или из просмотра справочной системы, если она была перед этим вызвана). Если команда была вызвана как more (это достигается ещё и специальной опцией - less -m), вместо символа двоеточия в нижней строке будет выведено имя файла с указанием процента просмотра:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">command.txt 3%</span> </p>
    <p class="Textbody">что, однако, не воспрещает и здесь давать ее встроенные команды — вводом символа двоеточия (:) и закрепленной за командой литеры (или их сочетания).</p>
    <p class="Textbody">Большинство встроенных команд less предназначено для навигации по телу файла. Осуществляется она несколькими способами:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">с помощью стандартных клавиш управления курсором: PageDown или Spacebar (вперед на один экран), PageUp (назад на один экран), Down или Enter (вперед на одну строку), Up (назад на одну строку), Right (на пол-экрана вправо), Left (на пол-экрана влево); </p>
      </li>
      <li>
        <p class="Textbody">с помощью предопределенных клавишных комбинаций, сходных с управляющими клавиатурными последовательностями командных оболочек и таких текстовых редакторов, как emacs и joe (хотя и не всегда с ними совпадающими): Control+V (на один экран вперед), Escape-V (на один экран назад), Control+N (на одну строку вперед), Control+P (на одну строку назад); </p>
      </li>
      <li>
        <p class="Textbody">с помощью фиксированных символьных клавиш, иногда подобных таковым командного режима редактора vi: z и w (вперед и назад на один экран), e и y (вперед и назад на одну строку, можно использовать также привычные по vi клавиши j и k, соответственно), d и u (вперед и назад на пол-экрана). </p>
      </li>
    </ul>
    <p class="Textbody">Последний способ интересен тем, что допускает численные аргументы перед символьной командой: так, нажатие 3e приведет к перемещёнию на три строки вперед, а 2w - на два экрана назад.</p>
    <p class="Textbody">Помимо «плавной», так сказать, навигации, можно перемещаться по файлу и скачками (jumping): нажатие клавиши с символом g (или последовательности Escape-&lt;) позволяет переместиться к первой строке файла, клавиши G (регистр важен! дублирующий вариант - Escape-&gt;) - к последней его строке, клавиши p -<br />к началу файла.</p>
    <p class="Textbody">Кроме навигации, имеется и возможность двустороннего поиска - в направлении как конца, так и начала файла. Для поиска вперед требуется ввести символ прямого слэша (/) и за ним - искомое сочетание символов. Поиск в обратном направлении предваряется символом вопроса (?). В обоих случаях в шаблоне поиска можно использовать стандартные регулярные выражения *, ?, [список_символов] или [диапазон_символов]. Нажатие клавиши n (в нижнем регистре) приводит к повторному поиску в заданном ранее направлении, клавиши N (в верхнем регистре) - к поиску в направлении противоположном.</p>
    <p class="Textbody">Управляющие комбинации команды less могут быть переопределены с помощью команды lesskey. Формат ее</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ lesskey -o output input</span> </p>
    <p class="Textbody">В качестве входных данных выступает простой текстовый файл (по умолчанию - ~/.lesskey, однако его следует создать самостоятельно), описывающий клавишные последовательности в следующем, например, виде:</p>
    <p class="Textbody"><span style="background-color:#dddddd">#command</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">\r        forw-line</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">\n        forw-line</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">k         back-line</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">Выходные данные - создаваемый из текстового двоичный файл, который собственно и используется командой less. Стандартное для него имя - ~/.less.</p>
    <p class="Textbody">Команда less допускает одновременный просмотр нескольких файлов. Для этого ее следует вызвать в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ less file1 file2 ... file#</span> </p>
    <p class="Textbody">после чего между открытыми файлами можно переключаться посредством :n (к следующему файлу), :p (к предыдущему файлу), :x (к первому файлу). Путем нажатия :d текущий файл исключается из списка просмотра. Символ двоеточия во всех этих случаях вводится с клавиатуры в дополнение к приглашению на ввод<br />команд.</p>
    <p class="Textbody">Команда less имеет великое множество опций - описание их на странице экранной документации занимает более дюжины страниц, поэтому задерживаться на них я не буду. Следует заметить только, что опции эти могут использоваться не только в командоной строке при запуске less, но и интерактивно - после символа дефиса в приглашении ввода. Так, указав там -m, можно включить т.н. промежуточный формат приглашения (с отображением процентов просмотренного объёма файла), а с помощью -M - длинный (more-подобный) формат, при котором в приглашении дополнительно указываются имя файла, его положение в списке загруженных файлов, просматриваемые ныне строки:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">command.html (file 2 of 10) lines 1-29/1364 2%</span> </p>
    <p class="Textbody">Значение команд постраничного просмотра файлов ещё и в том, что именно с их помощью осуществляется доступ к экранной документации (man-страницам). Команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ man cmd_name</span> </p>
    <p class="Textbody">как было описано в предыдущей интермедии, на самом деле вызывает определенный по умолчанию pager для просмотра соответствующего файла /usr/share/man/man#/cmd_name.gz. Какой именно - определяется переменной PAGER в пользовательских настройках.</p>
    <p class="Textbody">Кроме команд постраничного просмотра, существуют команды для просмотра фрагментарного. Это - head и tail, выводящие на экран некоторую фиксированную порцию файла, указанного в качестве их аргумента, с начала или с конца, соответственно. По умолчанию эта порция для обеих команд составляет десять строк (включая пустые). Однако ее можно переопределитьg произвольным образом, указав опции -n [число_линий] или -c [количество_байт]. Например, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ head -n 3 filename</span> </p>
    <p class="Textbody">выведет три первые строки файла filename, а команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ tail -c 100 filename</span> </p>
    <p class="Textbody">его последние 100 байт. При определении выводимого фрагмента в строках название опции (n) может быть опущено - достаточно числа после знака дефиса.</p>
    <p class="Textbody">Существуют и средства просмотра компрессированных файлов. Для файлов, сжатых программой gzip, можно использовать команды zcat и zmore, для спрессованных командой bzip2 - команду bzcat. Использование их ничем не отличается от аналогов для несжатых файлов - в сущности, именно они и вызываются для обеспечения просмотра. В случае команды zmore, как нетрудно догадаться, на самом деле используется команда less (сама по себе она аналога для компрессированных файлов не имеет).</p>
    <h3 id="toc100"><a id="RefHeading16421713816058"></a><a id="bkmRefHeading16421713816058"></a><a id="toc99"></a><a id="bkmtoc99"></a><a id="RefHeading4901136957987"></a><a id="bkmRefHeading4901136957987"></a><a id="bkmRefHeading4901136957987"></a><a id="bkmbkmRefHeading4901136957987"></a>Сравнение, объединение и деление файлов</h3>
    <p class="Textbody">Следующая важная группа операций над контентом файлов - сравнение файлов по содержанию и различные формы объединения файлов и их фрагментов. Начнем со сравнения. Простейшая команда для этого - cmp в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cmp file1 fil2</span> </p>
    <p class="Textbody">производит построчное сравнение файлов, указанных как первый и второй аргументы (а более их и не предусмотрено, все указанное после второго аргумента игнорируется). В случае идентичности сравниваемых файлов не происходит ничего, кроме возврата приглашения командой строки. Если же между файлами имеются различия, выводится номер первого различающегося символа и номер строки, в которой он обнаружен:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">file1 file2 differ: char 27, line 4</span> </p>
    <p class="Textbody">Это означает, что различия между файлами начинаются с 27-го от начала файла символа (включая пробелы, символы конца строк и т.д.), который имеет место быть в строке 4. С помощью опций -l и -z можно заставить команду cmp вывести номера всех различающихся символов в десятичном или шестнадцатеричном формате, соответственно.</p>
    <p class="Textbody">Более информативный вывод обеспечивает команда diff. Она также осуществляет построчное сравнение двух файлов, но выводит список строк, в которых обнаружены отличия. Например, для двух файлов вида</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ less file1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 3</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 4</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">line 5</span> </p>
    <p class="Textbody">и</p>
    <p class="Textbody"><span style="background-color:#dddddd">$less file2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 3</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 3a</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 4</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">line 5</span> </p>
    <p class="Textbody">это будет выглядеть следующим образом:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ diff file1 file2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">3a4</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">&gt; line 3a</span> </p>
    <p class="Textbody">Если различия будут выявлены более чем в одной строке, для каждого расхождения будет выведен аналогичный блок. Смысл его - в том, какие строки первого файла должны быть преобразованы, и как именно, для того, чтобы файлы стали идентичными. Первая линия блока вывода содержит номер строки первого файла, подлежащей преобразованию, номер соответствующей строки второго файла и обозначенное буквенным символом преобразование, во второй линии приведена собственно строка - предмет преобразования. Символы преобразования -<br />следующие:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">a (от append) указывает на строку, отсутствующую в первом файле, но присутствующую во втором; </p>
      </li>
      <li>
        <p class="Textbody">c (от change) фиксирует строки с одинаковым номером, но разным содержанием; </p>
      </li>
      <li>
        <p class="Textbody">d (от delete) определяет строки, уникальные для первого файла. </p>
      </li>
    </ul>
    <p class="Textbody">То есть в данном примере для преобразования file1 в file2 в него после строки 3 должна быть вставлена строка 4 из второго файла, что символизирует вторая линия блока - &gt; line 3a, где &gt; означает строку из первого сравниваемого файла. Если же аргументы команды diff дать в обратном порядке, вывод ее будет выглядеть следующим образом:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ diff file2 file1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">4d3</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">&lt; line 3a</span> </p>
    <p class="Textbody">показывающим, что для достижения идентичности из file2 должна быть удалена<br />четвертая строка (&lt; line 3a, где &lt; означает строку из второго файла). Если же произвести сравнение file1 с file3, имеющим вид</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ less file3</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 3a</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">line 4</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">line 5</span> </p>
    <p class="Textbody">то вывод команды</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ diff file1 file3</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">3c3</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">&lt; line 3</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">---</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">&gt; line 3a</span> </p>
    <p class="Textbody">будет означать необходимость замены третьей строки из file1 (символ &lt;) на третью строку из file3 (символ &gt;).</p>
    <p class="Textbody">Такая форма вывода команды diff называется стандартной. С помощью опции -c можно задать т.н. контекстную форму вывода, при которой на экран направляется не только различающиеся строки, но и строки, их окружающие (то есть контекст, в котором они заключены):</p>
    <p class="Textbody"><span style="background-color:#dddddd">diff -c file1 file2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">*** file1       Sun May 12 11:44:44 2002</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">--- file2       Mon May 13 15:17:27 2002</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">***************</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">*** 1,5 ****</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">--- 1,6 ----</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  line 1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  line 2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  line 3</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">+ line 3a</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  line 4</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">  line 5</span> </p>
    <p class="Textbody">Количество строк контента задается опцией -C:</p>
    <p class="Textbody"><span style="background-color:#dddddd">diff -C 1 file1 file2                                      ttyv1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">*** file1       Sun May 12 11:44:44 2002</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">--- file2       Mon May 13 15:17:27 2002</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">***************</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">*** 3,4 ****</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">--- 3,5 ----</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  line 3</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">+ line 3a</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">  line 4</span> </p>
    <p class="Textbody">В этом примере значение опции -C (единица) предписывает вывод по одной строке контекстного окружения вокруг различающейся строки. Сами же различающиеся строки помечаются следующим образом: знаком - (минус, или дефис) - строки, подлежащие удалению из первого файла, знаком + (как в примере) - строки, которые должны быть добавлены, знаком ! - просто различающиеся строки.</p>
    <p class="Textbody">Кроме контекстного формата, используется ещё и вывод в унифицированном формате, что предписывается опцией -U [значение], в качестве значения указывается число строк. В нем для обозначения изменяемых строк используются только символы + и -, а сам вывод чуть короче, чем при использовании контекстного формата.</p>
    <p class="Textbody">С помощью многочисленных опций команды diff сравнение файлов может быть детализовано и конкретизировано. Так, опция -b предписывает игнорировать «пустые» символы пробелов и табуляции в конце строк, а опция -w - вообще «лишние» пробелы (и те, и другие обычно имеют случайное происхождение). При указании опции -B игнорируются пустые строки, то есть не содержащие никаких иных символов, кроме перевода каретки; строки с символами табуляции или пробела как пустые не рассматриваются, для их игнорирования требуется опция -w. Благодаря опции -i при сравнении не принимается во внимание различие регистров символов, а опция -I regexp определяет регулярные вырвжения, строки с которыми также игнорируются при сравнении.</p>
    <p class="Textbody">В качестве аргументов команды diff (одного или обоих) могут выступать также каталоги. Если каталогом является только один из аргументов, для сравнения в нем отыскивается файл, одноименный второму аргументу. Если же оба аргумента суть каталоги, в них происходит сравнение всех одноимённых файлов в алфавитном порядке (вернее, в порядке ASCII-кода первого символа имени, разумеется). Благодаря опции -r сравнение файлов может осуществляться и во вложенных подкаталогах.</p>
    <p class="Textbody">Вывод команды diff может быть перенаправлен в файл. Такие файлы различия именуются diff-файлами или, применительно к исходным текстам программ, патчами (patches), о которых будет сказано несколько позже. Именно с помощью таких патчей обычно распространяются изменения к программам (дополнения, исправления ошибок и т.д.).</p>
    <p class="Textbody">В принципе, команда diff и придумана была именно для сравнения файлов исходников, над которыми ведут работу несколько (в пределе - неограниченное количество, как в случае с Linux) человек. Однако невозбранно и ее использование в мирных целях - то есть для сравнения просто повествовательных текстов. Единственное, что следует понимать при этом абсолютно ясно - то, что diff выполняет именно построчное сравнение. То есть: сравнение последовательностей символов, ограниченных символами конце строки с обеих сторон. И, соответственно, непрерывная абзацная строка в стиле emacs и vi - совсем не то же самое, что строка, образуемая в редакторе joe на границе экрана. Впрочем, это - вопрос, к которому ещё не раз придется возвращаться.</p>
    <p class="Textbody">Как уже было отмечено, команда diff осуществляет сравнение двух файлов (или - попарное сравнение файлов из двух каталогов). Однако, поскольку Бог, как известно, любит троицу, есть и команда diff3, позволяющая сранить именно три файла, указываемые в качестве ее аргументов. По действию она не сильно отличается от двоичного аналога. И потому изучение ее особенностей предлагается в качестве самостоятельного упражнения приверженцам троичной идеологии.</p>
    <p class="Textbody">Существуют и средства для сравнения сжатых файлов. Это - zcmp и zdiff. Подобно командам просмотра, ими просто вызываются соотвествтующие команды cmp и diff. И потому использование их не имеет никаких особенностей.</p>
    <p class="Textbody">От вопроса сравнения файлов плавно перейдем к рассмотрению способов их объединения. Для этого существует немало команд, из которых по справедливости первой должна идти команда cat, поскольку именно сие есть ее титульная функция (cat — от concatenation, сиречь объединения). Ранее уже упоминалось, что она способна добавлять информацию со стандартного ввода в конец существующего файла. Однако дело этим не ограничивается. В форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cat file1 file2 ... file# &gt; file_all</span> </p>
    <p class="Textbody">она создает новый файл, включающий в себя содержимое всех файлов-аргументов (и именно в том порядке, в каком они приведены в командной строке). Операция, казалось бы, нехитрая - однако представьте, сколько действий потребовалось бы в текстовом процессоре (например, в Word'е) для того, чтобы создать синтетический вариант из полутора десятков фрагментов, раскиданных по разным каталогам?</p>
    <p class="Textbody">А вот команда patch выступает в качестве диалектической пары для команды diff, именно она вносит в файл те изменения, которые документируются последней. Выглядит эта команда примерно так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ patch file1 diff_file</span> </p>
    <p class="Textbody">в ответ на что последует нечто вроде следующего вывода:</p>
    <p class="Textbody"><span style="background-color:#dddddd">Hmm...  Looks like a normal diff to me...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Patching file file1 using Plan A...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Hunk #1 succeeded at 4.</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">done</span> </p>
    <p class="Textbody">В результате исходная версия file1 будет сохранена под именем file1.orig, а сам он преобразован в соответствие с описанием diff-файла. Возможна и<br />форма</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">patch &lt; diff_file</span> </p>
    <p class="Textbody">В этом случае команда patch попытается сама определить имя файла-оригинала, и, если это ей не удастся, даст запрос на его ввод. Обращаю внимание на символ перенаправления ввода, поскольку если его опустить, имя dif-файла будет воспринято как первый аргумент команды (то есть имя файла-оригинала).</p>
    <p class="Textbody">В качестве второго аргумента команды patch могут использоваться dif-файлы не только в стандартном, но и в контекстном или унифицированном формате. Это следует указать посредством опции -c или -u, соответственно.</p>
    <p class="Textbody">Сочетание команд diff и patch очень широко используется при внесении изменений в исходные тексты программы. В частности, они применяются для внесения дистрибутив-специфичных изменений в deb-пакеты репозиториев Ununtu и Mint.</p>
    <p class="Textbody">Не менее часто, чем в слиянии, возникает и необходимость в разделении файлов на части. Цели этой служит команда split. Формат ее:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ split [options] filename [prefix]</span> </p>
    <p class="Textbody">В результате исходный файл будет разбит на несколько отдельных файлов вида prefixaa, prefixab и так далее. Значение аргумента prefix по умолчанию - x (то есть без его указания итоговые файлы получат имена xaa, xab и т.д.).</p>
    <p class="Textbody">Опции команды split задают размер выходных файлов - в байтах (опция -b) или количестве строк (опция -l). Первой опцией в качестве единицы, кроме байтов, могут быть заданы также килобайты или мегабайты - добавлением после численного значения обозначения k или m, соответственно.</p>
    <p class="Textbody">Команда split может использоваться для разбиения файлового архива на фрагменты, соответствующие размеру резервных носителей. Так, в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ split -b 1474560 arch_name</span> </p>
    <p class="Textbody">она обеспечит разбиение архива на части, какждая из которых может быть записана на стандартную трехдюймовую дискету. А посредством</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ split -b 650m arch_name</span> </p>
    <p class="Textbody">архив можно подготовить к записи на носители CD-R/RW. Легко догадаться, что обратное слияние таких фрагментированных файлов можно выполнить командой cat.</p>
    <p class="Textbody">В BSD-реализации команды split имеется опция -p (от pattern — шаблон), благодаря которой файл может быть разделена на фрагменты, ограниченные строками, содержащими текст, приведенный в качестве значения шаблона. Linux-реализация команды split таким свойством не обладает. Однако взамен этому в Linux есть команда csplit, именно для разделения файла по шаблону и предназначенная.</p>
    <p class="Textbody">Показать, как она работает, проще всего на конкретном примере. Предположим, у нас имеется книга в формате Plain Text, состоящая из введения и 23 глав, которую надо разбить на соответствующее количество фрагментов. Для этого сочиняется такая командная конструкция:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ csplit -f chapter mybook.txt '/Глава/' {23}</span> </p>
    <p class="Textbody">Здесь опция -f задаёт маску имён файлов, на которые будет разбит исходный текст (то есть файл mybook.txt). Шаблон, по которому будет выполняться разбиение — слово Глава ограничено прямыми слэшами и заключено в «строгие» кавычки. А число в фигурных скобках указывает, сколько раз надо повторить процедуру разбиения по заданному шаблону. И в результате мы получаем серию файлов вида chapter##, где файл chapter00 будет включать текст от начала до первой строки со словом Глава (которая, как ни странно, будет главой первой), chapter01 — от строки Глава первая до Главы второй, и так далее. Исходный файл при этом останется в неприкосновенности.</p>
    <h3 id="toc101"><a id="RefHeading16441713816058"></a><a id="bkmRefHeading16441713816058"></a><a id="toc100"></a><a id="bkmtoc100"></a><a id="RefHeading4921136957987"></a><a id="bkmRefHeading4921136957987"></a><a id="bkmRefHeading4921136957987"></a><a id="bkmbkmRefHeading4921136957987"></a>Поиск в файлах: grep сотоварищи</h3>
    <p class="Textbody">В одном из предыдущих разделов говорилось о поиске файлов посредством команды find. Ныне же речь пойдет о поиске внутри файлового контента - то есть поиске текстовых фрагментов. Для этого в POSIX-системах используется семейство утилит grep — собственно grep, egrep и fgrep, несколько различющихся функционально. Впрочем, в большинстве систем все это суть разные имена (жёсткие ссылки) одной и той же программы, именуемой GNU-реализацией grep, включающей ряд функций, свойственных ее расширенному аналогу, egrep. Соответственно, поиск текстовых фрагментов в файлах может быть вызван любой из этих команд, хотя в каждом случае функциональность их будет несколько различаться.</p>
    <p class="Textbody">Однако начнем по порядку. Самой простой формой команды grep является следующая:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ grep pattern files</span> </p>
    <p class="Textbody">где pattern - искомая последовательность символов, а files - файлы, среди которых должен производиться поиск (или - просто одиночный файл). В указании<br />имен файлов допустимы обычные маски, например, командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ grep line ./*</span> </p>
    <p class="Textbody">будут найдены строки вида line во всех файлах текущего каталога. Шаблон для поиска не обязан быть односложным. Правда, если в нем используются последовательности символов, разделенные пробелами, последние должны тем или иным способом экранироваться, иначе в качестве шаблона будет воспринято только первое слово. Например, каждый пробел может предваряться символом обратного слэша (\), или просто все искомое выражение заключается в одинарные или двойные кавычки.</p>
    <p class="Textbody">Шаблоны могут включать в себя регулярные выражения. причём список таковых для команды grep существенно шире, чем для команд манипулирования файлами. Так, кроме маски любой последовательности символов (*), любого одиночного символа (?), списка и диапазона символов ([a...z] и [a-z]), могут встречаться:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">. (точка) - маска любого одиночного (но, в отличие от маски ?, обязательно присутствующего) символа; то есть при задании шаблона lin. будут найдены строки, содержашие line или lins, но не lin; </p>
      </li>
      <li>
        <p class="Textbody">^ и $ - маски начала и конца строки, соответственно: по шаблону ^line, будут найдены строки, начинающиеся с соответствующего слова, по шаблону же line$ - им заканчивающиеся; </p>
      </li>
      <li>
        <p class="Textbody">маски повторения предыдущего шаблона, \{n\} - ровно n раз, \{n,\} - не менее n раз, \{,m\} - не более m раз, \{n,m\} - не менее n раз и не более m раз. </p>
      </li>
    </ul>
    <p class="Textbody">Маски повторения относятся к так называемым расширенным регулярным выражениям. Для их использования команда grep должна быть дана с опцией -e или в форме egrep — последняя часто определяется в общесистемном или пользовательском профильном файле как псевдоним команды grep:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias grep='egrep -s'</span> </p>
    <p class="Textbody">или</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias grep egrep</span> </p>
    <p class="Textbody">в оболочках семейств shell и csh, соответственно.</p>
    <p class="Textbody">При этом становятся доступными и другие возможности поиска - например, нескольких текстовых фрагментов (соедниненных логическим оператором «ИЛИ») одновременно. Делается это двояко. Первый способ - просто перечисление искомых фрагментов, каждый из которых предваряется опцией -e (и при необходимости экранируется кавычками):</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ grep -e pattern1 -e pattern2 files</span> </p>
    <p class="Textbody">При втором способе оператор между искомыми шаблонами задается в явном<br />виде:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ egrep 'pattern1|pattern2' files</span> </p>
    <p class="Textbody">Таким способом очень легко, например, составить оглавление для длинного текста (при наличии некоторой системы рубрикации в нем, разумеется). Для этого достаточно дать команду вроде следующей:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ egrep 'Часть|Глава|Раздел|Параграф' filename</span> </p>
    <p class="Textbody">Для текста, включающего html- или TeX-разметку, роль рубрик могут выполнять соответствующие ее элементы, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ egrep ' &lt;h1&gt;|&lt;h2&gt;|&lt;h3&gt;|&lt;h4&gt;' filename</span> </p>
    <p class="Textbody">Вывод команды grep может быть перенаправлен в файл, а при необходимости и предварительно отсортирован с помощью соответствующих командных конструкций перенаправления и конвейеризации.</p>
    <p class="Textbody">Разумеется, тем же способом можно создать общее оглавление для серии фрагментов, записанных в виде самостоятельных файлов — для этого достаточно только перечислить их имена в качестве аргументов команды. Так, например, если есть необходимость составления детальной карты сайта, включающей ссылки на подрубрики внутри отдельных html-документов, следует применить конструкцию типа:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ egrep '&lt;h1&gt;|&lt;h2&gt;|&lt;h3&gt;|&lt;h4&gt;' path/*.html &gt; sitemap.html</span> </p>
    <p class="Textbody">ещё одно замечательное свойство команды grep (и egrep) - возможность получения шаблона не со стандартного ввода (то есть не путем набора его с клавиатуры), а из файла. Так, если для приведенного выше случая создать простой текстовый файл shablon, содержащий строку</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Часть|Глава|Раздел|Параграф</span> </p>
    <p class="Textbody">выполнять операцию по сборке оглавления впредь (и в любом тексте, хоть частично совпадающем по структуре с рассмотренным) можно будет выполнять таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ egrep -f shablon filename</span> </p>
    <p class="Textbody">Опция -f и указывает команде, что список параметров должен извлекаться из файла, указанного в качестве значения опции.</p>
    <p class="Textbody">Список опций команды grep не исчерпывается указанными выше. Так, опция -i предписывает игнорировать различие регистров внутри искомого выражения, опция -h - подавляет вывод имен файлов (выводится только содержание найденных строк), тогда как опция -l, напротив, выводит только имена файлов, содержащих найденный шаблон, но не текстовый фрагмент, опция -n выводит номера найденных строк в соответствующих файлах. Весьма важной представляется опция -v, обеспечивающая инверсию поиска: при указании ее выводятся строки, не содержащие шаблона поиска.</p>
    <p class="Textbody">Команда grep имеет и аналоги для поиска в сжатых файлах - команду zgrep и семейство команд xzgrep, о которых говорилось в миниочерке про архивацию и компрессию.</p>
    <h3 id="toc102"><a id="RefHeading16461713816058"></a><a id="bkmRefHeading16461713816058"></a><a id="toc101"></a><a id="bkmtoc101"></a><a id="RefHeading4941136957987"></a><a id="bkmRefHeading4941136957987"></a><a id="bkmRefHeading4941136957987"></a><a id="bkmbkmRefHeading4941136957987"></a>Поиск в файлах: утилита search</h3>
    <p class="Textbody">В дистрибутиве Mint имеется фирменная утилита для поиска текстовых фрагментов в файлах — search/code&gt;. Она входит в состав пакета mintsystem (о котором подробней говорится в очерке об утилите apt) и располагается в каталоге /usr/local/bin/. Формат её вызова таков:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ search for [искомый фрагмент] in [каталог для поиска]</span> </p>
    <p class="Textbody">Например, в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ search for 'дистрибутив Mint' in /home/current/alv.me</span> </p>
    <p class="Textbody">она отыщет все абзацы с вхождением дистрибутив Mint во всех файлах указанного каталога и выведёт их в таком виде:</p>
    <p class="Textbody"><span style="background-color:#dddddd">/home/current/alv.me/mint/mint17-cin/mint17-02.txt:9:В числе родственников... нет, не примазавшихся, а настоящих, но пошедших другим путём, был и дистрибутив Mint. Сейчас не время обсуждать его взаимоотношения с прародительской Ububtu, но программу установки он унаследовал от неё практически без изменений. По крайней мере, до недавнего времени макроскопических различий в инсталляторах этих систем не наблюдалось.</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">Команда search не является полной заменой утилит семейства grep, в частности, она не поддерживает регулярные выражения. Но вполне может служить более простой в использовании альтернативой во многих тривиальных случаях, столь частых в практике применителей-текстовиков.</p>
    <h3 id="toc103"><a id="RefHeading16481713816058"></a><a id="bkmRefHeading16481713816058"></a><a id="toc102"></a><a id="bkmtoc102"></a><a id="RefHeading4961136957987"></a><a id="bkmRefHeading4961136957987"></a><a id="bkmRefHeading4961136957987"></a><a id="bkmbkmRefHeading4961136957987"></a>Sed: средство потокового редактирования</h3>
    <p class="Textbody">Весьма часто при обработке текстов встает такая задача: заменить одно слово (или последовательность слов) на другое сразу во многих файлах. Как она решается «подоконными» средствами? Обычно - открытием всех подлежащих изменению документов в word-процессоре и применением функции поиска/замены последовательно в каждом из них.</p>
    <p class="Textbody">Таким же способом можно воспользоваться и в POSIX-мире. Это просто, но уж больно скучно. Тем паче, что здесь есть очень эффективная альтернатива — средства потокового (неинтерактивного ) редактирования, примером которых является sed, с которым мы уже слегка познакомились в очерке о программах в автозапуске.</p>
    <p class="Textbody">Потоковое, или неинтерактивное, редактирование не требует загруки документа в память (то есть открытия), как в обычных текстовых редакторах и word-процессорах. Нет, при нем подлежащий изменению файл (или группа файлов) обрабатываются построчно с помощью соответствующих команд, задаваемых как опции единой командной директивы. В наши дни это выглядит анахронизмом, однако в ряде случаев оказывается чрезвычайно эффективным. Каких? - ответ легко дать на нескольких конкретных примерах.</p>
    <p class="Textbody">Так, при настройке системы нередко требуется внести мелкие однотипные изменения в серию конфигурационных файлов. Именно с такой ситуацией мы столкнулись, когда захотели увидеть все автоматически запускаемые при старте Cinnamon приложения. И тогда было самое время вспомнить про sed, с помощью которого эта задача была решена одной командой — не откажу себе в удовольствии напомнить её:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo sed -i 's/NoDisplay=true/NoDisplay=false/' /etc/xdg/autostart/*</span> </p>
    <p class="Textbody">Другой случай - во многих десятках, а то и сотнях файлов требуется изменить одну-единственную строку, причём — одинаковым образом (например, заменить копирайт Васи Пупкина на Петю Лавочкина). Неужто для этой цели нужно вызывать мощный текстовый редактор, грузить в него немерянное количество документов, перемещаться тем или иным способом перемещаться к нужному фрагменту, вносить требуемое изменение? Отнюдь, ибо sed поможет и здесь, позволив выполнить изменение любого количества файлов в пакетном режиме.</p>
    <p class="Textbody">Во всем блесе sed показывает себя при редактировании очень больших файлов (одно пролистывание которых требует немалого времени). А также — при редактировании сложных символьных последовательностей в нескольких файлах. Однажды, после очередной реконструкции моего сайта, передо мной встала задача тотальной модификации всех внутренних ссылок. Долго я с ужасом размышлял, как буду делать это в текстовом редакторе, и сколько ошибок при этом насажаю. Пока, раскинув мозгами, не нашел, как сделать это с помощью sed - быстро и, главное, безошибочно.</p>
    <p class="Textbody">В самом общем виде sed требует двух аргументов — указания встроенной его команды и имени файла, к которому она должны быть применена. Впрочем, в качестве аргумента можно задать только простую команду, мало-мальски сложное действие (а команды поиска/замены принадлежат к числу сложных) необходимо определить через значения опции -e, заключенные в кавычки (одинарные или двойные - по ситуации). Что же касается имен файлов — то их в качестве аргументов можно указать сколько угодно, в том числе и с помощью масок типа *, *.txt и так далее. Правда, sed не обрабатывает содержимое вложенных подкаталогов, но это — дело поправимое (как — скоро увидим). Так что поиск и замена слова или их последовательности выполняются такой конструкцией:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sed -e 's/Вася Пупкин/Петя Лавочкин/' *</span> </p>
    <p class="Textbody">Здесь s - это команда поиска, Вася Пупкин - искомый текст, а Петя Лавочкин - текст для замены. В приведенной форме команда выполнит поиск и замену только первого вхождения искомого текста. Чтобы заменить текст по всему файлу, после последнего слэша (он обязателен в любом случае, без него sed не распознает конца заменяющего фрагмента) нужно указать флаг g (от global). Важно помнить, что если оставить заменяющее поле пустым, искомый текст будет просто удален.</p>
    <p class="Textbody">По умолчанию sed выводит результаты своей работы на стандартный вывод, не внося изменений в файлы аргументы. Так где же здесь редактирование? Оно обеспечивается другой опцией - -i, указание которой внесет изменения непосредственно в обрабатываемый файл. В результате команда для замены, например, всех вхождений html на shtml во всех файлах текущего каталога будет выглядеть так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sed -i -e 's/html/shtml' *</span> </p>
    <p class="Textbody">А что делать, если таким же образом нужно обработать файлы во всех вложенных подкаталогах? Придется вспомнить об универсальной команде find, о которой мы не так давно говорили. В форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find . -name * -exec sed -i -e 's/html/shtml' * {} \</span> </p>
    <p class="Textbody">она с успехом справится с этой задачей.</p>
    <p class="Textbody">Я привел лишь элементарные примеры использования sed. На самом деле возможности его много шире, но их описание далеко выходит за рамки этого краткого введения.</p>
    <h2 id="toc104"><a id="RefHeading16501713816058"></a><a id="bkmRefHeading16501713816058"></a><a id="toc103"></a><a id="bkmtoc103"></a><a id="RefHeading12641136957987"></a><a id="bkmRefHeading12641136957987"></a><a id="bkmRefHeading12641136957987"></a><a id="bkmbkmRefHeading12641136957987"></a>Текстовый редактор nano</h2>
    <p class="Textbody">Только что я попытался показать мощь неинтерактивного редактирования, доступную благодаря потоковому редактору sed. Однако, как бы силён он не был, иногда при всякого рода конфигурировании возникает необходимость и в настоящем текстовом редакторе, интерактивном. Причём желательно способном работать и в терминальном окне графического сеанса, и в «чёрной» консоли.</p>
    <p class="Textbody">Записные линуксоиды обычно в таких случаях советуют начинающим применителям Vim или Emacs, в зависимости от собственной религиозной ориентации. Напрочь забывая о том, что эффективная работа в обоих этих редакторах возможна только при доведённых до автоматизма навыках, и к тому же навыках, постоянно тренируемых — иначе они утрачиваются очень быстро. При необходимости же поправить пару строк в конфиге раз или два в месяц приобретать такие навыки просто не имеет смысла.</p>
    <p class="Textbody">А вот редактор Nano вполне может сыграть роль своего рода амортизатора для начинающего применителя. Да, это не Vim, не Emacs, и даже не joe. Но с задачей конфигурирования справляется успешно. А в освоении и`обращении — прост, как грабли. Не случайно во многих дистрибутивах Linux он по умолчанию предлагается в качестве общесистемного. В том числе и в таких юзерофильных, как семейство Ubuntu, представители которого, с одной стороны, имеют штатные, мощные и удобные, инструменты редактирования в своих интегрированных средах, с другой — и Vim'ом эти системы не обделены, да и Emacs им устанавливать не возбраняется. Но даже в этих «борброжелательных» дистрибутивах иногда возникает потребность в простом и лёгком консольном редакторе. А многие ли из начинающих применителей способны сразу же смотреть на Vim и Emacs без содрогания?</p>
    <p class="Textbody">Столь длинное вступление направлено к тому, что затратить толику времени на освоение Nano — дело стоящее для многих линуксоидов, в том числе и начинающих применителей Mint. Тем более, что, как уже было сказано, в освоении он прост, а возможностей у него больше, чем может показаться на первый взгляд.</p>
    <p class="Textbody">Итак, представляю: редактор Nano, или, точнее, GNU nano. Характеризуется авторами как маленький и дружелюбный. Что в целом соответствует истине. Официальным местопребыванием имеет сайт <a href="http://www.nano-editor.org/" target="_blank">http://www.nano-editor.org</a>, где его текущая стабильная версия (2.2.6) доступна в виде тарбалла исходников и бинарников в форматах rpm и deb.</p>
    <p class="Textbody">Впрочем, применителям Mint заботиться о скачивании бинарников и тем более исходников не придётся: Nano имеется в официальном репозитории этого дистрибутива и, более того, устанавливается по умолчанию с инсталляционного Live-носителя, после чего немедленно готов к работе.</p>
    <p class="Textbody">Запускается Nano из командной строки консоли или терминального окна одноименной командой, можно — с указанием имени файла, существующего или нового (в последнем случае, как обычно, файл с таким именем будет создан). Поддерживается несколько опций командной строки, как то: -T #, устанавливающей величину (в символах) табуляции, -i, включающей автоматические отступы, -w, отключающей режим жёсткого переноса строк на границе экрана (что очень важно при редактировании конфигурационных файлов), -$, напротив, включающей режим переноса «мягкого» (так называемый softwrap), при котором визуальный перенос осуществляется без разрыва строки, и так далее. Полный список стартовых опций можно посмотреть посредством</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ man 1 nano</span> </p>
    <p class="Textbody">Кроме того, практически все эти опции могут быть прописаны в конфигурационном файле в качестве умолчальных.</p>
    <p class="Textbody">Общесистемный конфигурационный файл редактора — /etc/nanorc. Его можно скопировать в свой домашний каталог</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cp /etc/nanorc ~/.nanorc</span> </p>
    <p class="Textbody">После чего редактировать в своё удовольствие. Кроме того, в каталоге /usr/share/nano имеется большое количество примеров конфигов, адаптированных для разных языков программирования и разметки, а также специально для некоторых дистрибутивов (Gentoo, Debian).</p>
    <p class="Textbody">Впрочем, умолчальный конфиг кажется мне вполне соответствующим своим задачам. Единственное вносимое мной в него изменение — это включение режима «мягких» переносов по умолчанию. Для чего нужно снять комментарий со строки</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">set softwrap</span> </p>
    <p class="Textbody">И, напротив, закрыть комментарием строку</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#set nowrap</span> </p>
    <p class="Textbody">После этого Nano становится равно пригодным и для редактирования конфигурационных файлов (которые, как известно, не любят произвольных разрывов строк), и для сочинения «мирных» текстов, в которых уходящие за горизонт экрана строки очень мешают, а жёсткие их разрывы также не полезны, ибо затрудняют в дальнейшем поиск.</p>
    <p class="Textbody">Поиск, кстати, осуществляется комбинацией клавиш Control+w с последующим нажатием на Enter, повторямыми, сколько требуется. А для замены, в том числе глобальной, используется комбинация Control плюс обратный слэш (\) или Meta+R.</p>
    <p class="Textbody">После запуска Nano с указанием существующего файла в качестве аргумента (например, его собственного «домашнего» конфига) перед глазами возникает примерно такая картина:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/nano_001.png">
        <img alt="Изображение234" class="frameGraphics" id="234graphic" src="http://alv.me/wp-content/img/im_cin_img/nano_001-539x572.png" style="border:1.0px solid #000080;padding:0;width:540.8416px;height:573.83685px" />
      </a>
      <a id="a234graphic"></a>
      <a id="bkm234graphic"></a>
    </p>
    <p class="Textbody">Вверху — титульная строка, в которой выводятся номер версии программы, имя открытого файла и, в правом углу, сообщение о том, что файл был изменен. В нижней части экрана можно видеть зону подсказки — список основных управляющих клавишных последовательностей (образованных сочетанием Control+литера) с пояснениями на языке установленной локали.</p>
    <p class="Textbody">Главнейшей из управляющих последовательностей на первых порах знакомства с редактором будет Control+g (литерные клавиши последовательностей к регистру не чувствительны). Она вызывается весьма подробную справку, в том числе и о тех последовательностях, которые не уместились в двух нижних строках рабочей области. Та же самая справка вызывается и клавишей F1 — если она не перехватывается средой, как это имеет место быть в GNOME Terminal'е, который Cinnamon юзает вместо отсутствующего родного.</p>
    <p class="Textbody">Вообще поначалу удобно разместить рядом два терминальных окна, и в одном открывать текст для набора или редактирования, а в другом — вызвать справку и постоянно с ней сверяться:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/nano_002.png">
        <img alt="Изображение235" class="frameGraphics" id="235graphic" src="http://alv.me/wp-content/img/im_cin_img/nano_002-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a235graphic"></a>
      <a id="bkm235graphic"></a>
    </p>
    <p class="Textbody">Потому что, повторяю, управляющих последовательностей в Nano довольно много — больше, чем можно запомнить с одного просмотра, и все они полезны в практической работе.</p>
    <p class="Textbody">А ещё они бывают двух видов — в сочетании с клавишей Control и с клавишей Meta. Последней на современных клавиатурах не найти — она эмулируется либо нажатием клавиши Alt, либо нажатием и отпусканием клавиши Escape, хотя поледний способ и не всегда срабатывает..</p>
    <p class="Textbody">Собственно управляющие последовательности, Control+литера, предназначены в основном для редактирования текста и операций с файлами. Управляющие последовательности частично дублируются функциональными клавишами F1–F16. Отсутствующие на клавиатуре функциональные клавиши с F13 по F16 вызываются посредством сочетания Shift+F1–F4.</p>
    <p class="Textbody">Meta-последовательности (то есть сочетания Meta+литера) теоретически предназначены в основном для временого изменения настроек редактора (тот же результат достигается и опциями командной строки). Однако порою клавиша Meta выступает в роли «усилителя» Control-последовательности.</p>
    <p class="Textbody">К слову сказать, в «голой» консоли и Control-, и Meta-последовательности работают при любой раскладке клавиатуры, что латинской, что русской. А вот в терминальных окнах Cinnamon Meta-последовательности при русской раскладке клавиатуры выполнять свои функции отказываются.</p>
    <p class="Textbody">Описывать все управляющие и Meta-последовательности не буду — это сделано в той самой экранной подсказке, да в тому же в локализованной системе — на русском языке. Замечу только, что ничего страшного в них нет. Кейбиндинги для навигации по тексту и его редактирования — так называемые Emacs-подобные, примерно такие же, как в шеллах типа Bash или Zsh. И применителю любой из Sh-подобных командных оболочек могут показаться непривычными только те последовательности, которые отражают специфические функции Nano как редактора. Вот эти-то функции рассмотреть стоит.</p>
    <p class="Textbody">Как нетрудно догадаться, текстовый редактор может вводить и редактировать тексты, и Nano тут не исключение. Причём он умеет делать это в нескольких документах параллельно — каждый из них открывается в собственном так называемом буфере. Для чего сначала нужно включить мультибуферный режим — делается это meta-последовательностью Meta+F. Затем каждый новый буфер открывается с помощью комбинации Control+R, либо введя имя файла непосредственно в появившейся строке, либо, нажав Control+T, перейти в режим визуального выбора файла:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2014/12/nano_003.png">
        <img alt="Изображение236" class="frameGraphics" id="236graphic" src="http://alv.me/wp-content/img/im_cin_img/nano_003-521x572.png" style="border:1.0px solid #000080;padding:0;width:522.8511px;height:573.83685px" />
      </a>
      <a id="a236graphic"></a>
      <a id="bkm236graphic"></a>
    </p>
    <p class="Textbody">Число открытых буферов вроде бы ничем не ограничено — разве что объёмом памяти. Переключение между ними — с помощью Meta+&gt; (вперёд) и Meta+&lt; (назад).</p>
    <p class="Textbody">Если при задйствовании нескольких буферов отключить мультибуферный режим (это делается повторением комбинации Meta+F), то открытые буфера никуда не деваются, и переключаться между ними можно по прежнему, но вот открыть новый буфер уже не получится до повторного включения мультибуферного режима. А в днобуферном режиме комбинация Control+R после выбора файла вместо открытия втсавит его содержимое в позиции курсора текущего документа.</p>
    <p class="Textbody">Между буферами возможен обмен данными. Так, строка, скопированная (посредством Meta+6) или вырезанная (комбинацией Control+K) в одном буфере, может быть вставлена (с помощью Control+U) в другом. Ну и в «родном», разумеется, тоже.</p>
    <p class="Textbody">Надо заметить, что в Nano есть и другой способ одновременного редактирования нескольких файлов. Комбинация клавиш Meta+Z приостанавливает работу редактора (точнее, переводит его в фоновый режим), возвращая приглашение командной строки, в которой Nano можно запустить заново. Но это будет уже другой его экземпляр, и обмен между ними через буфер невозможен — это можно сделать только «мышиным» выделением и вставкой кликом средней её кнопкой. Однако в этой временной командной строке можно выполнить какие-либо команды, а результаты через то же «мышиное» выделение поместить в редактируемый документ. Возврат в который из командной строки — по команде fg.</p>
    <p class="Textbody">Очень полезная особенность Nano — возможность включения режима мягкого переноса слов (точнее, символов — softwrap), о которой я уже говорил. Здесь же добавлю, что это можно сделать не только через конфиг или опцию запуска Nano, но и прямо в его сеансе — последовательностью Meta+$. Я уделяю этому вопросу столько внимания, потому что такая, казалось бы, мелочь очень важна для сочинителя нарративных текстов — и не только при доводке их в word-процессоре или программе вёрстки, где лишние разрывы строк — вечный повод для головной боли. Не меньше они мешаются при поиске в архивах собственной нетленки по смутно запомнившимся её фрагментам.</p>
    <p class="Textbody">Думаю, важность подстветки синтаксиса понимают не только программисты и профессиональные web-разработчики. Ибо мода сочинять конфиги в XML-формате затронула многие рабочие среды. А разобраться в XML-файле без подсветки — проще удавиться. Да и сочинителям нарративных текстов, не брезгующим одновременно их разметкой (в HTML ли, или в TeX) это тоже лишним не покажется. И Nano поддерживает оную с давних пор, а с некоторого времени эта фича включена в нём по умолчанию. Список поддерживаемых языков программирования и разметки, а также дистрибутив-специфичных файлов можно посмотреть так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls /usr/share/nano</span> </p>
    <p class="Textbody">И выглядит он следующим образом:</p>
    <p class="Textbody"><span style="background-color:#dddddd">asm.nanorc      groff.nanorc     nanorc.nanorc  ruby.nanorc</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">awk.nanorc      html.nanorc      objc.nanorc    sh.nanorc</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">cmake.nanorc    java.nanorc      ocaml.nanorc   tcl.nanorc</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">c.nanorc        makefile.nanorc  patch.nanorc   tex.nanorc</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">css.nanorc      man.nanorc       perl.nanorc    xml.nanorc</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">debian.nanorc   mgp.nanorc       php.nanorc</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">fortran.nanorc  mutt.nanorc      pov.nanorc</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">gentoo.nanorc   nano-menu.xpm    python.nanorc</span> </p>
    <p class="Textbody">Правда, возможно, цветовая гамма в них не всем покажется идеальной. Но, как известно, на цвет товарищей нет, и никто не мешает отредактировать её вкусу своих фломастеров.</p>
    <p class="Textbody">Далее — проверка орфографии, которая одинаково важна для всех применителей, даже тех, кто, подобно автору этих строк, ею подчас манкирует. Для обеспечения оной в файле ~/nanorc нужно снять комментарий со строки</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">set speller "aspell -x -c"</span> </p>
    <p class="Textbody">После чего по комбинации Control+T (или по клавише F12, если та не задействована для других целей, например, вызова выпадающего терминала) для спеллинга будет вызываться программа aspell — если она, конечно, установлена и снабжена словарем для требующегося языка. В Mint пакет aspell устанавливается по умолчанию, но сопровождается только английским словарём. Так что для обеспечения проверки орфографии в русскоязычных текстах надо установить пакет aspell-ru.</p>
    <p class="Textbody">И, наконец, остается только сделать Nano редактором по умолчанию — чтобы использовать его по умолчанию в командах типа sudoedit и visudo (а также везде, где потребуется впредь). Для чего воспользуемся им самим же, открыв в нем конфигурационный файл своей пользовательской командной оболочки. Например, для Bash — так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ nano ~/.bashrc</span> </p>
    <p class="Textbody">И вписав в него такую вот строку:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">export EDITOR=nano</span> </p>
    <p class="Textbody">определяющую переменную среды EDITOR. Теперь редактор nano будет вызываться при редактировании системных конфигов, например, командой sudoedit.</p>
    <p class="Textbody">Функциональные возможности Nano на фоне Vim или Emacs не производят впечатления исключительно богатых. Однако это — не только минус, но и плюс: ограниченный набор функций легче освоить и особенно — держать в голове при эпизодическом применении. Тем более, что их хватает не только на несложную правку мелких конфигов, но и на сочинение не слишком масштабных нарративных текстов.</p>
    <h2 id="toc105"><a id="RefHeading16521713816058"></a><a id="bkmRefHeading16521713816058"></a><a id="toc104"></a><a id="bkmtoc104"></a><a id="RefHeading12661136957987"></a><a id="bkmRefHeading12661136957987"></a><a id="bkmRefHeading12661136957987"></a><a id="bkmbkmRefHeading12661136957987"></a>Mint и Zsh</h2>
    <p class="Textbody">В предыдущем очерке работа в CLI была рассмотрена на примере Bash — самой распространённой командной оболочки Linux'а. Однако о ней написаны пуды бумажной литературы и мегабайты сетевых материалов, повторять которые было бы скучно. И к тому же в реальной жизни я её практически не использую. Поэтому далее будет рассмотрена оболочка Zsh.</p>
    <p class="Textbody">Кроме борьбы со скукой, есть и немало более технических аргументов в пользу применения Zsh как пользовательской оболочки (login shell):</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">функциональность, существенно превосходящая возможности Bash в интерактивной работе; </p>
      </li>
      <li>
        <p class="Textbody">расширяемость за счёт дополнительных модулей; </p>
      </li>
      <li>
        <p class="Textbody">настраиваемость, ограниченная практически только фантазией применителя; </p>
      </li>
      <li>
        <p class="Textbody">прекрасная документированность — объём официальной документации составляет более 3 МБ в формате HTML (не считая прочих форматов); </p>
      </li>
      <li>
        <p class="Textbody">активное сообщество энтузиастов — разработчиков и применителей. </p>
      </li>
    </ul>
    <p class="Textbody">Не последним аргументом в пользу Zsh является его отличная интеграция с утилитой apt, лежащей в основе пакетного менеджмента дистрибутива Mint. До сих пор, описывая действия по управлению пакетами в CLI, я, будучи давним пользователем Zsh, приводил их к общему знаменателю с Bash. В один прекрасный момент мне это надоело. Причём отказываться от мощного функционала Zsh, к которому привык так, что без него как без рук, не не собираюсь. И потому решил впредь помещать в тексты своих сочинений команды в «Zsh'изированной» форме. А для пояснения их сути — написать настоящуюю серию мини-очерков и включить её в книгу про Mint.</p>
    <h3 id="toc106"><a id="RefHeading16541713816058"></a><a id="bkmRefHeading16541713816058"></a><a id="toc105"></a><a id="bkmtoc105"></a><a id="RefHeading4981136957987"></a><a id="bkmRefHeading4981136957987"></a><a id="bkmRefHeading4981136957987"></a><a id="bkmbkmRefHeading4981136957987"></a>Zsh как login shell</h3>
    <p class="Textbody">В Mint в качестве системной командной оболочки, то есть интерпретатора общесистемных сценариев, выступает Dash (Debian-клон оболочки Альмквиста, ash), лёгкая и компактная, но имеющая слабые возможности для интерактивной работы. Для последней, как и в подавляющем большинстве дистрибутивов Linux, используется Bash, которая является пользовательской оболочкой (login shell) по умолчанию. Что же до Zsh, она отсутствует в стандартной инсталляции Mint, но доступна в официальном репозитории, из которого легко может быть установлена.</p>
    <p class="Textbody">Начинающему применителю Mint проще всего установить Zsh с помощью описанного ранее менеджера пакетов. Для чего сначала надо отыскать соответствующий пакет:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_001.png">
        <img alt="Изображение237" class="frameGraphics" id="237graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_001-572x461.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:462.83212px" />
      </a>
      <a id="a237graphic"></a>
      <a id="bkm237graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_001.png"> </a>
    </p>
    <p class="Textbody">После чего поглядеть на его описание и установить:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_002.png">
        <img alt="Изображение238" class="frameGraphics" id="238graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_002-572x530.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:531.8463px" />
      </a>
      <a id="a238graphic"></a>
      <a id="bkm238graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_002.png"> </a>
    </p>
    <p class="Textbody">Однако просто иметь Zsh мало — его надо сделать регистрационной оболочкой (login shell) в своём аккаунте. Как ни странно, в обоих графических модулях Системных настроек Cinnamon такой возможности нет. Однако можно прибегнуть к графической утилите usermode, предварительно установив её через Менеджер приложений и запустив из главного меню, где она скрывается в секции Параметры под именем О себе и после запуска выглядит таким образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_003.png">
        <img alt="Изображение239" class="frameGraphics" id="239graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_003.png" style="border:1.0px solid #000080;padding:0;width:341.84946px;height:252.84157px" />
      </a>
      <a id="a239graphic"></a>
      <a id="bkm239graphic"></a>
    </p>
    <p class="Textbody">После установки Zsh её можно будет выбрать из выпадающего списка в поле Оболочка:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_004.png">
        <img alt="Изображение240" class="frameGraphics" id="240graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_004.png" style="border:1.0px solid #000080;padding:0;width:380.8542px;height:376.8479px" />
      </a>
      <a id="a240graphic"></a>
      <a id="bkm240graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_004.png"> </a>
    </p>
    <p class="Textbody">Кажется, это единственное, что может сделать полезного данная утилита. Поэтому возникает вопрос — а стоит ли устанавливать её ради разовой операции? Может быть, лучше прибегнуть к самому простому способу смены login shell — прямой команде? Тот этой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ chsh -s /bin/zsh</span> </p>
    <p class="Textbody">Вопрос, как вы понимаете, риторический…</p>
    <p class="Textbody">Каким бы образом ни была назначена Zsh <span style="text-decoration:line-through">любимой женой</span> пользовательской командной оболочкой, следующая авторизация данного пользователя в «голой» консоли однозначно её запустит. В эмуляторах же терминала, возможно, потребуется внести некоторые изменения в их настройках, например, предписать запуск /bin/zsh явным образом, или отметить опцию запуска оболочки как login shell.</p>
    <p class="Textbody">В любом случае первый запуск сеанса пользователя с новой оболочкой предложит такие варианты выбора:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">q — выход из программы автоконфигурирования без последствий; при следующем входе в оболочку вызов её будет повторён; </p>
      </li>
      <li>
        <p class="Textbody">0 — выход из автоконфигурирования с созданием пустого конфига ~/.zshrc, предотвращающем в дальнейшем повторения автоконфигурирования; </p>
      </li>
      <li>
        <p class="Textbody">1 — вызов главного меню; </p>
      </li>
      <li>
        <p class="Textbody">2 — создание конфига ~/.zshrc по образу и подобию эталонного, /etc/zsh/newuser.zshrc.recommended, который в дальнейшем может редактироваться вручную. </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_005.png">
        <img alt="Изображение241" class="frameGraphics" id="241graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_005-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a241graphic"></a>
      <a id="bkm241graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_005.png"> </a>
    </p>
    <p class="Textbody">С вариантом q всё ясно, это просто откладывание вопроса на потом, вариант 1, с автоконфигурированием, был некогда <a href="http://fossbook.info/subproj/shell/1120" target="_blank">описан достаточно подробно</a>, и с тех пор процесс этот ничуть не изменился, вариант же 2 зависит от настроек общего конфига оболочки, принятых майнтайнерами данного дистрибутива. Так что я хотел бы сконцентрировать внимание на «нулевом» варианте. И последовательно рассмотреть все настройки, которые потребуется выполнить применителю для создания комфортной среды CLI. Не абстрактно, разумеется, а применительно к целям и задачам себя, любимого. Так что читатель должен воспринимать всё сказанное в этих очерках далее, не как догму, а как руководство к действиям, то есть экспериментам, и к размышлениям о своих потребностях.</p>
    <p class="Textbody">Однако прежде отмечу, что применителю не обязательно сразу определять Zsh как login shell. Он может вызвать её из командной строки Bash:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /bin/zsh</span> </p>
    <p class="Textbody">Запуск Zsh ознаменуется сменой вида приглашения командной строки с Bash'евской, которая в Mint'е по умолчанию выглядит так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zshuser@alv-cinn ~ $</span> </p>
    <p class="Textbody">на умолчальную Zsh'еву:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alv-cinn%</span> </p>
    <p class="Textbody">Вот с настройки вида приглашения командной строки я и начну. Добавив только, что после каждого изменения в конфиге ~/.zshrc для вступления его в силу вовсе не обязательно завершать сеанс и авторизоваться заново — достаточно такой команды:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alv-cinn% source .zshrc</span> </p>
    <p class="Textbody">Кстати, конфигурационных файлов для Zsh предусмотрено много, и порядок их считывания тоже определён жёстко. Однако далее речь будет идти, за одним специально оговоренным исключением, только о редактировании ~/.zshrc. Почему? Да потому, что остальные конфиги или были придуманы для совместимости с оболочкой совсем другого семейства, Tcsh, или не оказывают влияния на пользовательский сеанс.</p>
    <h3 id="toc107"><a id="RefHeading16561713816058"></a><a id="bkmRefHeading16561713816058"></a><a id="toc106"></a><a id="bkmtoc106"></a><a id="RefHeading5001136957987"></a><a id="bkmRefHeading5001136957987"></a><a id="bkmRefHeading5001136957987"></a><a id="bkmbkmRefHeading5001136957987"></a>Документация</h3>
    <p class="Textbody">Но прежде чем перейти к настройкам Zsh, надо сказать несколько слов о его документации, столь расхваленной мной во вводных словах. И первое, что тут удивляет — отсутствие для его текущих версий (5.0.X) стандартных man-страниц. Раньше они были, причём во множестве: собственные страницы были посвящены отдельным частям этой оболочки (опциям, параметрам, функциям etc.), а сама по себе страница man (1) zsh играла роль оглавления.</p>
    <p class="Textbody">Но со временем суммарный объём man-документации достиг такого размера, что ей стало практически невозможно пользоваться в том режиме, в котором мы все привыкли общаться с любимой тётей Маней. И потому разработчики Zsh от man-страниц в составе самого пакета отказались.</p>
    <p class="Textbody">Но зато, во-первых, пакет zsh и жёстко с ним связанный zsh-common сопровождается пакетом zsh-doc, который в большинстве дистрибутивов (в том числе и в Mint) следует устанавливать отдельно. Он содержит материалы в форматах info и html общим объёмом 6 МБ, а также включает PDF-руководство на 400 страниц.</p>
    <p class="Textbody">Во-вторых, Zsh сопровождается также пакетом zsh-lovers — он также устанавливается отдельно, и его компоненты после этого будут располагаться в каталоге /usr/share/doc/zsh-lovers. Он озаглавлен так: Советы, рекомендации и примеры для Z Shell. И содержит большинство тех самых man-страниц, которые были изъяты из основного пакета — в чисто текстовом формате или в виде gz-компрессированных файлов. А также — заявленные советы, рекомендации и примеры, созданные многочисленными применителями этой оболочки. Все они поимённо перечислены в файле /usr/share/doc/zsh-lovers/README. Своего рода квинтэссенцией пакета является страница man (1) zsh-lovers, в конспективной форме описывающая основные возможности этой оболочки, иллюстрируя их примерами. Собственно, её обзор (OVERVIEW) и начинается словами:</p>
    <p class="Textbody">Каждый раз, когда мы заглядываем в руководство по Zsh, мы удивляемся, почему там нет примеров или просто случаев из жизни в командной оболочке. Возможностей у Zsh, много, а руководства, иллюстрирующего их примерами, нет. Поэтому мы написали своё руководство.<br />…<br />Это просто развлекухи ради.</p>
    <p class="Textbody">И, надо сказать, развлекуха получилась не без пользы для нас, применителей. Кстати, читать эту развлекуху можно также в форматах HTML и PDF.</p>
    <p class="Textbody">В-третьих, неисчислимое по объёму количество информации о Zsh'е имеется в Интернете — и всё это богачество доступно по ссылкам с <a href="http://www.zsh.org/" target="_blank">официальный сайт</a>, главнейшей из которых является ссылка на <a href="http://zsh.sourceforge.net/" target="_blank">zsh.sourceforge.net</a>. Здесь можно найти руководства по этому шеллу на любой вкус — от «юзерофильного» до исчерпывающего, а также ссылки на книги, wiki, статьи и прочие материалы. Разбираться в этом океане я предоставляю заинтересованным (или заинтересовавшимся) читателям.</p>
    <p class="Textbody">В-четвёртых, существует сайт, именуемый <a href="http://ohmyz.sh/" target="_blank">Oh My ZSH!</a>. Это коллекция плагинов, скриптов, конфигов и тем приглашения командной строки. Она инсталлируется на локальную машину и в дальнейшем автоматически синхронизируется с родительским сайтом, который пользуется всенародной популярностью и широкой известностью в узких кругах энтузиастов Zsh.</p>
    <p class="Textbody">Наконец, в-пятых, официальными, полуофициальными и общенародными ресурсами информация о Zsh не исчерпывается — существует много «неучтённых» на zsh.sourceforge.net сайтов и блогов, ведомых любителями этого шелла. И на них часто можно найти освещёние неожиданных и интересных нюансов его конфигурирования. В последние годы в их числе появились и русскоязычные ресурсы. Из последних хотелось бы отметить подборку статей на <a href="http://muhas.ru/" target="_blank">сайте Михаила Мищенкова aka muhas</a>).</p>
    <h3 id="toc108"><a id="RefHeading16581713816058"></a><a id="bkmRefHeading16581713816058"></a><a id="toc107"></a><a id="bkmtoc107"></a><a id="RefHeading5021136957987"></a><a id="bkmRefHeading5021136957987"></a><a id="bkmRefHeading5021136957987"></a><a id="bkmbkmRefHeading5021136957987"></a>Настройка приглашения</h3>
    <p class="Textbody">Как известно со времён со времён Константин Сергеича Станиславского, театр начинается с вешалки, а дистрибутив — с инсталлятора. Командная же оболочка начинается с приглашения командной строки. Каковая, во-первых, отражает готовность системы к выполнению действий применителя, а во-вторых, несёт (или должна бы нести) некую существенную для него информацию.</p>
    <p class="Textbody">Правда, умолчальное приглашение Zsh информативностью не блещёт, сообщая только имя хоста (в примере на предыдущей странице — alv-cinn), и то, что сеанс шелла запущен обычным пользователем — в отличие от Bash'а, здесь это по умолчанию выражается символом %. Однако добавить информации нам никто не мешает. А помогает — файл zshexports.gz из пакета zsh-lovers, упомянутого в позапрошлом очерке. Его можно просмотреть командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ zcat path3/zshexports.gz</span> </p>
    <p class="Textbody">отыскать в нём секцию, начинающуюся словами</p>
    <p class="Textbody"><span style="background-color:#dddddd"># PS{1,2,3}, RPOMPT, ..</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"># The "prompt" of the shell</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">внимательно изучить её, а также фрагмент конкретных примеров:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># Some examples:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">#  PS1="PS1='%B%n%b@%m:%4c&gt;'"</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">осмыслить прочитанное и опробованное на примерах. После чего решить, какую же информацию вы хотите видеть в приглашении командной строки.</p>
    <p class="Textbody">Я, например, не хочу видеть там имени хоста, поскольку не дожил ещё до ситуации из известного аккордеонистого бояна: «Кто я, кто я? Губайдулин я!» Да и вообще, времена, когда каждая машина в сети имела собственное неповторимое имя, канули в лету, и нынче так называемое «хвостнаме» берётся от булды.</p>
    <p class="Textbody">А вот имя пользователя в явном виде будет не лишним — у меня на основной машине их обычно не менее трёх: рабочий, экспериментальный и умолчально-восстановительный. Также неплохо иметь представление о своём положении в файловой иерархии, причём в полном виде — одноимённые подкаталоги часто находятся в разных её ветвях. Приглашение получается перегруженным? Отнюдь, потому что в Zsh таковых предусмотрено два — просто PROMPT и RPROMT, и перечисленные элементы можно разнести таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/home/data/current $=&gt;                                  [alv]</span> </p>
    <p class="Textbody">Или наоборот, таким:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">[zshuser]$=&gt;                                  [/home/data/current]</span> </p>
    <p class="Textbody">Добиться этого можно, как вы понимаете, редактированием файла ~/.zshrc. До сих пор он у нас содержал единственную строку комментария:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># Created by newuser for 5.0.2</span> </p>
    <p class="Textbody">Теперь же добавляем в него сторки для получения приглашения первого вида:</p>
    <p class="Textbody"><span style="background-color:#dddddd">## Prompt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">PROMPT='%~ $=&gt; '</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">RPROMPT=' [%n] '</span> </p>
    <p class="Textbody">Или второго:</p>
    <p class="Textbody"><span style="background-color:#dddddd">## Prompt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">PROMPT='[%n]$=&gt; '</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">RPROMPT=' [%~] '</span> </p>
    <p class="Textbody">Раньше мне больше нравился первый вариант, но ныне я перешёл на второй.</p>
    <p class="Textbody">Кроме обычного, то есть «левого» приглашения и приглашения «правого», в Zsh поддерживаются также приглашение «вторичное», выводимое в многострочных командах, и «третичное» — предложение вариантов замены при включённой коррекции ошибок, PROMPT2 и PROMPT3, соответственно. Вторичное приглашение у меня имеет вид</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">PROMPT2='%i%U&gt; '</span> </p>
    <p class="Textbody">В результате в нём выводится номер «вторичной» строки в данном сеансе шелла, указывается стрелкой на то, что ввод следует в ней продолжить, а сам ввод даётся подчёркнутым шрифтоначертанием. Вживе это выглядит так:</p>
    <p class="Textbody"><span style="background-color:#dddddd">[zshuser]$=&gt; echo $USER \                                   [~]</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">33&gt; echo $SHELL \</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">34&gt; echo $PATH</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zshuser echo /bin/zsh echo /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span> </p>
    <p class="Textbody">Что же до коррекции ошибок, у меня она отключена (к этому вопросу мы ещё вернёмся).</p>
    <p class="Textbody">А вообще, как можно увидеть в файле zshexports.gz, в любом из видов приглашения командной строки могут фигурировать:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">полное или сокращенное имя хост-машины; </p>
      </li>
      <li>
        <p class="Textbody">путь к текущему каталогу в различных формах; </p>
      </li>
      <li>
        <p class="Textbody">номер текущей команды в буфере истории или строки в данном сеансе работы; </p>
      </li>
      <li>
        <p class="Textbody">имя пользователя; </p>
      </li>
      <li>
        <p class="Textbody">название командной оболочки; </p>
      </li>
      <li>
        <p class="Textbody">номер виртуальной консоли или текущего терминала; </p>
      </li>
      <li>
        <p class="Textbody">дата и время в разных форматах; </p>
      </li>
      <li>
        <p class="Textbody">индикация работы от лица суперпользователя; </p>
      </li>
      <li>
        <p class="Textbody">любые символы типа стрелок, крышечек, скобочек; </p>
      </li>
      <li>
        <p class="Textbody">текстовые сообщения (например, поздравление с началом трудового процесса); </p>
      </li>
      <li>
        <p class="Textbody">и многое другое. </p>
      </li>
    </ul>
    <p class="Textbody">Кроме того, приглашение могут быть оформлены визуально различно: выделением жирным шрифтом (boldface mode), инвертированием текста/фона (standout mode), полчёркиванием (underline mode), а также цветами. «Раскрашенный» шелл мне нравится не больше, чем «раскрашенный» Штирлиц, инвертирование также вызывает раздражение, а вот выделение полужирным шрифтоначертанием и подчёркиванием я использую. В результате секция настройки вида приглашения в моём ~/.zshrc выглядит так:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># Left prompt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">PROMPT='%B[%n]$=&gt;%b '</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">PROMPT2='%i%U&gt; '</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">#</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"># Right prompt</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">RPROMPT=' %B[%~]%b '</span> </p>
    <p class="Textbody">Как уже говорилось, я не призываю к подражательству, а лишь предлагаю поэкспериментировать, чтобы добиться максимальной информативности приглашения и его внешней выразительности.</p>
    <h3 id="toc109"><a id="RefHeading16601713816058"></a><a id="bkmRefHeading16601713816058"></a><a id="toc108"></a><a id="bkmtoc108"></a><a id="RefHeading5041136957987"></a><a id="bkmRefHeading5041136957987"></a><a id="bkmRefHeading5041136957987"></a><a id="bkmbkmRefHeading5041136957987"></a>Темы приглашений</h3>
    <p class="Textbody">Только что речь шла о том, как оформить приглашение командной строки Zsh своими руками, в соответствие с собственными вкусами и предпочтениями. Однако можно пойти другим путём, и воспользоваться уже готовыми темами приглашений. Они входят в пакет zsh-common, который всегда, насколько я знаю, устанавливается как зависимость пакета zsh. После установки местоположение готовых тем — каталог /usr/share/zsh/functions/Prompts.</p>
    <p class="Textbody">Сами по себе темы приглашения — файлы вида prompt_themename_setup, представляющие собой функции Zsh, описывающие как вид приглашения, так и, часто, некоторый его декор, типа расцветки, которая может быть нескольких видов. Однако разбираться в устройстве этих функций не обязательно — с ними можно ознакомиться визуально.</p>
    <p class="Textbody">Знакомство это начинается с запуска функций управления видом приглашений:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ autoload -U promptinit &amp;&amp; promptinit</span> </p>
    <p class="Textbody">После чего можно давать команду на «смотрины невест»:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ prompt -p</span> </p>
    <p class="Textbody">которая выведет их все (в моей системе — около двух десятков, плюс цветовые вариации) примерно в таком виде:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_006.png">
        <img alt="Изображение242" class="frameGraphics" id="242graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_006-540x572.png" style="border:1.0px solid #000080;padding:0;width:541.8243px;height:573.83685px" />
      </a>
      <a id="a242graphic"></a>
      <a id="bkm242graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_006.png"> </a>
    </p>
    <p class="Textbody">Среди «невест» можно видеть весьма пёстро наряженных:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_0071.png">
        <img alt="Изображение243" class="frameGraphics" id="243graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_0071-540x572.png" style="border:1.0px solid #000080;padding:0;width:541.8243px;height:573.83685px" />
      </a>
      <a id="a243graphic"></a>
      <a id="bkm243graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_0071.png"> </a>
    </p>
    <p class="Textbody">Но и одетых весьма скромно также есть:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_008.png">
        <img alt="Изображение244" class="frameGraphics" id="244graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_008-540x572.png" style="border:1.0px solid #000080;padding:0;width:541.8243px;height:573.83685px" />
      </a>
      <a id="a244graphic"></a>
      <a id="bkm244graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_008.png"> </a>
    </p>
    <p class="Textbody">Выбрав подходящую <span style="text-decoration:line-through">невесту</span> тему, её можно тут же установить командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ prompt имя_темы</span> </p>
    <p class="Textbody">при желании — с указанием цветовых параметров, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ prompt fade white grey blue</span> </p>
    <p class="Textbody">Что в «живом» терминальном окне (терминал Sakura) будет выглядеть так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_009.png">
        <img alt="Изображение245" class="frameGraphics" id="245graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_009-572x290.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:291.8463px" />
      </a>
      <a id="a245graphic"></a>
      <a id="bkm245graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_009.png"> </a>
    </p>
    <p class="Textbody">А в выпадающем терминале Guake — несколько иначе:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_010.png">
        <img alt="Изображение246" class="frameGraphics" id="246graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_010-572x305.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:306.85104px" />
      </a>
      <a id="a246graphic"></a>
      <a id="bkm246graphic"></a>
    </p>
    <p class="Textbody">Кстати, а в «голой» консоли вид этой же темы будет существенно скромнее — разбираться с программами для изготовления скриншотов консоли мне было лень, так что прошу поверить на слово.</p>
    <p class="Textbody">Установленная таким образом тема будет функционировать только в данном терминальном окне в течении текущего сеанса. Чтобы увековечить её, необходимо вписать в файл ~/.zshrc такие строки:</p>
    <p class="Textbody"><span style="background-color:#dddddd">autoload -Uz promptinit</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">promptinit</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">prompt clint</span> </p>
    <p class="Textbody">В примере приведена тема, пожалуй, наиболее информативного приглашения, которое «вживе» вылядит так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_011.png">
        <img alt="Изображение247" class="frameGraphics" id="247graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_011-572x290.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:291.8463px" />
      </a>
      <a id="a247graphic"></a>
      <a id="bkm247graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/zsh_011.png"> </a>
    </p>
    <p class="Textbody">Большое количество тем можно при желании отыскать на сайте <a href="http://ohmyz.sh/" target="_blank">Oh My ZSH!</a>, но эти я уже заниматься не стал.</p>
    <h3 id="toc110"><a id="RefHeading16621713816058"></a><a id="bkmRefHeading16621713816058"></a><a id="toc109"></a><a id="bkmtoc109"></a><a id="RefHeading5061136957987"></a><a id="bkmRefHeading5061136957987"></a><a id="bkmRefHeading5061136957987"></a><a id="bkmbkmRefHeading5061136957987"></a>Приёмы навигации</h3>
    <p class="Textbody">Сознательные граждане, активно применяющие CLI, используют множество команд, как встроенных в их любимый шелл, так и внешних. Но, думаю, что самыми употребимыми в повседневной жизни являются такие:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">pwd для определения своего текущего положения на файловом древе — да-да, иногда, после многократных переходов между подкаталогами, забываешь, не только кто я, но и где я (уж не в Тимирязском ли?); </p>
      </li>
      <li>
        <p class="Textbody">ls — для просмотра содержимого текущего каталога; </p>
      </li>
      <li>
        <p class="Textbody">cd — для перехода в определённый каталог. </p>
      </li>
    </ul>
    <p class="Textbody">Однако здесь Zsh вносит свои коррективы, здорово облегчающие жизнь его применителя. Только что было показано, как фактическим можно избавиться от команды pwd, выведя путь к текущему каталогу в качестве RPROMPT. Без команды ls, конечно, не обойтись и Zsh. А вот команда cd в Zsh просто… не нужна.</p>
    <p class="Textbody">Да, дорогие мои болельщики, в среде Zsh без этой команды не просто можно обойтись, а жить куда комфортней, нежели с ней. Ведь давайте вспомним, что такое переход в каталог имя_рек? Для типа файлов, именуемого каталогом (directory) это то же самое, что исполнение для обычного (ordinary) файла, будь он откомпилированным бинарником или интерпретируемым сценарием.</p>
    <p class="Textbody">И потому более чем логично то, что как для запуска скрипта оболочки не требуется никакой внешней команды (хотя и не возбраняется что-нибудь типа . или /bin/sh), так и для перехода в каталог, к которому данный юзер имеет доступ (то есть попадает в число тех, для кого у этого каталога установлен бит исполнения), ему достаточно указать полный путь к нему, без всяких команд. Например, введя к командной строке что-нибудь вроде</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /usr/share/fonts/truetype/</span> </p>
    <p class="Textbody">можно сразу оказаться в каталоге с TTF-шрифтами.</p>
    <p class="Textbody">«Бескомандный» переход в каталоги распространяется и на «символические» обозначения последних. Так, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ~</span> </p>
    <p class="Textbody">переместит пользователя в его домашний каталог. Как, кстати, и команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ $HOME</span> </p>
    <p class="Textbody">Хотя практического смысла последний вариант не имеет. Зато директива</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ..</span> </p>
    <p class="Textbody">волшебным образом ознаменует переход в каталог, родительский относительно текущего.</p>
    <p class="Textbody">Правда, всё это происходит не само собой: для практического воплощения этого волшебства в общесистемном конфиге /etc/zsh/zshrc или пользовательском ~/.zshrc должна присутствовать строка</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">setopt autocd</span> </p>
    <p class="Textbody">В пару к ней можно добавить ещё и такую строку:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">cdpath=(~/ /home/current/ /home/data/)</span> </p>
    <p class="Textbody">где в скобках перечислены каталоги, к подкаталогам которых чаще всего требуется быстрый доступ. И теперь, где бы в пределах файлового древа ни находился пользователь, ввод им директивы</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ Documents</span> </p>
    <p class="Textbody">нечувствительно сделает текущим каталогом /home/username/Documents.</p>
    <p class="Textbody">То есть опция autocd и массив переменных cdpath отнюдь не исключают, а прекрасно дополняют друг друга.</p>
    <h3 id="toc111"><a id="RefHeading16641713816058"></a><a id="bkmRefHeading16641713816058"></a><a id="toc110"></a><a id="bkmtoc110"></a><a id="RefHeading5081136957987"></a><a id="bkmRefHeading5081136957987"></a><a id="bkmRefHeading5081136957987"></a><a id="bkmbkmRefHeading5081136957987"></a>Автодополнение</h3>
    <p class="Textbody">Волшебное свойство клавиши Tab, вызывающей автодополнение — одно из первых, с чем знакомится применитель CLI. Хотя при этом часто забывается, что когда-то, в перворождённом шелле Борна, никакого автодополнения не было. Оно появилось в Csh — и сначала только для путей, но не для команд. Тем не менее, ныне представить себе интерактиную работу в командной строке без автодополнения невозможно (да и не нужно).</p>
    <p class="Textbody">Однако в Zsh клавиша Tab волшебна дважды: она не только дополняет пути и команды после их частичного ввода, но и способна развернуть аббревиатуры для тех и других. Например, нажатие клавиши табулции после набора последовательности</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /u/s/f/tr</span> </p>
    <p class="Textbody">развернёт её в полный путь к каталогу со шрифтами TrueType</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /usr/share/fonts/truetype</span> </p>
    <p class="Textbody">а после нажатия клавиши Enter сделает этот каталог текущим, как мы только что видели.</p>
    <p class="Textbody">Правда, само по себе развёртывание аббревиатур работать не будет — его надо активизировать такими строками в файле ~/.zshrc:</p>
    <p class="Textbody"><span style="background-color:#dddddd"> autoload -Uz compinit</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">compinit</span> </p>
    <p class="Textbody">Можно пойти дальше, и не просто разворачивать безальтернативные аббревиатуры, типа приведённый выше, но и выбирать стрелками, как в меню, подкаталги или файлы среди предлагаемый альтернатив. Например, если набрать ту же самую<br />последовательность символов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /u/s/f/tr</span> </p>
    <p class="Textbody">а затем дважды нажать клавишу табуляции, то она не только развернётся в полный путь</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /usr/share/fonts/truetype/</span> </p>
    <p class="Textbody">но и выведет список подкаталогов указанного каталога:</p>
    <p class="Textbody"><span style="background-color:#dddddd">dejavu/ freefont/ openoffice/ ubuntu-font-family/ droid/ liberation/</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">ttf-dejavu/ wqy/</span> </p>
    <p class="Textbody">И выбор нужного среди них можно выполнять либо стрелками управления курсором, либо обычными кейбиндингами типа Control+f, Control+b и им подобными:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/zsh_012.png">
        <img alt="Изображение248" class="frameGraphics" id="248graphic" src="http://alv.me/wp-content/img/im_cin_img/zsh_012-572x305.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:306.85104px" />
      </a>
      <a id="a248graphic"></a>
      <a id="bkm248graphic"></a>
    </p>
    <p class="Textbody">Правда, и такая реакция Zsh на Tab возникает не из воздуха, а из присутстствия в файле ~/.zshrc таких строк:</p>
    <p class="Textbody"><span style="background-color:#dddddd"> setopt menucomplete</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zstyle ':completion:*' menu select=1 _complete _ignored _approximate</span> </p>
    <p class="Textbody">По умолчанию их там нет, а вот стоит ли их вносить — применитель должен решить для себя сам — перебор вариантов традиционным способом, то есть последовательным нажатием клавиши табулции, может показаться более удобным.</p>
    <h3 id="toc112"><a id="RefHeading16661713816058"></a><a id="bkmRefHeading16661713816058"></a><a id="toc111"></a><a id="bkmtoc111"></a><a id="RefHeading5101136957987"></a><a id="bkmRefHeading5101136957987"></a><a id="bkmRefHeading5101136957987"></a><a id="bkmbkmRefHeading5101136957987"></a>История команд</h3>
    <p class="Textbody">Возможность просмотра истории введённых ранее команд клавишами Up/Down кажется таким же неотъемлемым атрибутом CLI, как и автодополнение командной строки. И, как и последнее, напрочь отсутствовало в перворождённом шелле Борна, однако ныне имеется во всеш развитых шеллах. Причём доступ к истории команд в них не ограничивается командой history и упомянутыми стрелками. В частности, в Bash широко практикуется инкрементный поиск по клавишной последовательности Control+R и вводу последовательности символов одной из предыдущих команд или её аргументов.</p>
    <p class="Textbody">В tcsh же испокон веков существовала (и, что характерно, обычно была активирована по умолчанию) другая возможность — так называемый history-substring-search, то есть инкрементный перебор истории команд по вводимым символам. Что это такое — проще пояснить на примере: вы вводите в командной строке один символ (для примера — s) и нажимаете клавишу Up. И тут в перебор включаются только те команды из истории, которые с буковки s начинаются. Вводя дополнительные символы, можно сузить круг поиска: например, последовательность sudo позволяет просмотреть, что было наколбасино от лица суперпользователя вообще.</p>
    <p class="Textbody">Поскольку Zsh изначально задумывалась как синтез всех передовых достижений шелло-строительной мысли, аналогичная возможность имеется и здесь. Правда, как и многие другие продвинутые фичи этой оболочки, она требует активации. То есть — внесения в файл ~/.zshrc таких строк:</p>
    <p class="Textbody"><span style="background-color:#dddddd">bindkey "^[[A" up-line-or-search</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">bindkey "^[[B" down-line-or-search</span> </p>
    <p class="Textbody">Как выяснилось, надо подчеркнуть: перебор history-substring-search и инкрементный поиск по Control+R отнюдь не исключают друг друга, а дополняют: первым способом проще искать ранее введённые директивы по имени команды, вторым — по её аргументам, например, по имени файла.</p>
    <p class="Textbody">Справедливости ради надо сказать, что history-substring-search нынче реализован и в Bash, хотя, как и в Zsh, требует активации.</p>
    <p class="Textbody">Опытный применитель Zsh, не имевший ранее дела с Ubuntu и её производными (в том числе и с Mint'ом), будет весьма удивлён тем обстоятельством, что эта фича (по моему мнению, одна из самых полезных среди всех достоинств нашей героини), с кондачка работать не будет. Даже при условии правильно настроенного конфига — при внесённых в него строках, указанных выше. Точнее, не будет делать это в окне любого иксового эмулятора терминала, хотя не откажется от выполнения history-substring-search в «голой» консоли. Причём интересно, что это же касается и Bash, хотя в Tcsh данная фича будет работать «искаропки».</p>
    <p class="Textbody">Следствие, проведённое в Джуйке и благодаря участию джуковца @altwazar'а, показало, что это давний известный баг, восходящий к Debian'у, знаменитому своей стабильностью во всех отношениях (в том числе и в отношении багов, вероятно). И бороться с этим можно различными методами. Мне самым простым показался такой: создание в домашнем каталоге файла ~/.zshenv с единственной строкой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">DEBIAN_PREVENT_KEYBOARD_CHANGES=yes</span> </p>
    <p class="Textbody">Разумеется, на поведение Bash это никак не скажется: в нём history-substring-search включается не через его профильный файл, а через inputrc — конфиг для readline. Как именно — оставляю на рассмотрение преданных поклонников этой оболочки.</p>
    <p class="Textbody">Разумеется, возможности настройки доступа к истории команд всем сказанным выше не исчерпываются: имеет место быть и исключение из неё дубликатов, и пустых строк, и прочего баласта, а также подключения некоторых полезных фич, вроде ограничения общей истории и истории текущего сеанса. А также — дополнения файла истории. Однако ничего особенного, специфичного именно для Zsh, тут уже нет. Так что к рассмотрению этих вопросов я вернусь под занавес — когда буду говорить о ~/.zshrc для себя, любимого...</p>
    <h3 id="toc113"><a id="RefHeading16681713816058"></a><a id="bkmRefHeading16681713816058"></a><a id="toc112"></a><a id="bkmtoc112"></a><a id="RefHeading5121136957987"></a><a id="bkmRefHeading5121136957987"></a><a id="bkmRefHeading5121136957987"></a><a id="bkmbkmRefHeading5121136957987"></a>Рекурсивный поиск</h3>
    <p class="Textbody">Все применители CLI знают и любят утилиту find — и любят заслуженно, ибо это апофеоз командного интерфейса: с её помощью можно отыскать в файловой системе всё, что угодно — и почти всё, что нужно, с найденным сделать, конечно, с помощью некоторых дополнительных средств, вроде xargs и конвейеров. Однако для многих рутинных задач мощь этой команды кажется излишней, напоминая знаменитое упражнение по отстрелу мелких пернатых их зенитно-ракетных комплексов. И вот тут Zsh опять позволяет решать такие задачи малой кровью — то есть с минимальным ударением по клавишам. Ибо поддерживает такую штуку, как рекурсивные поиск.</p>
    <p class="Textbody">Что это такое — как обычно, проще показать, чем рассказать. Предположим, перед применителем стоит задача отыскать все картинки в каталоге некоего проекта, включая все вложенные в него подкаталоги. Средствами Zsh сделать это очень просто — достаточно дать команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls path3/**/*.png</span> </p>
    <p class="Textbody">где path3, как нетрудно догадаться, «корневой» каталог поиска, *.png — маска искомых файлов, а «двузвёздие» — так сказать, директива рекурсивного поиска.</p>
    <p class="Textbody">Правда, вопреки утверждениям некоторых уж очень правоверных Zsh'истов, эта возможность не делает команду find избыточной, ибо, как все знают, она умеет и многое другое. Но зато такая простая директива позволяет не беспокоить Её Величество по пустякам...</p>
    <p class="Textbody">А заодно — конструкции вида **/* можно использовать как аргументы команд управления файлами, таких, как cp, mv, rm. В частности, с помощью команды вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ rm -f path3/**/*~</span> </p>
    <p class="Textbody">можно легко гуртом избавиться от всех временных копий, которые по умолчанию так любят сохранять некоторые текстовые редакторы и ворд-процессоры, если им не запретить это самым категорическим образом.</p>
    <p class="Textbody">Разумеется, можно фильтровать базар. Давеча в приступе чёрной меланхолии переслушивал я всё, что сочинил и спел Фред Солянов — увы, большинство моих потенциальных читателей о его существовании не подозревают: в отличе от многих всенародно известных так называемых «бардов», он не был популярен при жизни. А когда его верхние люди позвали — люди нижние про него забыли напрочь. И зря — но это из совсем другой оперы. А в нынешней арии мне было интересно, сколько же Фред сочинил песен за ту четверть чека, что ему отпустила на то судьба. И я дал очень простую команду:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ ls path3/fred/**/*.mp3 | wc -l</span> </p>
    <p class="Textbody">И она мне сказала, что сочинил Фред 168 песен. Откидываем дубликаты, неизбежные в любой коллекции — но здесь их очень мало, на штуки счёт.</p>
    <p class="Textbody">Откинем откровенно слабые песенки — ведь даже гений не каждое утро начинает с сочинения чего-то шедеврального. Откинем песенки вторичные — Фред никогда не претендовал на основоположничество, и, в отличе от некоторых более иных авторов, на которых я не хотел бы указывать пальцем, не считал для себя западло называть своего реального учителя в ентом деле, Булат Шавловича...</p>
    <p class="Textbody">Для себя откину те песенки, которые лично меня не очень зацепили — их, по сравнению с прочими фильтрами, больше всего, почти полсотни.</p>
    <p class="Textbody">Остаётся - около ста песен. За двадцать пять лет. Мало по сравнению с раннеперестроечными сборниками типа «Шестьсот лучших песен имя река»? Да, не много. Но ведь (и это мнение не только моё, а тысяч людей с такими же биографиями) эти песни стали, как нынче принято говорить, культовыми.</p>
    <p class="Textbody">Ну, дальше на эту тему распространяться не буду, а вернусь к генеральной линии сюжета. А именно — что маски типа **/*можно использовать в аргументах команды grep и для поиска фрагментов текстов. Так, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ grep KDE **/*html</span> </p>
    <p class="Textbody">выведет все строки с упоминанием KDE в html-файлах каталога текущего и вложенных. А в форме</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ grep -i kde **/kde*.html</span> </p>
    <p class="Textbody">она произведёт аналогичный поиск только в файлах вида kde01.html, kde02.html и так далее. Причём без учёта регистра — но к мадемуазель Zsh, интересы которой я представляю в данный момент, это не имеет никакого отношения.</p>
    <h3 id="toc114"><a id="RefHeading16701713816058"></a><a id="bkmRefHeading16701713816058"></a><a id="toc113"></a><a id="bkmtoc113"></a><a id="RefHeading5141136957987"></a><a id="bkmRefHeading5141136957987"></a><a id="bkmRefHeading5141136957987"></a><a id="bkmbkmRefHeading5141136957987"></a>Перенаправление расширенное и множественное</h3>
    <p class="Textbody">Что такое перенаправление ввода/вывода — знают все применители CLI. Однако в Zsh возможности его очень широки, почему оно и называется здесь расширенным перенаправлением. Этот механизм позволяет в ряде случаев обходиться без некоторых команд вообще. Например, обычно для просмотра текстового файла применяют или команду cat, или команды-пейджеры типа more, less, most. Выбор между конкатенатором и одним из пейджеров определяется ситуацией, выбор внутри «тройки по борьбе с <span style="text-decoration:line-through">басмачами</span> файлами» зависит от привычек или предпочтений. Однако Zsh может избавить применителя от мук буриданова осла, подменяя любую из этих команд оператором перенаправления в виде команды</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ &lt; filename</span> </p>
    <p class="Textbody">Результатом чего будет постраничный вывод содержимого файла, подобный таковому любого пейджера.</p>
    <p class="Textbody">С помощью того же оператора можно просмотреть одновременно содержимое двух файлов — то есть, конечно, не одновременно, а последовательно, но в едином потоке. То есть команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ &lt; {zshenv,zshrc}</span> </p>
    <p class="Textbody">покажет оба файла как одно целое. Причём в данном случае можно поступить ещё проще, ибо маски имён файлов также не возбраняются:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ &lt; z*</span> </p>
    <p class="Textbody">Кстати, в терминах Zsh развёртывание масок имён файлов называется globbing — с ним мы уже сталкивались в рассказе о рекурсивном поиске.</p>
    <p class="Textbody">Число «оперируемых» файлов ничем не ограничено, кроме здравого смысла и целесообразности. Так, есть резон проглядеть таким образом на скорую руку, как будут выглядеть 5-6 заметок по несколько строк каждая, если их объединить в одну статью. Но просматривать с помощью оператора перенаправления книжку, состоящую из пары десятков глав по много страниц каждая, уже явный перебор.</p>
    <p class="Textbody">Однако бывают случаи, когда большое число «оперируемых» файлов очень даже уместно. Например, если требуется объединить ряд текстовых фрагментов в единый файл. И тогда, легким движением рук набрав в командной строке конструкцию</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ &lt; chapter[01-10] &gt; mybook</span> </p>
    <p class="Textbody">мы на выходе из разрозненных глав получаем готовую книгу.</p>
    <p class="Textbody">Таким образом мы перешли уже к множественному перенаправлению. Применение которого просмотром файлов не исчерпывается — их содержимое может быть перенаправлено не только на стандартный вывод, но и на ввод какой-либо команды, подменяя командный конвейер. Например, конструкция вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sort &lt; file_{1,2}</span> </p>
    <p class="Textbody">совместно отсортирует строки обоих файлов, file_1 и file_2, точно так же, как это сделал бы конвейер команд</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cat file_1 file_2 | sort</span> </p>
    <p class="Textbody">Кстати, перенаправление вполне может играть с конвейерами в одной команде. Например, конструкция вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ time commandname [options] [arguments] &gt; filename | cat</span> </p>
    <p class="Textbody">занесёт время выполнения некоей команды в файл с одновременным выводом его на экран, заменяя команду tee. Это особенно полезно при всяких «тестированиях на быстродействие», когда надо и сохранить результат для дальнейшей обработки, и не терпится посмотреть на него сразу.</p>
    <p class="Textbody">Множественное перенаправление удобно использовать для суммарного подсчёта числа символов в нескольких файлах таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ wc -m &lt;*txt</span> </p>
    <p class="Textbody">Что на выводе даст единственное число, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">5382</span> </p>
    <p class="Textbody">Казалось бы, та же команда в «обычной» форме даже короче на один символ:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ wc -m *txt</span> </p>
    <p class="Textbody">Однако вывод её будет развёрнут:</p>
    <p class="Textbody"><span style="background-color:#dddddd">2820 my_file_1.txt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> 606 my_file_2.txt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> 401 my_file_3.txt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">1555 my_file_4.txt</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">5382 итого</span> </p>
    <p class="Textbody">Что при работе во встроенных терминальных окнах текстовых редакторов вроде Geany или Kate , часто небольших по размеру может оказаться лишним. А ведь именно там приёмы, подобные описанным в этом разделе, оказываются весьма эффективными.</p>
    <p class="Textbody">В общем, уже за одну только конструкцию &lt; filename разработчики Zsh заслужили памятник, а все остальные возможности расширенного и множественного перенаправления выступают как бесплатное приложение к ней.</p>
    <h3 id="toc115"><a id="RefHeading16721713816058"></a><a id="bkmRefHeading16721713816058"></a><a id="toc114"></a><a id="bkmtoc114"></a><a id="RefHeading5161136957987"></a><a id="bkmRefHeading5161136957987"></a><a id="bkmRefHeading5161136957987"></a><a id="bkmbkmRefHeading5161136957987"></a>Просто псевдонимы и псевдонимы глобальные</h3>
    <p class="Textbody">Что такое псевдонимы, по простому aliases, — знают все, кто применяет любую командную оболочку: их поддержка существует со времён перворождённого шелла Борна. Это один из простых способов минимизировать ввод командных директив, начиная с простейшего рекурсивного копирования файлов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias cp='cp -R'</span> </p>
    <p class="Textbody">И заканчивая бессчётным количеством псевдонимов для команды ls.</p>
    <p class="Textbody">Однако в Zsh есть ещё одна фича — глобальные псевдонимы, по сей день не имеющие аналогов, насколько я знаю, во всяких там ваших башах. И даже в почти соплеменных тсишах их нет.</p>
    <p class="Textbody">Но начну по порядку. Опять же, кого не раздражала ситуация: в ответ на поиск файла find'ом или поиск фрагмента текста grep'ом выдаётся сто пятьсот экранов сообщений, что доступ к каталогу запрещён?</p>
    <p class="Textbody">Разумеется, каждый применитель Bash'а знает, как с этим бороться — достаточно присобачить к конструкции поиска посредством той или другой утилиты маленький аппендикс в виде 2&gt; /dev/null, отправляющий в небытие все сообщения об ошибках.</p>
    <p class="Textbody">Сложнее применителям Tcsh — там подавления вывода нежелательных сообщений об ошибках возможно в виде такой конструкции:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">% (command &gt; out)&gt;&amp; err</span> </p>
    <p class="Textbody">где command — команда со всеми её опциями и аргументами, out — условное имя файла, в который перенаправляется «полезный» вывод команды, а &amp; в данном контексте представляет весь остаток от оного, то есть сообщения об ошибках, которые помещаются в файл err. Имя последнего также условно, так что никто не запрещает подменить его сакраментальным /dev/null.</p>
    <p class="Textbody">Конструкция далеко не столь проста, как в sh-совместимых оболочках типа Bash. Кроме того, для просмотра «полезного» вывода она потребует ещё одной команды — вызова какого-либо пейджера вроде less:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">% (command &gt; out)&gt;&amp; err ; less out</span> </p>
    <p class="Textbody">А вот применителям Zsh — проще всех. Им достаточно задать такой глобальный псевдоним:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ alias -g N='2&gt;/dev/null'</span> </p>
    <p class="Textbody">где -g указывает, что следующий символ (или символы) являют собой на простой псевдоним, а глобальный, N — его имя, а следующая после равенства последовательность в строгих кавычках — подменяемое им выражение. После чего можно практиковать такое:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ find path3 -name [filename] N</span> </p>
    <p class="Textbody">И больше не заботиться о фильтрации зёрен от плевел.</p>
    <p class="Textbody">Глобальные псевдонимы очень полезны в командных конструкциях перенаправления по конвейеру, например, для поэкранного вывода:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ alias -g L='|less'</span> </p>
    <p class="Textbody">Пример для «пролистывания» вывода команды dmesg:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ dmesg L</span> </p>
    <p class="Textbody">Для фильтрации по вхождению «слова» можно задать такой глобальный псевдоним:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias -g G='|grep'</span> </p>
    <p class="Textbody">После чего использовать его в конструкциях, подобных такой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ dmesg G raid</span> </p>
    <p class="Textbody">что выведет нечто вроде</p>
    <p class="Textbody"><span style="background-color:#dddddd">[    1.434246] md: raid0 personality registered for level 0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">[    1.434376] md/raid0:md0: md_size is 390742016 sectors.</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">Мне весьма полезен глобальный псевдоним вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias -g W='|wc -m'</span> </p>
    <p class="Textbody">Поскольку часто требуется прибегать к такой конструкции</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ cat filename W</span> </p>
    <p class="Textbody">которая в данном случае выведет число символов в текстовом файле — для меня оно важнее числа байт (а при использовании 16-битной кодировки для преимущественно кириллического текста эти значения не совпадают).</p>
    <p class="Textbody">К именам глобальных псевдонимов применяются те же требования, что и к именам псевдонимов обычных: они должны быть по возможности короткими, мнемонически прозрачными. И, разумеется, определения всех постоянно используемых глобальных псевдонимов следует занести в свой кондуитик — то есть в ~/.zshrc.</p>
    <p class="Textbody">Разумеется, здесь не описаны все возможные случаи употребления глобальных псевдонимов — они лимитируются только потребностями применителя и его фантазией. И, конечно, наказом, который дал атаман Платов небезызвестному Левше:</p>
    <p class="Textbody">Не пей мало, не пей много, а пей средственно.</p>
    <p class="Textbody">То есть — не придумывайте глобальных псевдонимов больше, чем сможете запомнить.</p>
    <h3 id="toc116"><a id="RefHeading16741713816058"></a><a id="bkmRefHeading16741713816058"></a><a id="toc115"></a><a id="bkmtoc115"></a><a id="RefHeading5181136957987"></a><a id="bkmRefHeading5181136957987"></a><a id="bkmRefHeading5181136957987"></a><a id="bkmbkmRefHeading5181136957987"></a>Псевдонимы-суффиксы</h3>
    <p class="Textbody">Кроме обычных и глобальных псевдонимов, в Zsh существует ещё одна их разновидность — псевдонимы «суффиксные», более удачного определения на языке родных осин я не придумал, псевдонимы.</p>
    <p class="Textbody">Подобно тому, как добаление к команде alias опции -g с помощью магии превращает обычный псевдоним в глобальный, так и опция -s делает обычный псевдоним «суффиксным». То есть привязывает суффикс имени файла (те, кто, подобно автору этих строк, затронуты порчей чёрным DOS'ом, до сих пор часто называют его «расширением») к некоей программе, которая может сотворить над ним нужное действо. Например, если задать псевдоним такого вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ alias -s html=links</span> </p>
    <p class="Textbody">а затем набрать в CLI такое</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ path3/некто.html</span> </p>
    <p class="Textbody">то этот самый некто.html будет открыт в текстовом браузере Links.</p>
    <p class="Textbody">Чем, разумеется, возможности «суффиксных» псевдонимов не исчерпываются — как всегда, предел им ставит только фантазия применителя применительно к его задачам. Ограничусь одним примером.</p>
    <p class="Textbody">Какой же русский не любит Командера-полуночника? В том числе и потому, что он — один из сыновей прославленного командера Нортона, имя которого, в свою очередь, не более чем alias незабвенного лейтенанта Шмидта (история его чудесного спасения из лап царской охранки и последующей блестящей карьере сначала в ВМС Пендостана, а затем в интернациональном софтверном бузиненсе реконструирована <a href="http://alv.me/?p=290#1">нашими замечательными историками</a> из славного Екатеринбурга). Впрочем, со временем наш русский применитель, не смотря на весь свой патриотизм, начинает понимать, что слепая любовь к MC связывает ему руки в операциях с возлюбленной CLI, и хорошо бы с командиром расстаться, как это делают цивилизованные люди — без скандалов и истерик.</p>
    <p class="Textbody">Но тут возникает проблема: MC — один из самых удобных способов просмотра того, из чего состоят файлы пакетов (будь то deb, rpm или что ещё из tar.*z-серии). Так вот, механизм «суффиксных» псевдонимов Zsh предлагает нам адекватную замену: если дать команду, например,</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ alias -s deb='dpkg -c'</span> </p>
    <p class="Textbody">а затем набрать в командной строке такое:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ path3/opera-beta_25.0.1614.11_amd64.deb</span> </p>
    <p class="Textbody">то мы сразу увидим, что же припасли для нас разработчики этого многими любимого браузера в своём полуподпольном пре-релизе за нумером 25 (впрочем, за время сочинения этой книги он стал вполне официальным, приобретя номер версии 27):</p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x root/root         0 2014-09-13 03:54 ./</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x root/root         0 2014-09-13 03:54 ./usr/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x root/root         0 2014-09-13 03:54 ./usr/bin/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x root/root         0 2014-09-13 03:54 ./usr/lib/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">drwxr-xr-x root/root         0 2014-09-13 03:54 ./usr/lib/x86_64-linux-gnu/</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">Понятное дело, что аналогичные псевдонимы можно придумать и для всяких rpm-и tgz-пакетов. И, разумеется, наиболее востребованные из них занести в кондуит... то есть в ~/.zshrc.</p>
    <h3 id="toc117"><a id="RefHeading16761713816058"></a><a id="bkmRefHeading16761713816058"></a><a id="toc116"></a><a id="bkmtoc116"></a><a id="RefHeading5201136957987"></a><a id="bkmRefHeading5201136957987"></a><a id="bkmRefHeading5201136957987"></a><a id="bkmbkmRefHeading5201136957987"></a>Конфигурирование</h3>
    <p class="Textbody">В качестве обобщения всего сказанного выше в заключение этого очерка я размещаю свой конфигурационный файл ~/.zshrc, прокомментированный, по мере сил, подробно. Этот конфиг существует с 2001 года, кочуя с машина на машину, из системы в систему, постоянно модернизируюсь в соответствие с изменениями моих потребностей и возможностей Zsh. И в текущем состоянии он обеспечивает все функции и особенности, о которых я говорил ранее, и некоторые другие, которые станут понятными после знакомства с Mint-утилитой пакетного менеджмента apt.</p>
    <p class="Textbody">Данный конфиг может быть использован полностью или фрагментарно всеми заинтересованными лицами: блоки, заключённые в теги &lt;pre&gt;&lt;/pre&gt;, пригодны для прямого копирования, за одним исключением, о котором будет сказано в своё время. Однако я отнюдь не призываю к этому, напротив: настоятельно рекомендую, используя данный конфиг и аналогичные, которые можно найти в Сети, по мере сил и возможности создавать конфиг собственный. Ибо хороший (для конкретного применителя) ~/.zshrc — это не результат, а процесс, и причём процесс преувлекательный.</p>
    <p class="Textbody">Как и большинство уважающих себя конфигов, мой начинается с секции, закрытой комментариями, в которой сообщается, что:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">это ~/.zshrc — то есть «домашний» конфигурационный файл для командной оболочки Zsh; </p>
      </li>
      <li>
        <p class="Textbody">используется только в интерактивных её экземплярах; </p>
      </li>
      <li>
        <p class="Textbody">содержит крманды для определения псевдонимов, функций, опций и прочих кейбиндингов; </p>
      </li>
      <li>
        <p class="Textbody">укладывается в последовательность считывания конфигов таким образом: zshenv, zprofile, zshrc, zlogin. </p>
      </li>
    </ul>
    <p class="Textbody">Всё это <span style="text-decoration:line-through">потибрено</span> унаследовано от прототипа, распространяющегося разрабочиками Zsh. От себя я добавил лишь такую строку:</p>
    <p class="Textbody"><span style="background-color:#dddddd">#</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"># Alv's edition for Mint</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#</span> </p>
    <p class="Textbody">Это не значит, что данный конфиг нельзя использовать вне Mint: подавляющая часть его строк будет иметь силу в любых дистрибутивах Linux'а или в BSD-системах. Но отдельные его блоки (специально оговоренные) в них просто не будут иметь смысла.</p>
    <p class="Textbody">Далее начинается собственно строки определения конфигурируемых параметров. Для удобства восприятия (по крайней мере, моего собственного) они разделены на блоки «целевого назначения». Последовательность блоков, как и строк внутри них, в большинстве случаев рояля не играет, отдельные исключения также оговорены специально.</p>
    <p class="Textbody">Поскольку всё имеет своё начало, начать свой конфиг мне показалось логичным с блока строк, имеющих отношение к истории команд. Перво-наперво — определение числа команд, сохраняемых в буфере во время данного сеанса, имени файла истории, и числа сохраняемых в нём команд:</p>
    <p class="Textbody"><span style="background-color:#dddddd">HISTSIZE=2000</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">HISTFILE=~/.zhistfile</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">SAVEHIST=10000</span> </p>
    <p class="Textbody">Обычно для HISTSIZE и SAVEHIST рекомендуют принимать одинаковые значения (по умолчанию при автоматическом конфигурировании они равны 1000). Однако если действительно трудно представить ввод более чем тысячи команд в течении сеанса, то вот за весь цикл жизнедеятельности оболочки в системе превысить этот лимит достаточно просто.</p>
    <p class="Textbody">Кроме того, надо учесть, что в обоих случаях сохраняются не просто команды, а целые директивы с опциями и аргументами, перенаправлениями и конвейерами, подчас достаточно сложными и редко используемыми. В Zsh имеются очень эффективные механизмы извлечения командных строк из сохранённой истории — не только по именам команд, но и по их опциям и аргументам. Обычно этим мало кто заморчивается, однако в некоторых, пусть и не частых, случаях такие командные конструкции могут потребоваться вторично. И тогда приятно сознавать, что они храняться в файле истории, откуда вытащить их всё равно проще, чем пытаться воспроизвести по памяти или отыскивать аналоги в сети.</p>
    <p class="Textbody">Так что со временем я, увеличив на всякий пожарный случай HISTSIZE вдвое, отвёл под SAVEHIST 10000 строк. Кстати, когда предупреждают о том, что увеличение обоих значений может привести к торможению, следует учитывать, что в памяти постоянно находится только содержимое HISTSIZE, тогда как из SAVEHIST оно извлекается по мере необходимости. Не говоря уже о том, что при типичных для современных машин объёмах памяти об этом просто смешно говорить.</p>
    <p class="Textbody">Имя файла истории я тоже изменяю на ~/.zhistfile. Во-первых потому, что иногда по старой памяти балуюсь Tsch, а в ней файл истории по умолчанию также именуется ~/.histfile (собственно, оттуда он в Zsh и был потибрен, в хорошем смысле этого слова). А во-вторых, просто для удобства восприятия — чтобы все имеющие отношение к Zsh файлы в домашнем каталоге были рядом.</p>
    <p class="Textbody">Однако продолжим наши «исторические» опции. Следующие строки задают условия сохранения команд в файле истории:</p>
    <p class="Textbody"><span style="background-color:#dddddd">setopt  INC_APPEND_HISTORY</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">setopt  HIST_IGNORE_ALL_DUPS</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">setopt  HIST_REDUCE_BLANKS</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">setopt  HIST_IGNORE_SPACE</span> </p>
    <p class="Textbody">Они определяют, соответственно:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">инкрементное наращивание файла истории — без указания этой опции (или одной из однотипных) его прежние команды будут заменены командами текущего сеанса; </p>
      </li>
      <li>
        <p class="Textbody">удаление предыдущих полных дубликатов нововведённых командных конструкций; </p>
      </li>
      <li>
        <p class="Textbody">избавление от пустых строк, возникающих после ошибочного нажатия Enter в «голом» приглашении; </p>
      </li>
      <li>
        <p class="Textbody">удаление лишних пробелов из командной конструкции. </p>
      </li>
    </ol>
    <p class="Textbody">Зачем нужны пункты 2–4 — ясно без комментариев. А вот о пункте 1-м надо сказать несколько слов. Ибо он не просто обеспечивает наращивание файла истории (для этого было бы достаточно опции, APPEND_HISTORY), но делает это в ходе сеанса, не дожидаясь его завершения. В результате команда, введённая в одном терминальном окне или вкладе терминала, будет доступна в истории команд другого терминала или вкладки (хотя и с некоторой задежкой).</p>
    <p class="Textbody">Далее следуют две очень важные строки, определяющие одну из полезнейших возможностей Zsh — тот самый механизм history-substring-search, о котором говорилось ранее:</p>
    <p class="Textbody"><span style="background-color:#dddddd">bindkey "^[[A" up-line-or-search</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">bindkey "^[[B" down-line-or-search</span> </p>
    <p class="Textbody">Следующие две строки касаются уже простого пролистывания истории в командной строке, позволяя делать это клавишами PageUp и PageDown (а не только стрелками Up и Down, которые в этом качестве работают всегда и везде):</p>
    <p class="Textbody"><span style="background-color:#dddddd">bindkey "^[[5~" up-line-or-history</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">bindkey "^[[6~" down-line-or-history</span> </p>
    <p class="Textbody">Этими строками перебрасывается логический мостик к определению кейбиндингов для клавиш, которые в Zsh по умолчанию работают «неправильно» в большинстве терминалов (если не во всех). У меня это Home, End, Delete — их поведение исправляется такими, соответственно, строками:</p>
    <p class="Textbody"><span style="background-color:#dddddd">bindkey "^[OH" beginning-of-line</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">bindkey "^[OF" end-of-line</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">bindkey "^[[3~" delete-char</span> </p>
    <p class="Textbody">Это как раз пример тех строк, которые as is копировать не нужно. Во-первых, в общем случае, могут не работать другие клавиши (скорее, не только эти). Во-вторых же и главных, в более иных терминалах коды тех же клавиш могут быть совсем другими. Какими — легко определить, нажав Control+V, а затем «неправильную» клавишу. Именно таким образом получены коды для Home, End и Delete в системе, в которой сочиняются эти строки.</p>
    <p class="Textbody">Теперь — опции, определяющие магию Zsh при навигации по файловой системе:</p>
    <p class="Textbody"><span style="background-color:#dddddd">cdpath=(/home/current /home/current/alv.me /etc)</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">setopt autocd</span> </p>
    <p class="Textbody">Первая строка позволяет с помощью команды cd переходить в подкаталоги перечисленных каталогов, не набирая никаких путей, ни относительных, ни абсолютных, вторая же — обходиться без команды cd.</p>
    <p class="Textbody">На грани между опциями навигации и автодополнения находятся такие строки:</p>
    <p class="Textbody"><span style="background-color:#dddddd">setopt menucomplete</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zstyle ':completion:*' menu select=1 _complete _ignored _approximate</span> </p>
    <p class="Textbody">Они в паре обеспечивают «менюобразный» вывод списка доступных дополнений по нажатию клавиши табуляции. И это как раз тот случай, когда последовательность строк имеет значение.</p>
    <p class="Textbody">Аналогично и со следующими строками — теми самыми, которые обеспечивают волшебство развёртывания <a href="http://alv.me/?p=6745">сокращённого ввода пути в полный</a>:</p>
    <p class="Textbody"><span style="background-color:#dddddd">autoload -Uz compinit</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">compinit</span> </p>
    <p class="Textbody">Расширенные подстановки и дополнения обеспечиваются вот этими строками:</p>
    <p class="Textbody"><span style="background-color:#dddddd">setopt extendedglob nomatch notify</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zstyle ':completion:*' completer _expand _complete _ignored _correct _approximate</span> </p>
    <p class="Textbody">Строка</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zstyle ':completion:*' use-compctl false</span> </p>
    <p class="Textbody">знаменует собой отречение от старого мира — системы дополнения compctl, в пользу новой системы compsys.</p>
    <p class="Textbody">Строка</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'</span> </p>
    <p class="Textbody">устанавливает равноправие при дополнениях символов нижнего регистра с верхним.</p>
    <p class="Textbody">А строка</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">zstyle :compinstall filename '/home/zsh/.zshrc'</span> </p>
    <p class="Textbody">фиксирует файл, в который compinstall (функция автоматического конфигурирования compsys) будет вносить свои изменения при грядущих её вызовах (если они, конечно, будут).</p>
    <p class="Textbody">Пора переходить к псевдонимам. Сначала — серия таковых для команд манипуляции файлами, предписывающие запрос подтверждения на таковые или, напротив, форсированное исполнение, в зависимости от ситуации:</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias mv='mv -i'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias cp='cp -iR'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias cpr='cp -fR'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias rm='rm -i'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias rmf='rm -f'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias rmrf='rm -fR'</span> </p>
    <p class="Textbody">Оказывается, что для одной-единственной команды ls можно придумать больше псевдонимов, чем для всех файломанипулирующих команд, вместе взятых:</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias ls='ls -F'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias ll='ls -lh'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias la='ls -A'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias li='ls -ial'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias lsd='ls -ld *(-/DN)'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias lsa='ls -ld .*'</span> </p>
    <p class="Textbody">На самом деле их можно придумывать ещё и ещё — этот тот необходимый минимум, который я в состоянии запомнить без вреда для рассудка. Расшифровывать псевдонимы не буду — кому надо, и так могут сорвать с них маски, а кто не знает — так ему это и не нужно.</p>
    <p class="Textbody">Далее идёт серия псевдонимов для различных команд и утилит разного назначения. Здесь также расшифровка будет лишней. Ибо они или оболее-менее общеприняты:</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias h=history</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias df='df -h'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias du='du -h'</span> </p>
    <p class="Textbody">Либо обусловлены давними привычками (как, например, more-образный вывод команды less):</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias less='less -M'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias wget='wget -c'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias nano='nano -$'</span> </p>
    <p class="Textbody">Либо связаны со спецификой деятельности:</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias wcl='wc -l'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias wcw='wc -w'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias wcm='wc -m'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias wcc='wc -c'</span> </p>
    <p class="Textbody">Так что можно переходить к следующей убойной фиче Zsh — определению глобальных псевдонимов:</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias -g N='2&gt;/dev/null'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias -g L='|less'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias -g G='|grep'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias -g W='|wc -m'</span> </p>
    <p class="Textbody">Где, впрочем, комментарии тоже излишни.</p>
    <p class="Textbody">А посему перехожу к тем самым дистрибутив-специфическим блокам, которые я предназначил для применения в Mint. Это — псевдонимы для субкоманд её утилиты apt, призванные минимизировать ввод при наиболее частых действиях по пакетному менеджменту:</p>
    <p class="Textbody"><span style="background-color:#dddddd">alias aptin='apt install --yes'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias apter='apt purge'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias aptup='apt update'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias aptug='apt upgrade'</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">alias aptse='apt search'</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias aptsh='apt show'</span> </p>
    <p class="Textbody">Псевдонимы для внутренних команд apt из APT также имеет смысл определить, по крайней мере один, для получения списка инсталлированных пакетов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias aptlist='/usr/bin/apt list --installed'</span> </p>
    <p class="Textbody">Смысл этих псевдонимов будет ясен после знакомства с очерком об утилите apt. И в них нет ничего Zsh-специфичного. В отличие от альтернативного метода, основанного на псевдонимах глобальных, которые определяются для соответствующих аргументов команды sudo. Правда, особенность реализации утилиты apt в Mint такова, что она не требует ввода этой команды в явном виде. И потому здесь у меня осталась единственная строка для псевдонима команды добавления репозиториев:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">alias -g Ar='add-apt-repository'</span> </p>
    <p class="Textbody">Хотя я и утверждал не так давно, что приглашение оболочки — нечто вроде вешалки для театра, сам добрался до этой темы только к концу своего конфига. Однако вот — обычное левосторонне приглашение:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#PROMPT='%B[%n]$=&gt;%b '</span> </p>
    <p class="Textbody">Вторичное приглашение:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#PROMPT2='%i%U&gt; '</span> </p>
    <p class="Textbody">Правостороннее приглашение:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#RPROMPT=' %B[%~]%b '</span> </p>
    <p class="Textbody">А вот это — альтернативы, которыми я баловался во время сочинения раздела про приглашения. Все они начинаются с такой пары строк:</p>
    <p class="Textbody"><span style="background-color:#dddddd">autoload -Uz promptinit</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">promptinit</span> </p>
    <p class="Textbody">После которых вызывается уже одна из конкретных тем:</p>
    <p class="Textbody"><span style="background-color:#dddddd">#prompt fade</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">prompt fade white grey blue</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">#prompt clint</span> </p>
    <p class="Textbody">Естественно, что остальные строки должны быть закомментированы.</p>
    <p class="Textbody">Осталось немного — всякая всячина. Например, предотвращение выхода из оболочки после случайного нажатия Control+D в пустой командной строке:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">setopt IGNORE_EOF</span> </p>
    <p class="Textbody">Отключение раздражающего звукового сигнала при ошибках набора:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">setopt NO_BEEP</span> </p>
    <p class="Textbody">Фиксация emacs-образного поведения клавиш (хотя это и так имеет место быть по умолчанию):</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">bindkey -e</span> </p>
    <p class="Textbody">И под занавес — определение пары переменных среды, для начала умолчального пейджера. Хотя я не так давно говорил, что расширенное перенаправление делает его практически не нужным, но, кроме всего прочего, это ещё и средство для просмотра man-страниц:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">export PAGER="less"</span> </p>
    <p class="Textbody">И умолчальный редактор: не смотря на свою любовь к Joe, навыки работы с ним я утратил напрочь, поэтому так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">export EDITOR="nano"</span> </p>
    <p class="Textbody">Вот вроде и всё. Остаётся последний дистрибутив-специфичный стришок — исправление нехорошего поведения history-substring-search в Mint, унаследованного от Ubuntu. А точнее, поведения никакого — эта фича без дополнительных мер просто не работает. Благо меры эти очень просты — создание файла ~/.zshenv с единственной строкой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">DEBIAN_PREVENT_KEYBOARD_CHANGES=yes</span> </p>
    <p class="Textbody">Вот теперь действительно всё — с конфигурированием Zsh «мануальным» способом покончено.</p>
    <h2 id="toc118"><a id="RefHeading16781713816058"></a><a id="bkmRefHeading16781713816058"></a><a id="toc117"></a><a id="bkmtoc117"></a><a id="RefHeading12681136957987"></a><a id="bkmRefHeading12681136957987"></a><a id="bkmRefHeading12681136957987"></a><a id="bkmbkmRefHeading12681136957987"></a>Пакеты и репозитории</h2>
    <p class="Textbody">Все дистрибутивы Linux, и Mint тут не исключение, организованы по пакетному принципу. Точно также, в виде пакетов, распространяются и любые дополнительные программы для них, создаваемые независимыми разработчиками. И потому одна из важных задач пользователя — это интеграция пакетов в свою систему. Она решается средствам управления пакетами, предназначенным для установки, обновления и удаления программ, учета и разрешения их зависимостей. Однако, прежде чем говорить о таких средствах, не худо посмотреть, что такое пакеты вообще, deb-пакеты в частности и пакеты дистрибутива Mint в особенности. А также — каким образом они организованы в репозитории.</p>
    <h3 id="toc119"><a id="RefHeading16801713816058"></a><a id="bkmRefHeading16801713816058"></a><a id="toc118"></a><a id="bkmtoc118"></a><a id="RefHeading5221136957987"></a><a id="bkmRefHeading5221136957987"></a><a id="bkmRefHeading5221136957987"></a><a id="bkmbkmRefHeading5221136957987"></a>Пакеты, зависимости, библиотеки</h3>
    <p class="Textbody">Пакеты — это своего рода программные кванты, на которые делится система или дистрибутив. Это могут быть и простые монофункциональные утилиты (например, строчный текстовый редактор ed или архиватор tar), более или менее обширные наборы функционально связанных программ (скажем, coreutils) или составные части огромных программных комплексов (примером чему — Cinnamon, о котором столько гворилось в прошлых очерках).</p>
    <p class="Textbody">Термин пакет (английское package) употребляется в двух смыслах: как авторский набор исходных текстов, созданный разработчиком программы, и как комплект скомпилированных из него исполняемых программ и всех их служебных файлов, собранный майнтайнерами дистрибутива или вообще третьими лицами. Пакеты в первом смысле называются исходниками или вообще «сырцами» (от английского Source), во втором — бинарниками. Далее в этой книге речь пойдёт почти исключительно о пакетах во втором понимании этого термина.</p>
    <p class="Textbody">Бинарные пакеты специфичны для семейств некогда родственных дистрибутивов, почему часто говорят о системах rpm based или deb based. Но даже если они собраны в одном формате (например, rpm или deb), бинарные пакеты из разных дистрибутивов далеко не всегда совместимы в рамках одной системы. Впрочем, к формату deb, принятому в дистрибутиве Mint и потому в интересующему нас больше всех остальных, вместе взятых, это относится в наименьшей степени: его пакеты сохраняют почти полную бинарную совместимость с пакетами родительской Ubuntu и частичную — с пакетами прародительского Debian'а.</p>
    <p class="Textbody">Ключевым для бинарных, или дистрибутивных, пакетов является понятие зависимостей. Суть его в том, что пакет packagename1 для сборки, установки и (или) функционирования требует наличия в системе пакета packagename2, тот, в свою очередь, может потребовать пакета packagename3, и так далее.</p>
    <p class="Textbody">Следует различать зависимости жёсткие и «мягкие». Удовлетворение первых абсолютно необходимо для сборки и функционирования данного пакета. Так, практически любая программа использует главную системную библиотеку glibc (или libc), любое приложение для системы X — одну из главных Иксовых библиотек: старые — xlib, новые — xcb, любая интегрированная рабочая среда — одно из двух основных семейств высокоуровневых библиотек, Qt/kdelibs или Gtk.</p>
    <p class="Textbody">«Мягкие» зависимости данного пакета не критичны для его функционирования — удовлетворение их лишь добавляет ему дополнительные функции (например, печати и сканирования для офисных и графических приложений) или возможности (скажем, доступ к файлам данных определённых форматов для той же графики или мультимедиа).</p>
    <p class="Textbody">В deb-формате бинарных пакетов предусмотрено более дробное разделение «мягких» зависимостей, но об этом подробнее будет говориться чуть позже. А пока замечу, что часто приходится учитывать и так называемые конфликтующие зависимости — то есть альтернативные по назначению пакеты, не способные ужиться в одной системе.</p>
    <p class="Textbody">Понятие зависимостей пронизывает насквозь UNIX-совместимые системы, и особенно важно для свободных их представителей. В то же время пользователи Windows с ним сталкиваются очень редко, и потому постижение его вызывает у них определённые трудности.</p>
    <p class="Textbody">Традиционная модель разработки UNIX-программ (то, что задумчиво именуют UNIX Way) характеризуется ярко выраженным стремлением не множить сущности без крайней необходимости. Или, говоря попросту, не изобретать велосипеды. То есть: если требуемая разработчику данной программы функция уже реализована и включена в какую-либо распространённую библиотеку, то наш разработчик скорее всего этой библиотекой и воспользуется, а не будет переписывать ее с нуля. Благо, поскольку все распространённые и общеупотребимые библиотеки открыты, он имеет полную возможность это сделать.</p>
    <p class="Textbody">Ведь все программы, вне зависимости от их назначения, неизбежно должны выполнять некоторые однотипные действия, как то: открыть файл, записать его, вывести на экран его содержимое, и так далее, вплоть до закрытия. Сущность таких действий не меняется, что бы программа ни делала. И потому нет никакого смысла программировать такие манипуляции каждый раз заново.</p>
    <p class="Textbody">Вот их, как правило, поддаваясь смертному греху лености, и не программируют «с нуля». А объединяют соответствующие директивы в отдельные программные комплексы, именуемые библиотеками (libraries). Сами по себе они к автономному исполнению не пригодны. Однако любая программа, при необходимости совершить одно из типовых действий, вызывает из такой библиотеки некий фрагмент кода, содержащий требуемую последовательность директив.</p>
    <p class="Textbody">Библиотеки обычно привязаны к определённым языкам программирования, синтаксису которого подчиняются описания директив, так называемых функции. Поскольку наиболее употребимым в UNIX-системах и их приложениях является язык C, то его функции и требуются чаще всего. Они собираются в главную системную библиотеку, которая почти во всех дистрибутивах Linux именуется glibc.</p>
    <p class="Textbody">Однако главной системной библиотекой список не исчерпывается. В UNIX-подобных системах при создании пользовательских интерфейсов используются библиотеки свойств терминала (например, ncurces) для консольных программ и библиотеки, описывающие процедуры отрисовки окон и управления ими — для графических программ системы X, библиотеки интерфейсных элементов и графических примитивов более высокого уровня (Motif, Qt, Gtk), библиотеки описания графических и мультимедийных форматов файлов и тому подобные «сборники». Иными словами, существует тенденция к вынесению в разделяемые библиотеки всех повторяющихся действий и элементов, какие только возможно.</p>
    <p class="Textbody">Если библиотек, используемых в программах для консольного режима, не так много, они достаточно универсальны и легко поддаются учёту, то с библиотеками для обеспечения графического режима существенно сложнее. Даже простое перечисление их заняло бы немало места. Поэтому ограничусь констатацией факта, существенного для нашей темы. Обе основные рабочие среды дистрибутива Mint, MATE и Cinnamon, а также штатные приложения обеих редакций базируются на библиотеках Gtk — 2-й и 3-й версий, соответственно. К ним же примыкает и «левая» редакция с Xfce. И лишь KDE-редакция Mint основывается на библиотеках Qt и kdelibs. Поскольку основной героиней этого романа является Cinnamon, то дальше речь пойдёт в основном о пакетах, связанных зависимостями с библиотекой Gtk 3.</p>
    <h2 id="toc120"><a id="RefHeading16821713816058"></a><a id="bkmRefHeading16821713816058"></a><a id="toc119"></a><a id="bkmtoc119"></a><a id="RefHeading12701136957987"></a><a id="bkmRefHeading12701136957987"></a><a id="bkmRefHeading12701136957987"></a><a id="bkmbkmRefHeading12701136957987"></a>Формат пакетов</h2>
    <p class="Textbody">Как уже было сказано, в дистрибутиве Mint принят deb-формат пакетов. Будучи разработан ещё в прошлом тысячелетии для дистрибутива Debian, формат этот был унаследован от него Ubuntu, во многом предопределив успех последней. А вслед за ней — и удачливость нашего главного героя. Почему deb-формату и следует уделить некоторое внимание.</p>
    <p class="Textbody">Пакет deb-формата — архивный файл (собранный утилитой ar, о которой недавно шла речь), включающий три компонента. Первый — это файлик debian-binary, не содержащий ничего, кроме номера версии deb-формата (в данный момент — 2.0).</p>
    <p class="Textbody">Второй файл носит имя data.tar.xz и, как легко догадаться, представляет собой tar-архив, сжатый утилитой xz. Содержимое архива — скомпилированные исполняемые бинарники и необходимые им для работы компоненты (библиотеки, конфиги, документация и так далее). Иными словами, все компоненты, которые при установке пакета будут инкорпорированы в файловую иерархию целевой системы. Например, для пакета cinnamon_2.4.1+rebecca_amd64.deb в этом архиве обнаруживается каталог /usr с подкаталогами /usr/bin, /usr/lib, /usr/share, содержащими исполняемые бинарники, библиотеки и разделяемые компоененты, соответственно.</p>
    <p class="Textbody">Третий файл именуется control.tar.gz и представляет собой архив файлов, содержащих всякого рода метаинформацию — описание пакета, его зависимости, классификационную принадлежность, приоритет и так далее (файл control), контрольные суммы всех исполняемых бинаников (файл md5sums), сценарии, выполняемые при установке и удалении пакета (preinst, postinst, prerm и postrm).</p>
    <p class="Textbody">Зависимости в терминах deb-пакетов имеют несколько градаций: обязательные (depends), рекомендуемые (recommends), предлагаемые (suggests), конфликтующие (conflicts). Первая градация — это обычные «жёсткие» зависимости, без удовлетворения которых пакет либо не будет работать, либо вообще не установится. С градацией последней тоже понятно — это, так сказать, анти-зависимости: например, Opera текущей, 26-й, версии конфликтует с пакетом opera-12.16.</p>
    <p class="Textbody">Ну а зависимости рекомендуемые и предлагаемые — это две разновидности «мягких» зависимостей. Разница между ними в том, что рекомендуемые пакеты обеспечивают «зависимому» пакету дополнительные функции (например, поддержку мыши в консольных приложениях), а пакеты предлагаемые предоставляют дополнительные возможности, вполне вероятно, полезные, но не жизненно необходимые (например, документацию, в том числе на не-английских языках). То есть первая категория как бы более нужная, нежели вторая. Впрочем, таково субъективное мнение майнтайнера конкретного пакета — вполне возможно, что у применителя будет своё мнение по этому поводу. И потому и пакетный менеджер apt, и его графическая «морда» Synaptic, устанавливающие зависимости автоматически, в Mint по умолчанию не делают этого ни для рекомендуемых, ни, тем более, для предлагаемых пакетов, а лишь выводят их список, дабы применитель сам принял решение по данному вопросу.</p>
    <p class="Textbody">Кроме того, спецификой deb-пакетов является ещё и существование так называех пред-зависимостей (pre-depends) — при их нарушении установка пакета даже не может начаться, ибо их наличия требует пре-инсталляционный сценарий «зависящего» пакета. Впрочем, с точки зрения пользователя они немногим отличаются от обычных зависимостей типа depends.</p>
    <p class="Textbody">Кроме зависимостей, для пакетов deb-формата важно также понятие их приоритета. Оно отражает степень необходимости пакета для функционирования системы, например: обязательный (required), без которого работа системы невозможна, основной (base) и важный (important), также оказывающиеся практически необходимыми, стандартный, то есть имеющийся практически в любой полнофункциональной Linux-системе, дополнительный (optional) — тут уж степень важности каждый должен решать для себя.</p>
    <p class="Textbody">Как это принято в мире Open Source, все бинарные пакеты Mint (а также, конечно, Ubuntu и сородичей) сопровождаются исходными текстами, доступными из соответствующего репозитория дистрибутива. И здесь deb-формат проявляет свою специфику: каждый пакет в исходниках обычно включает три файла — packagename.orig.tar.gz, packagename.dsc и packagename.diff.gz.</p>
    <p class="Textbody">Первый — самый обычный тарбалл исходных текстов авторского пакета, что подчеркивается словом orig в его имени: формат архива, имя и система нумерации версий также совпадают с таковыми авторского пакета. Файл packagename.dsc содержит в себе всю метаинформацию, необходимую для правильного построения из него бинарного deb-пакета. А packagename.diff.gz — это те изменения исходного кода, которые вносятся для адаптации пакета непосредственно к данному дистрибутиву. Если таких изменений не потребовалось (или если пакет писался именно для Ubuntu или Mint), он может и отсутствовать.</p>
    <h2 id="toc121"><a id="RefHeading16841713816058"></a><a id="bkmRefHeading16841713816058"></a><a id="toc120"></a><a id="bkmtoc120"></a><a id="RefHeading12721136957987"></a><a id="bkmRefHeading12721136957987"></a><a id="bkmRefHeading12721136957987"></a><a id="bkmbkmRefHeading12721136957987"></a>Репозитории: введение</h2>
    <p class="Textbody">Пакеты, входящие в дистрибутив (или, если угодно, образующие дистрибутив), валяются не абы как — они организованы в репозитории. Что это такое?</p>
    <p class="Textbody">В переводе на русский язык слово репозиторий означает хранилище — и именно его рекомендуют употреблять языковые пуристы (они же те, кто предпочитает называть себя grammar nazi). Однако, как это обычно бывает по жизни, в народе утвердилось иное их именование — repo или, говоря по нашему, по <span style="text-decoration:line-through">бразильскому</span> кириллическому, репы. Почему во множественном числе — станет понятно из дальнейшего рассказа.</p>
    <p class="Textbody">Сам по себе репозиторий действительно можно в первом приближении определить как место хранения пакетов, специально собранных для данного дистрибутива, к которому возможен свободный (мы ведь ведём речь только о свободных системах) доступ.</p>
    <p class="Textbody">Однако доступности сервера, хранящего пакеты, недостаточно, чтобы носить звание репозитория. Пакеты в репозитории должны быть структурированы по определённым, присущим данному дистрибутиву, принципам. Система хранения пакетов должна обеспечивать их пополнение, обновление, а главное — поддержку целостности и непротиворечивости пакетов в отношении зависимостей, причём для всех поддерживаемых на текущий момент версий дистрибутива.</p>
    <p class="Textbody">Иными словами, пакеты в репозитории должны сопровождаться базами данных — теми самыми, которые используются системой управления пакетами данного дистрибутива.</p>
    <p class="Textbody">Кроме того, весьма желательно, чтобы репозиторий зеркалировался на нескольких независимых серверах — по вполне понятным причинам. Правда, это не является непременным требованием. Тем не менее, наличие зеркал — одно из оснований для употребления слова репозитории во множественном числе.</p>
    <p class="Textbody">В последние годы получила распространение точка зрения, что право на гордое имя настоящего дистрибутива даёт только собственный репозиторий пакетов, при его отсутствии ты в лучшем случае ремикс дрожащая, а то и вообще жалкий респин. Причём дистрибутив, претендующий на всенародную любовь, обязан иметь репозиторий тем более всеобъёмлющий, чем шире его претензии.</p>
    <p class="Textbody">Автор этих строк и сам активно поддерживает озвученный взгляд. Однако Mint, казалось бы, служит живым его опровержением. Ибо в базовой своей части, начиная с ядра и заканчивая Xorg, он не просто основывается на репозиториях Ubuntu, подобно тому, как последняя основывается на репозиториях Debian ветки testing. Нет, Mint просто напрямую использует соответствующие пакеты из официального репозитория Ubuntu, без всяких модификаций, патчей, пересборок и тому подобных архитектурных излишеств. Нет, Mint, конечно, имеет и собственный репозиторий, но он выглядит песчинкой по сравнению с глыбой репозиториев прародительской системы.</p>
    <p class="Textbody">И, тем не менее в звании дистрибутива Mint никто и никогда даже не пытался отказывать. Почему? Да потому, что репозиторий его, что называется, мад, да удал: в нём поддерживаются пакеты, определяющие своеобразие дистрибутива, такие, как «фирменные» утилиты, рабочие среды Cinnamon и MATE. Причём если для MATE репозиторий Mint является как бы вторичным по отношению к «головному» репозиторию <a href="http://pub.mate-desktop.org/releases/" target="_blank">проекта mate-desktop.org</a>, то <a href="https://github.com/linuxmint/" target="_blank">соответствующий репозиторий Cinnamon</a> выступает самым что ни на есть «головным» для этой среды и всех связанных с ней пакетов (вроде файлового менеджера Nemo). И, само собой, таковым он является и для всех дистрибутив-специфичных пакетов — дисплейного менеджера MDM и комплекса Mint-утилит. Ну а что разработчики Mint не занимаются пересборкой базовых пакетов из репозиториев Ubuntu — вполне понятно: зачем изобретать велосипед, когда имеющийся вполне пригоден для езды. Это позволяет сконцентрировать силы на развитии «генеральной линии» собственной системы.</p>
    <p class="Textbody">Пояснение: под «головным» репозиторием я понимаю то, что на вражьей мове называется upstream: они поддерживаются основной командой данного пакета или комплекса пакетов, в них хранятся исходники их текущих и разрабатываемых версий, туда же вливаются (или, по крайней мере, должны вливаться) патчи от независимых разработчиков. И на них основываются сборки бинарных пакетов для всех дистрибутивов, испытывающих необходимость в оных.</p>
    <p class="Textbody">В ближайших разделах будет последовательно рассмотрено устройство базового репозитория Ubuntu, а затем собственного репозитория Mint. Кроме этих официальных репозиториев, в Mint могут быть использованы пакеты из PPA-репозиториев Ubuntu, собираемые для этого дистрибутива независимыми майнтайнерами. Так что и них будет сказано под занавес.</p>
    <h3 id="toc122"><a id="RefHeading16861713816058"></a><a id="bkmRefHeading16861713816058"></a><a id="toc121"></a><a id="bkmtoc121"></a><a id="RefHeading5241136957987"></a><a id="bkmRefHeading5241136957987"></a><a id="bkmRefHeading5241136957987"></a><a id="bkmbkmRefHeading5241136957987"></a>Устройство репозиториев Ubuntu</h3>
    <p class="Textbody">Официальные репозитории Ubuntu располагаются по адресу: archive.ubuntu.com/ubuntu. Это — «головное» хранилище пакетов, имеющее многочисленные региональные зеркала, принадлежность которых к стране указывается стандартным двухсимвольным префиксом, например ru.archive.ubuntu.com/ubuntu/ — российское зеркало. Впрочем, как раз российского зеркала утилита Mintsources (о которой шла речь в соответствующем разделе) автоматически не предлагает.</p>
    <p class="Textbody">Проще всего с устройством репозиториев с точки зрения применителя можно ознакомиться просмотром их списка в файле /etc/apt/sources.list.d/official-package-repositories.list. Он создаётся автоматически при инсталляции, но затем может быть изменён с помощью Mintsources или отредактирован в текстовом редакторе. Например, у меня относящесяся к репозиториям Ubuntu строки имеют следующий вид:</p>
    <p class="Textbody"><span style="background-color:#dddddd">deb http://gd.tuwien.ac.at/opsys/linux/ubuntu/archive trusty main restricted universe multiverse</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">deb http://gd.tuwien.ac.at/opsys/linux/ubuntu/archive trusty-updates main </span><span style="background-color:#dddddd">restricted universe multiverse</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">deb http://security.ubuntu.com/ubuntu/ trusty-security main restricted universe multiverse</span> </p>
    <p class="Textbody">Здесь первый компонент в каждой строке, deb, означает, что речь идёт о бинарных пакетах (про пакеты с исходниками я скажу чуть позже). Далее следует «базовый» URL репозитория. В первых двух строках он соответствует тому серверу, который был выбран мной с помощью утилиты Mintsources по «скоростным» показателям, в третьей — сохранился в первозданном виде. Затем определяется группа пакетов, соответствующая имени релиза. В данный момент для нас актуален Trusty, потому как именно из него Mint Rebecca (как и предшествовавшая ей Qiana) черпает все свои основные, не специфичные для него, компоненты. Групп этих три:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">просто trusty — в неё входят собственно собственно пакеты дистрибутива; </p>
      </li>
      <li>
        <p class="Textbody">trusty-updates — «обычные» обновления пакетов, связанные со сменой версий, сборок и исправлением ошибок; </p>
      </li>
      <li>
        <p class="Textbody">trusty-security — как нетрудно догадаться, обновления, латающие «дыры» в безопасности системы. </p>
      </li>
    </ul>
    <p class="Textbody">На самом деле в репозитории Ubuntu имеются ещё группы trusty-backport и trusty-proposed, но в Mint они по умолчанию не задействованы, а trusty-proposed вообще можно подключить только вручную (чего, впрочем, делать не стоит без очень веских причин). В нашем же файле среди «Ubuntu'йских» строк есть такая:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">deb http://archive.canonical.com/ubuntu/ trusty partner</span> </p>
    <p class="Textbody">Это репозиторий для пакетов, в том числе и коммерческих, разрабатываемых партнёрами фирмы Canonical. Я, кажется, никогда ничего из него не устанавливал, ни в Mint, ни в Ubuntu, и больше говорить о нём не буду.</p>
    <p class="Textbody">Далее в каждой группе идёт перечень категорий пакетов. Их четыре:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">main — полностью свободные пакеты, официально поддерживаемые разработчиками Ubuntu; </p>
      </li>
      <li>
        <p class="Textbody">restricted — пакеты, также официально поддерживаемые дистрибутивом, но не вполне свободные; </p>
      </li>
      <li>
        <p class="Textbody">universe — полностью свободные программы, официально дистрибутивом не поддерживаемые и развивающиеся силами независимых разработчиков; </p>
      </li>
      <li>
        <p class="Textbody">multiverse — пакеты, аналогично universe официально не поддерживаемые и, подобно restricted, не вполне свободные. </p>
      </li>
    </ul>
    <p class="Textbody">«Не вполне свобода» пакетов из категорий restricted и multiverse выражается в ограничениях на их распространение (например, мультимедиа-кодеки, использующие алгоритмы, патентованные в отдельных странах) или могут распространяться только в бинарном виде (фирменные драйверы для видеокарт Nvidia).</p>
    <p class="Textbody">До сих пор речь шла о репозиториях бинарных пакетов. Однако существуют и параллельные им репозитории с исходниками. Они подлючаются, если отметить соответствующую опцию в Mintsources — при этом герерируется файл /etc/apt/sources.list.d/official-source-repositories.list. Он устроен точно таким же образом, что и official-package-repositories.list, только в первой позиции каждой его строки будет стоять deb-src:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">deb-src http://gd.tuwien.ac.at/opsys/linux/ubuntu/archive trusty main restricted universe multiverse</span> </p>
    <p class="Textbody">и так далее.</p>
    <h3 id="toc123"><a id="RefHeading16881713816058"></a><a id="bkmRefHeading16881713816058"></a><a id="toc122"></a><a id="bkmtoc122"></a><a id="RefHeading5261136957987"></a><a id="bkmRefHeading5261136957987"></a><a id="bkmRefHeading5261136957987"></a><a id="bkmbkmRefHeading5261136957987"></a>Особенности репозитория Mint</h3>
    <p class="Textbody">Репозитории Mint организованы внешне сходно с таковыми Ubuntu, но на самом деле строятся по несколько иным принципам. В файле official-package-repositories.list они описываются двумя строками:</p>
    <p class="Textbody"><span style="background-color:#dddddd">deb http://linux-mint.froonix.org rebecca main upstream import</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">deb http://extra.linuxmint.com rebecca main</span> </p>
    <p class="Textbody">Первая — определяет основной репозиторий для пакетов дистрибутива, распространяемых свободно: это аналог групп main и universe из репозиториев Ubuntu. Как и в последних, в ней указывается URL подключённого по умолчанию или выбранного позднее сервера, а затем имя релиза (на текущий момент — rebecca). Далее следует список категорий, однако тут в это понятие вкладывается несколько иной смысл. Так, категория main включает в себя те самый дистрибутив-специфичные пакеты, о которых я столько говорил раньше: «фирменные» утилиты, MDA, Cinnamon, MATE. В категорию upstream входят пакеты, заимствованные из GNOME 3 и специально пересобранные для совместимости с Mint. Здесь же можно обнаружить пакеты для его Xfce-редакции. Категория же import образована пакетами для KDE-редакции, представленными во всей их полноте.</p>
    <p class="Textbody">Кроме трёх перечисленных, в основном репозитории имеются категории backport и romeo. В первой — пакеты, перенесённые из более новых версий в более старые, второй — пакеты в стадии тестирования. Обе эти категории подключаются только в том случае, если в Mintsources были отмечены соответствующие опции (ну или они были прописаны руками в official-package-repositories.list).</p>
    <p class="Textbody">Репозиторий extra.linuxmint.com не имеет зеркал (по крайней мере, сейчас) и содержит единственную категорию main, включающую не вполне свободные пакеты — это аналог категорий restricted и multiverse из репозиториев Ubuntu. То есть формально в нём есть и все те же категории, что и в основном репозитории, но они пусты (по крайней мере, в момент сочинения этих строк).</p>
    <p class="Textbody">Симметрично строкам для репозиториев бинарных пакетов в файле official-source-repositories.list есть строки для описания репозиториев исходников:</p>
    <p class="Textbody"><span style="background-color:#dddddd">deb-src http://linux-mint.froonix.org rebecca main upstream import</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">deb-src http://extra.linuxmint.com rebecca main</span> </p>
    <p class="Textbody">Файлы списков репозиториев можно (почти) безбоязненно править руками в текстовом редакторе. В частности, именно таким образом осуществляется апгрейд с релиза на релиз (по крайней мере, в пределах одной LTS-версии): для этого достаточно заменить, например, все вхождения qiana на rebecca и выполнить тотальное обновление системы, о чём будет рассказано в своё время.</p>
    <p class="Textbody">В заключение же разговора о репозиториях Mint напомню, что их содержимое можно посмотреть визуально в браузере — и <a href="http://packages.linuxmint.com/index.php" target="_blank">основного</a>, и <a href="http://extra.linuxmint.com/index.php" target="_blank">extra</a>.</p>
    <h3 id="toc124"><a id="RefHeading16901713816058"></a><a id="bkmRefHeading16901713816058"></a><a id="toc123"></a><a id="bkmtoc123"></a><a id="RefHeading5281136957987"></a><a id="bkmRefHeading5281136957987"></a><a id="bkmRefHeading5281136957987"></a><a id="bkmbkmRefHeading5281136957987"></a>О PPA-репозиториях</h3>
    <p class="Textbody">Кроме официального репозитория, для Ubuntu существует централизованное хранилище репозиториев дополнительных, объединяемых понятием PPA — Personal Packages Archive, то есть входящих в персональный архив пакетов, пополняемый сторонними разработчиками и майнтайнерами. А их, вследствие популярности дистрибутива, очень немало. И поэтому свежие версии многих программ, как популярных (что важно для начинающих), так и весьма экзотических (что часто критично для многоопытных), в первую очередь появляются как бинарники в так называемых PPA-репозиториях Ubuntu.</p>
    <p class="Textbody">Для доступа к PPA-репозиториям фирмой Canonical разработан специальный онлайновый инструмент — Launchpad, размещённый на <a href="https://launchpad.net/" target="_blank">одноимённом сайте</a>. Это — не открытая и не свободная система. Более того, она имеет и платную версию, предназначенную для коммерческих пакетов. Однако мы ведь не рататую абстрактной свободы, и нас это не волнует, верно? Цели и задачи Launchpad'а не ограничиваются обеспечением доступа к PPA-репозиториям. Однако остальные его функции предназначены для разработчиков, и потому нас, применителей, также не касаются.</p>
    <p class="Textbody">Казалось бы, при чём здесь Mint? А при том, что практически все пакеты из PPA-репозиториев прекрасно устанавливаются в нём и работают точно так же, как в родной Ubuntu. И потому обращение к ним неизбежно, как как крах мировой системы социализма: далеко не всегда потребности применителя в пакетах удовлетворяются официальными репозиториями Ubuntu, даже дополненными Mint'овскими.</p>
    <p class="Textbody">В разделе про Mintsource мы уже занимались подключением PPA-репозиториев. Теперь посмотрим, что получается в итоге. А вот что: в том же каталоге /etc/apt/sources.list.d/ к спискам официальных репозиториев, official-package-repositories.list и official-source-repositories.list, присоединяются файлы вида *.list — по одному на каждый подключённый репозиторий, где под маской скрывается его так называемое ppa-имя.</p>
    <p class="Textbody">Откуда берётся ppa-имя — расскажу в очерке про управление пакетами. А пока — как оно выглядит. Большинство пакетов в PPA-репозиториях собирается и поддерживается майнтайнерами-индивидуалами, и потому здесь нередко можно видеть их имена, фамилии или ники, например, ppa:andrew-crew-kuznetsov/crew — репозиторий, поддерживаемый Андреем Crew Кузнецовым, разработчиком программы XNeur и сборщиком пакета hunspell-ru-ie-yo, словаря для проверки русской орфографии, поддерживающего букву Ё. В других случаях это просто имя пакета, часто с отражением статуса разработки, например, ppa:marlin-devs/marlin-daily — репозиторий «ежедневных» сборок файлового менеджера Marlin. Репозиторий может включать несколько связанных друг с другом пакетов — и тогда называться по главному из них, например: ppa:zfs-native/stable и ppa:zfs-native/daily — репозитории пакетов поддержки ZFS on Linux стабильной и разрабатываемой ветки, соответственно.</p>
    <p class="Textbody">Возможны и более причудливые имена, например, ppa:mystic-mirage/komodo-edit — репозиторий текстового редактора Komodo Edit. Важно, что они в обязательном порядке включают «префикс» ppa:, который в имени соответствующего list-файла отбрасывается. Зато завершается последний обязательным компонентом — именем релиза. Например, для Komodo Edit имя list-файла — mystic-mirage-komodo-edit-trusty.list.</p>
    <p class="Textbody">Внутри такого файла — обычно две строки. Например, для пакета komodo-edit они будут такими:</p>
    <p class="Textbody"><span style="background-color:#dddddd">deb http://ppa.launchpad.net/mystic-mirage/komodo-edit/ubuntu trusty main</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">deb-src http://ppa.launchpad.net/mystic-mirage/komodo-edit/ubuntu trusty main</span> </p>
    <p class="Textbody">То есть в одном файле описывается и репозиторий бинарников, и репозиторий исходников. Если последний отсутствует — соответствующей строки не будет. Впрочем, в PPA-репозиториях пакетов без исходников не водится. А вот среди «не вполне свободного» софта встречаются, примером чему — браузер Opera: файл opera-stable.list выглядит следующим образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">deb http://deb.opera.com/opera-stable/ stable non-free #Opera Browser (final releases)</span> </p>
    <p class="Textbody">Однако случаи, когда приходится искать пакеты за пределами PPA-репозиториев, очень редки. Ибо в них, как в Греции есть всё — и ещё немного больше, чем всё.</p>
    <h3 id="toc125"><a id="RefHeading16921713816058"></a><a id="bkmRefHeading16921713816058"></a><a id="toc124"></a><a id="bkmtoc124"></a><a id="RefHeading5301136957987"></a><a id="bkmRefHeading5301136957987"></a><a id="bkmRefHeading5301136957987"></a><a id="bkmbkmRefHeading5301136957987"></a>Подключение PPA-репозиториев</h3>
    <p class="Textbody">Чтобы воспользоваться всем греческим сокровищем,описанным на предыдущей страницу, необходимо научиться подключать дополнительные репозитории вообще и PPA-репозитории в особенности.</p>
    <p class="Textbody">В очерке про фирменный инструментарий Mint был описан один способ их подключения — с помощью утилиты mintsources, она же software-sources. Однако это можно сделать и в CLI — командой add-apt-repository (или apt-add-repository — это опять-таки символическая ссылка на неё). Поскольку очевидно, что для подключения репозиториев требуются права администратора, команда эта должна быть дана в такой форме:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo add-apt-repository ppa-name</span> </p>
    <p class="Textbody">Если воспользоваться глобальными псевдонимами Zsh, это будет выглядеть примерно так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo Ar ppa-name</span> </p>
    <p class="Textbody">Так что остаётся только сущая мелочь — определить это самое ppa-имя нужного репозитория. Между прочим, та же проблема была и при использовании mintsources — и он никак не может помочь в этом деле. Как её решить?</p>
    <p class="Textbody">Можно, конечно, походить по форумам Ubuntu'йской тематики, можно сделать запрос к Гоше или Яше, указав имя искомого пакета, можно... да много чего можно сделать, чтобы по прошествии изрядного или ещё большего времени получить нужный результат. А можно, действуя методично и планомерно, прибегнуть к универсальному способу. И для начала зайти на <a href="https://launchpad.net/" target="_blank">Launchpad</a>:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/add-repo_001.png">
        <img alt="Изображение249" class="frameGraphics" id="249graphic" src="http://alv.me/wp-content/img/im_cin_img/add-repo_001-539x572.png" style="border:1.0px solid #000080;padding:0;width:540.8416px;height:573.83685px" />
      </a>
      <a id="a249graphic"></a>
      <a id="bkm249graphic"></a>
    </p>
    <p class="Textbody">Далее в поле поиска следует набрать имя требующегося пакета или его фрагмент, например, zfs. Далее в списке выдачи результатов нужно отыскать нужную строку — в данном случае это будет ZFS Stable Releases... или ZFS Daily Releases..., в зависимости от требований — стабильности или фронтирности:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/add-repo_002.png">
        <img alt="Изображение250" class="frameGraphics" id="250graphic" src="http://alv.me/wp-content/img/im_cin_img/add-repo_002-539x572.png" style="border:1.0px solid #000080;padding:0;width:540.8416px;height:573.83685px" />
      </a>
      <a id="a250graphic"></a>
      <a id="bkm250graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/add-repo_002.png"> </a>
    </p>
    <p class="Textbody">Теперь — щёлкнуть на ней (предположим, мы предпочти синицу стабильности журавлю фронтирности), и прочитать раздельчик, озаглавленный Adding this PPA to your system:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/add-repo_003.png">
        <img alt="Изображение251" class="frameGraphics" id="251graphic" src="http://alv.me/wp-content/img/im_cin_img/add-repo_003-539x572.png" style="border:1.0px solid #000080;padding:0;width:540.8416px;height:573.83685px" />
      </a>
      <a id="a251graphic"></a>
      <a id="bkm251graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/add-repo_003.png"> </a>
    </p>
    <p class="Textbody">Искомое ppa-имя будет выделено полужирным шрифтом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/add-repo_004.png">
        <img alt="Изображение252" class="frameGraphics" id="252graphic" src="http://alv.me/wp-content/img/im_cin_img/add-repo_004.png" style="border:1.0px solid #000080;padding:0;width:461.84946px;height:324.84158px" />
      </a>
      <a id="a252graphic"></a>
      <a id="bkm252graphic"></a>
    </p>
    <p class="Textbody">Его и следует подставить в качестве аргумента команды:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo add-apt-repository ppa:zfs-native/stable</span> </p>
    <p class="Textbody">Дабы развеять все сомнения, можно пройти по ссылке Read about installing. Появится всплывающее окошко, в котором процедура добавления PPA-репозитория будет описана подробно:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/add-repo_005.png">
        <img alt="Изображение253" class="frameGraphics" id="253graphic" src="http://alv.me/wp-content/img/im_cin_img/add-repo_005-572x365.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:366.83212px" />
      </a>
      <a id="a253graphic"></a>
      <a id="bkm253graphic"></a>
    </p>
    <p class="Textbody">И не только описана, но и проиллюстрирована:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/add-repo_006.png">
        <img alt="Изображение254" class="frameGraphics" id="254graphic" src="http://alv.me/wp-content/img/im_cin_img/add-repo_006.png" style="border:1.0px solid #000080;padding:0;width:532.829px;height:245.84944px" />
      </a>
      <a id="a254graphic"></a>
      <a id="bkm254graphic"></a>
    </p>
    <p class="Textbody">Да, выполнив последнюю команду, нужно ни в коем случае не забыть проделать процедуру апдейта:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt update</span> </p>
    <p class="Textbody">Обращаю внимание — команда sudo отсутствует: как будет показано в следующем очерке, реализация apt для Mint позволяет применителю не утруждать себя её вводом.</p>
    <p class="Textbody">Теперь можно устанавливать пакеты из новообретённого репозитория (о чём также пойдёт речь в следующем очерке). А ознакомиться со списком оных можно ещё на странице Launchpad'а:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/add-repo_007.png">
        <img alt="Изображение255" class="frameGraphics" id="255graphic" src="http://alv.me/wp-content/img/im_cin_img/add-repo_007-572x536.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:537.8558px" />
      </a>
      <a id="a255graphic"></a>
      <a id="bkm255graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/add-repo_007.png"> </a>
    </p>
    <p class="Textbody">Впрочем, можно поступить иначе, обойдясь без команды add-apt-repository: развернуть строку Technical details about this PPA и в выпадающем меню выбрать имя (номер) своего релиза Ubuntu. В нашем случае это будет Trusty (14.04), так как и Mint Qiana, и Mint Rebecca основаны на нём:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/add-repo_008.png">
        <img alt="Изображение256" class="frameGraphics" id="256graphic" src="http://alv.me/wp-content/img/im_cin_img/add-repo_008-572x282.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:283.8337px" />
      </a>
      <a id="a256graphic"></a>
      <a id="bkm256graphic"></a>
    </p>
    <p class="Textbody">Строки из поля ниже просто копируются в новый текстовый файл, создаваемый в каталоге /etc/apt/sources.list.d под именем package_name-status-release_name.list, то есть в нашем примере — zfs-native-stable-trusty.list. После чего опять же не забыть про</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt update</span> </p>
    <p class="Textbody">Не правда ли, любой из предложенных способов проще, чем беготня по форумам? Да и Гошу с Яшей не стоит беспокоить по пустякам.</p>
    <p class="Textbody">Отдельный случай — подключение репозиториев, содержащих всякие красивости, вроде тем, пиктограмм или обоин. Главным источником таковых является сайт <a href="http://www.noobslab.com/" target="_blank">NoobsLab</a>. Здесь также всё просто — в каждой теме или коллекции пиктограмм имеется исчерпывающая инструкция по подключению соответствующего репозитория. В подавляющем большинстве случаев она сводится к выполнению директив</p>
    <p class="Textbody"><span style="background-color:#dddddd">sudo add-apt-repository ppa:noobslab/themes</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">sudo add-apt-repository ppa:noobslab/icons</span> </p>
    <p class="Textbody">что, очевидно, нужно проделать единократно, с последующим апдейтом, то есть в нашем случае опять-таки</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt update</span> </p>
    <p class="Textbody">Что же до обоин — думаю, каждый уважающий сеья применитель-эстет имеет собственную коллекцию картинок для использования в этом качестве.</p>
    <p class="Textbody">Редко, но бывает так, что приходится устанавливать пакеты из какого-либо иного источника, нежели PPA-репозитории. Но в этом случае грамотно сделанный пакет при установке сам добавляет свой репозиторий в общий список — так, например, происходит при установке биаузера Opera версии 26.X для Linux. Либо — сопровождается сведениями о том, как это сделать самостоятельно. Если ни того, ни другого не имеет места быть — возникает вопрос: а стоит ли связываться с таким пакетом?</p>
    <h2 id="toc126"><a id="RefHeading16941713816058"></a><a id="bkmRefHeading16941713816058"></a><a id="toc125"></a><a id="bkmtoc125"></a><a id="RefHeading12741136957987"></a><a id="bkmRefHeading12741136957987"></a><a id="bkmRefHeading12741136957987"></a><a id="bkmbkmRefHeading12741136957987"></a>Управление пакетами</h2>
    <p class="Textbody">Работа с пакетами предполагает следующие действия — их установку с занесением в локальную базу данных, отслеживание зависимостей (и иногда их разрешение) обновление, удаление, получение информации о пакетах, иногда конфигурирование. Для понимания сути их необходимо дать</p>
    <h3 id="toc127"><a id="RefHeading16961713816058"></a><a id="bkmRefHeading16961713816058"></a><a id="toc126"></a><a id="bkmtoc126"></a><a id="RefHeading5321136957987"></a><a id="bkmRefHeading5321136957987"></a><a id="bkmRefHeading5321136957987"></a><a id="bkmbkmRefHeading5321136957987"></a>Терминологическое введение</h3>
    <p class="Textbody">В системах пакетного менеджмента deb based дистрибутивов, в том числе и в Mint, пакеты объединяются в категории, секции и группы. Список категорий включает следующие пункты:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Установленные пакеты — очевидно из названия; </p>
      </li>
      <li>
        <p class="Textbody">Обновляемые пакеты — установленные пакеты, для которых в репозитории доступны более новые версии; </p>
      </li>
      <li>
        <p class="Textbody">New Packages — пакеты, добавленные в локальный кэш  после последней его очистки; </p>
      </li>
      <li>
        <p class="Textbody">Неустановленные пакеты — пакеты, отсутствующие в системе, но доступные из репозиториев; </p>
      </li>
      <li>
        <p class="Textbody">Виртуальные пакеты — не существующие пакеты, указывающие на другие пакеты, которые нужно использовать или которые предоставляют схожие функции.; </p>
      </li>
      <li>
        <p class="Textbody">Задачи (Tasks) — группы пакетов (метапакеты), которые предоставляют лёгкий способ выбора заранее сформированного набора пакетов под определённую цель. </p>
      </li>
    </ul>
    <p class="Textbody">В секции пакеты группируются по назначению: программы для администрирования, базовые пакеты, текстовые редакторы, и так далее.</p>
    <p class="Textbody">Группы представляющие собой разделы официального репозитория. В Mint они таковы: main, upstream, import, backport, romeo.</p>
    <p class="Textbody">Каждый пакет в терминологии имеет основной статус, обозначаемый строчной литерой; в их число входят:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">i (от install) — установленный пакет; </p>
      </li>
      <li>
        <p class="Textbody">p (от purge) — пакет не установленный или деинсталлированный «вчистую» (то есть с удалением его конфигурационных файлов); </p>
      </li>
      <li>
        <p class="Textbody">c (от clean) — пакет, деинсталлированный с сохранением конфигурационных файлов; </p>
      </li>
      <li>
        <p class="Textbody">v (от virtual) — виртуальный пакет. </p>
      </li>
    </ul>
    <p class="Textbody">Кроме того, пакеты могут иметь один из следующих дополнительных статусов, хотя это и не обязательно:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">A (от Auto) — установленный автоматически, как зависимость другого пакета; пакеты, не имеющие статуса A, считаются установленными вручную; </p>
      </li>
      <li>
        <p class="Textbody">h (от hold) — пакет с фиксированной версией (то есть не подверженный апгрейду); </p>
      </li>
      <li>
        <p class="Textbody">u (от unpacked) — пакет распакованный, но не установленный; </p>
      </li>
      <li>
        <p class="Textbody">H — «недоустановленный» пакет; </p>
      </li>
      <li>
        <p class="Textbody">C — пакет установленный, но не настроенный; </p>
      </li>
      <li>
        <p class="Textbody">B — «сломанный» пакет, то есть установленный с нарушением зависимостей. </p>
      </li>
    </ul>
    <p class="Textbody">Обращаю особое внимание на пакеты, имеющие статус A: они устанавливаются вместе со своими зависимостями и могут быть удалены только вместе с ними. Правда, как мы увидим дальше, статус установленного пакета может быть изменён, и тогда он станет доступным для индивидуального удаления.</p>
    <p class="Textbody">В сущности, все действия по управлению пакетами в Mint сводятся к изменению их статуса. И делается это с помощью инструментов текстового режима (утилиты dpkg и apt) или графических фронт-эндов (Менеджер программ и Synaptic).</p>
    <h3 id="toc128"><a id="RefHeading16981713816058"></a><a id="bkmRefHeading16981713816058"></a><a id="toc127"></a><a id="bkmtoc127"></a><a id="RefHeading5341136957987"></a><a id="bkmRefHeading5341136957987"></a><a id="bkmRefHeading5341136957987"></a><a id="bkmbkmRefHeading5341136957987"></a>Средства для работы с пакетами. Обзор</h3>
    <p class="Textbody">Инструментарий для работы с пакетами можно разделить на пять групп:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">установщики пакетов; </p>
      </li>
      <li>
        <p class="Textbody">оболочки для них; </p>
      </li>
      <li>
        <p class="Textbody">менеджеры пакетов; </p>
      </li>
      <li>
        <p class="Textbody">их графические фронт-энды; </p>
      </li>
      <li>
        <p class="Textbody">центры приложений. </p>
      </li>
    </ul>
    <p class="Textbody">Первая группа — это низкоуровневые утилиты для работы с единичными пакетами: их установки, удаления, etc. В нашем случае эту роль выполняет семейство утилит dpkg. Отслеживание зависимостей здесь выполняется на уровне удовлетворения или неудовлетворения, попыток автоматического разрешения зависимостей не предпринимается. Семейство это не уникально для Mint, а присутствует во всех дистрибутивах, использующих deb-формат пакетов.</p>
    <p class="Textbody">Оболочки для установщиков пакетов выполняют те же самые функции, что и они сами, но посредством не прямых команд, а графического интерфейса. В Mint такой оболочкой для dpkg является Gdebi.</p>
    <p class="Textbody">Менеджеры пакетов работают уже не с единичными пакетами, а с их репозиториями. И, кроме перечисленных функций, их непременной обязанностью является не только отслеживание зависимостей, но и их автоматическое, по возможности, разрешение. В большинстве deb based дистрибутивов эту роль выполняет семейство утилит APT. Однако в Mint имеется собственная реализация такого инструмента в лице интегрированной утилиты apt — её следует чётко отличать от одноимённой команды из обще-Debian'овского APT-семейства.</p>
    <p class="Textbody">Четвёртая группа — графические фронт-энды для менеджеров пакетов. В Mint она представлена программой Synaptic.</p>
    <p class="Textbody">Что же касается пятой группы — это самые высокоуровневые программы, в которых прозрачно для применителя интегрированы функции поиска пакетов в Сети, подключения к содержащим их репозиториями и собственно пакетный менеджмент. Название её заимствовано от Центра приложений Ubuntu — первого представителя этой группы. В Mint её аналогом выступает Менеджер программ, о котором говорилось в очерке про фирменные утилиты этого дистрибутива. Остальные же инструменты работы с пакетами будут рассмотрены в ближайших очерках.</p>
    <h3 id="toc129"><a id="RefHeading17001713816058"></a><a id="bkmRefHeading17001713816058"></a><a id="toc128"></a><a id="bkmtoc128"></a><a id="RefHeading5361136957987"></a><a id="bkmRefHeading5361136957987"></a><a id="bkmRefHeading5361136957987"></a><a id="bkmbkmRefHeading5361136957987"></a>Установщик пакетов dpkg</h3>
    <p class="Textbody">Утилиты семейства dpkg, предназначенные для работы с единичными deb-пакетами, были исторически первым средством автоматического развертывания пакетов, учитывающим их зависимости. Они лежат в фундаменте всех надстраивающих их систем (apt, synaptic, mintinstall. В ряде случаев dpkg оказывается наиболее простым средством для установки или удаления пакета, а также получения информации о нем. Кроме того, одна из утилит семейства, dpkg-reconfigure, с которой мы сталкивались во время доводки текстовой консоли, оказывается незаменимой при настройке пакетов установленных.</p>
    <p class="Textbody">Вообще, возможности утилит семейства (см. man (1) dpkg) очень широки, и потому заслуживают рассмотрения, хотя бы в минимально необходимом для применителя объёме. Наиболее употребимы из них — следующие:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">собственно dpkg — средство для установки и удаления программ; </p>
      </li>
      <li>
        <p class="Textbody">dpkg-query — инструмент создания запросов к базе данных deb-пакетов; </p>
      </li>
      <li>
        <p class="Textbody">dpkg-reconfigure — программа для настройки установленных пакетов. </p>
      </li>
    </ul>
    <p class="Textbody">А вообще это семейство включает в себя около 25 утилит — полный их список можно просмотреть таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">ls /usr/sbin/dpkg* /usr/bin/dpkg*</span> </p>
    <p class="Textbody">Утилиты эти входят в состав пакетов dpkg и dpkg-dev; первый, предназначенный для основных действий с бинарными пакетами, устанавливается по умолчанию в ходе первичной инсталляции; второй же, включающий утилиты для манипуляции с пакетами исходников, должен быть установлен дополнительно (или устанавливается как зависимость при инсталляции deb-специфичного сборочного инструментария).</p>
    <p class="Textbody">Для начала рассмотрим установку пакетов. Итак, если нам необходимо установить единичный пакет, поступаем так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ dpkg -i path2/packagename.deb</span> </p>
    <p class="Textbody">и дело в шляпе — через считанные мгновения пакет packagename.deb будет установлен: это обеспечивает опция -i (от install) вслед за командой dpkg. Дабы в дальнейшем не повторяться, замечу, что все действия по установке и удалению пакетов требуют полномочий администратора, приобретаемых временно командой sudo.</p>
    <p class="Textbody">Разумеется, успешной установка пакета будет только при соблюдении следующих условий:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">физическом наличии его в пределах досягаемости с локальной машины (на подключенной файловой системе, смонтированном компакт-диске или ином носителе); </p>
      </li>
      <li>
        <p class="Textbody">знании точного пути (path2) к нужному файлу пакета (имя его, кстати, должно быть указано полностью); </p>
      </li>
      <li>
        <p class="Textbody">отсутствии неудовлетворенных зависимостей. </p>
      </li>
    </ol>
    <p class="Textbody">Из первого условия следует, что dpkg удобно использовать при доустановке компонентов с инсталляционного CD/DVD (или установке заблаговременно скачанных пакетов). Второе условие самоочевидно. Ну а третье также выполнимо без особого труда: в случае нарушения зависимостей dpkg выдаст сообщение об ошибке с полным перечнем того, что нужно установить для ее устранения, причём в списке будут перечислены только обязательные зависимости. И достаточно все необходимые пакеты поместить в командную строку:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo dpkg -i path2/packagename1.deb … path2/packagename#.deb</span> </p>
    <p class="Textbody">для того, чтобы они были установлены единой операцией (если, конечно, все эти пакеты имеются в наличии).</p>
    <p class="Textbody">Другое часто требующееся применение команды dpkg — удаление ненужных пакетов. Это делается двояко: команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo dpkg -r packagename</span> </p>
    <p class="Textbody">удалит пакет, но сохранит настроечные его файлы, а команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo dpkg -P packagename</span> </p>
    <p class="Textbody">произведет полную очистку системы от всех компонентов пакета (кроме конфигурационных файлов в домашнем каталоге пользователя — от них в любом случае придется избавляться вручную). Правда, только если он не связан зависимостями с другими пакетами — в этом случае последует сообщение о невозможности удаления пакета и выведен список его зависимостей, этому препятствующих.</p>
    <p class="Textbody">Обратим внимание — в аргументах обеих команд фигурирует уже не полное имя пакета, а только его базовая часть. Это распространяется на все случаи использования dpkg (и других команд ее семейства), когда речь идет об уже установленных пакетах.</p>
    <p class="Textbody">Следующая сфера деятельности команд семейства dpkg — получение информации о пакетах. И здесь первое дело — это получение списка пакетов, установленных в системе:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ dpkg -l</span> </p>
    <p class="Textbody">Что в моей системе даёт примерно такой вывод:</p>
    <p class="Textbody"><span style="background-color:#dddddd">ii  accountsservice 0.6.35-0ubuntu7.1 amd64 query and manipulate user account information</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">ii  acl 2.2.52-1 amd64 Access control list utilities</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">…</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">ii  zsh 5.0.2-3ubunt amd64 shell with lots of features</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">ii  zsh-common 5.0.2-3ubunt all architecture independent files for Z</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">ii  zsh-doc 5.0.2-3ubunt all zsh documentation - info/HTML format</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">ii  zsh-lovers 0.8.3-0ubunt all tips, tricks and examples for the zs</span> </p>
    <p class="Textbody">До появления интегрированной утилиты apt команда dpkg -l была чуть ли не единственным способом получения списка установленных пакетов. Или, по крайней мере, самым простым.</p>
    <p class="Textbody">Для уже установленных пакетов информацию о них проще всего получить с помощью команды dpkg-query, требующей указания какого-либо из операторов действия и имени пакета в качестве аргумента. Операторы действия команды dpkg-query можно вывести так (поскольку получение информации о пакетах никак не влияет на систему в целом, необходимости в правах администратора тут не возникает):</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ dpkg-query --help</span> </p>
    <p class="Textbody">Они следующие:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">-s или --status — вывод детального статуса пакета, включающий: </p>
        <ul style="margin-top:0;margin-bottom:0;list-style-type:bullet;clear:left">
          <li>
            <p class="Textbody">имя пакета, собственно статус (установлен ли он) и приоритет; </p>
          </li>
          <li>
            <p class="Textbody">секция репозитория, к которой пакета относится (например, editors — для текстовых редакторов); </p>
          </li>
          <li>
            <p class="Textbody">размер пакета в установленном виде; </p>
          </li>
          <li>
            <p class="Textbody">имя майнтайнера, архитектура, для которой пакет собран, и номер версии; </p>
          </li>
          <li>
            <p class="Textbody">описание зависимостей и конфликтов; </p>
          </li>
          <li>
            <p class="Textbody">краткое (в один абзац) описание пакета. </p>
          </li>
        </ul>
      </li>
      <li>
        <p class="Textbody">-p или --print-avail — практически то же самое, но в форме, приспособленной для печати; </p>
      </li>
      <li>
        <p class="Textbody">-l или --list — тоже своего рода описание статуса, включающее сведения о том, установлен ли пакет, нуждается ли он в обновлении, нет ли ошибок в его настройке, и так далее; </p>
      </li>
      <li>
        <p class="Textbody">-W или --show — просто вывод номера версии в форме: </p>
        <p class="Textbody"><span style="background-color:#dddddd"> $ dpkg-query -W nano</span> </p>
        <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">nano    1.3.8-2</span> </p>
      </li>
      <li>
        <p class="Textbody">-L или --listfiles — полный список файлов, относящихся к данному пакету, в форме: </p>
        <p class="Textbody"><span style="background-color:#dddddd"> /.</span> </p>
        <p class="Textbody"><span style="background-color:#dddddd">/etc</span> </p>
        <p class="Textbody"><span style="background-color:#dddddd">/etc/nanorc</span> </p>
        <p class="Textbody"><span style="background-color:#dddddd">/usr</span> </p>
        <p class="Textbody"><span style="background-color:#dddddd">/usr/share</span> </p>
        <p class="Textbody"><span style="background-color:#dddddd">/usr/share/doc</span> </p>
        <p class="Textbody"><span style="background-color:#dddddd">/usr/share/doc/nano</span> </p>
        <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">…</span> </p>
        <p class="Textbody">и так далее (пример для текстового редактора nano);</p>
      </li>
      <li>
        <p class="Textbody">-S или --search — поиск пакета, к которому относится некий файл, указанный в качестве аргумента; может выполнить и обратную задачу — поиск всех файлов, принадлежащих данному пакету, вывод в этом случае оказывается аналогичным dpkg-query -L. </p>
      </li>
    </ul>
    <p class="Textbody">Повторю, что все сказанное о информации по пакетам, относится к пакетам уже установленным. Для получения же сведений о неустановленных пакетах удобнее использовать графическую оболочку GDebi, о которой будет говориться в следующем разделе.</p>
    <p class="Textbody">ещё одна важная задача утилит dpkg — выполнение настройки отдельных, уже установленных, пакетов. Предназначенная для этого команда так и называется — dpkg-reconfigure, и запускается таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo dpkg-reconfigure packagename</span> </p>
    <p class="Textbody">После этого вызывается диалоговая программа конфигурации — debconf, и ответы на серию более или менее тривиальных вопросов позволяют добиться желаемого результата. Каковы эти вопросы — зависит от настраиваемой программы. В частности, ранее dpkg-reconfigure была использована для настройки экранных шрифтов в консоли.</p>
    <h3 id="toc130"><a id="RefHeading17021713816058"></a><a id="bkmRefHeading17021713816058"></a><a id="toc129"></a><a id="bkmtoc129"></a><a id="RefHeading5381136957987"></a><a id="bkmRefHeading5381136957987"></a><a id="bkmRefHeading5381136957987"></a><a id="bkmbkmRefHeading5381136957987"></a>Установщик пакетов GDebi</h3>
    <p class="Textbody">GDebi представляет собой графический фронт-энд для утилиты dpkg. Она разработана фирмой Canonical специально для Ubuntu и потому, естественно, имеется и в Mint (о котором далее и пойдёт речь). Запустить GDebi можно из секции Администрирование главного меню Cinnamon — но тогда придётся обратиться к пункту File -&gt; Open её меню, и потом долго рыскать по файловому древу в поисках нужного имени. Так что более простой способ её запуска — клик на имени deb-файла в файловом менеджере Nemo. Что представит такую картинку:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/gdebi_01.png">
        <img alt="Изображение257" class="frameGraphics" id="257graphic" src="http://alv.me/wp-content/img/im_cin_img/gdebi_01.png" style="border:1.0px solid #000080;padding:0;width:551.84px;height:401.83054px" />
      </a>
      <a id="a257graphic"></a>
      <a id="bkm257graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/gdebi_01.png"> </a>
    </p>
    <p class="Textbody">Самая ценная информация здесь — это список файлов, входящих в состав пакета. В отличие от Synaptic'а, о котором речь пойдёт со временем, GDebi выводит его даже для не установленных пакетов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/gdebi_02.png">
        <img alt="Изображение258" class="frameGraphics" id="258graphic" src="http://alv.me/wp-content/img/im_cin_img/gdebi_02-482x572.png" style="border:1.0px solid #000080;padding:0;width:483.8463px;height:573.83685px" />
      </a>
      <a id="a258graphic"></a>
      <a id="bkm258graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/gdebi_02.png"> </a>
    </p>
    <p class="Textbody">В случае, если в пакете всё устраивает, он устанавливается нажатием одноимённой кнопки, что сначала потребует авторизации, а затем незамедлительно начинается установка:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/gdebi_03.png">
        <img alt="Изображение259" class="frameGraphics" id="259graphic" src="http://alv.me/wp-content/img/im_cin_img/gdebi_03-572x191.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:192.82268px" />
      </a>
      <a id="a259graphic"></a>
      <a id="bkm259graphic"></a>
    </p>
    <p class="Textbody">Проверка зависимостей, естественно, осуществляется как и в dpkg — на уровне удовлетворённости или неудовлетворённости. В последнем случае выводится сообщение о том, какие пакеты следует установить для их разрешения. По завершении установки картинка становится такой:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/gdebi_04.png">
        <img alt="Изображение260" class="frameGraphics" id="260graphic" src="http://alv.me/wp-content/img/im_cin_img/gdebi_04.png" style="border:1.0px solid #000080;padding:0;width:551.84px;height:401.83054px" />
      </a>
      <a id="a260graphic"></a>
      <a id="bkm260graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/gdebi_04.png"> </a>
    </p>
    <p class="Textbody">Удаление пакета выполняется тем же образом: авторизация и собственно удаление:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/gdebi_05.png">
        <img alt="Изображение261" class="frameGraphics" id="261graphic" src="http://alv.me/wp-content/img/im_cin_img/gdebi_05-572x450.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:451.83374px" />
      </a>
      <a id="a261graphic"></a>
      <a id="bkm261graphic"></a>
    </p>
    <p class="Textbody">И завершается возвращением исходной картинки. Если от удаляемого пакета зависит какой-либо другой, то опять же последует сообщение об ошибке:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/gdebi_06.png">
        <img alt="Изображение262" class="frameGraphics" id="262graphic" src="http://alv.me/wp-content/img/im_cin_img/gdebi_06-572x225.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:226.83846px" />
      </a>
      <a id="a262graphic"></a>
      <a id="bkm262graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/gdebi_06.png"> </a>
    </p>
    <p class="Textbody">Никаких преимуществ против консольного бэк-энда, то есть собственно dpkg, я в GDebi не усмотрел — кроме разве что наглядности. Для установки большого количества пакетов она оказалась неудобной из-за необходимости авторизоваться на каждый такой чих — при использовании dpkg это можно решить один раз командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo -i</span> </p>
    <p class="Textbody">А самая востребованная сфера применения GDebi — установка единичного, не отягощённого завимисостями, пакета на предмет «поиграться и стереть». Но в этом отношении ей нет равных…</p>
    <h2 id="toc131"><a id="RefHeading17041713816058"></a><a id="bkmRefHeading17041713816058"></a><a id="toc130"></a><a id="bkmtoc130"></a><a id="RefHeading12761136957987"></a><a id="bkmRefHeading12761136957987"></a><a id="bkmRefHeading12761136957987"></a><a id="bkmbkmRefHeading12761136957987"></a>Утилита apt. Реализация для Linux Mint</h2>
    <p class="Textbody">В данном очерке рассмотрены особенности утилиты apt в реализации для дистрибутива Linux Mint и её отличия от семейства утилит, входящих в пакет apt, общий для всех deb based дистрибутивов.</p>
    <h3 id="toc132"><a id="RefHeading17061713816058"></a><a id="bkmRefHeading17061713816058"></a><a id="toc131"></a><a id="bkmtoc131"></a><a id="RefHeading5401136957987"></a><a id="bkmRefHeading5401136957987"></a><a id="bkmRefHeading5401136957987"></a><a id="bkmbkmRefHeading5401136957987"></a>Введение</h3>
    <p class="Textbody">В процессе сочинения этой книги обнаружилось, что реализация утилиты apt для этого дистрибутива не документирована никак — не только на языке родных осин, но даже на мове Вильяма нашего, Шекспира. В связи с чем я и решил посвятить ей отдельный очерк.</p>
    <p class="Textbody">Необходимость в таком материале, как мне кажется, ещё и в том, что многие начинающие пользователи Mint и особенно Linux вообще, судя по сайтам, блогам и форумам соответствующей тематики, даже не подозревают о существовании реализации apt для Mint и её отличиях от тёзки из одноимённого пакета. И потому механически применяют рецепты для чистой Ubuntu и её прямых клонов, на которые так богаты указанные ресурсы. Хотя использование apt для Mint делает эти рецепты излишними — функционал этой утилиты позволяет добиться той же цели быстрей и проще. По крайней мере, путём меньшего количества нажатий на клавиши.</p>
    <h3 id="toc133"><a id="RefHeading17081713816058"></a><a id="bkmRefHeading17081713816058"></a><a id="toc132"></a><a id="bkmtoc132"></a><a id="RefHeading5421136957987"></a><a id="bkmRefHeading5421136957987"></a><a id="bkmRefHeading5421136957987"></a><a id="bkmbkmRefHeading5421136957987"></a>Общее описание</h3>
    <p class="Textbody">Утилиту apt в реализации для Mint не следует путать ни с одноимённым пакетом, входящим в состав всех deb based дистрибутивов (в том числе и в Mint), ни с одноимённой же утилитой из этого пакета.</p>
    <p class="Textbody">Утилита apt для Mint входит в состав пакета mintsystem, что определяется с помощью её же самой:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt contains /usr/local/bin/apt</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">mintsystem: /usr/local/bin/apt</span> </p>
    <p class="Textbody">В отличие от стандартной утилиты apt, располагающейся в каталоге /usr/bin, apt для Mint находится в каталоге /usr/local/bin, что определяется такой командой:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ which apt</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/usr/local/bin/apt</span> </p>
    <p class="Textbody">При вводе в командной строке apt без указания пути вызывается именно она, что определяется значениями переменной PATH, определёнными в общесистемном конфиге /etc/login.defs:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ echo $PATH</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games</span> </p>
    <p class="Textbody">Так что для запуска стандартной утилиты apt из одноимённого пакета для неё следует указывать полный путь, например</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /usr/bin/apt list --installed</span> </p>
    <p class="Textbody">для вывода списка инсталлированных пакетов — это чуть ли не единственная функция стандартного инструментария пакета apt, отсутствующая в apt для Mint. Ибо последняя перекрывает почти все возможности утилит apt-get и apt-cache, большинство возможностей командного режима aptitude, а также выполняет некоторые функции низкоуровневой утилиты dpkg.</p>
    <p class="Textbody">Примечание. Утилита apt — не единственный компонент пакета mintsystem. Кроме неё, он включает ещё четыре утилиты (также располагающиеся в каталоге</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/usr/local/bin/search</span> </p>
    <p class="Textbody">): mint-md5sum, search, highlight и pastebin.</p>
    <p class="Textbody">К управлению пакетами некоторое отношение имеет только первая из них, предназначенная для подсчёта контрольных сумм. Так, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mint-md5sum opera-stable_26.0.1656.60_amd64.deb</span> </p>
    <p class="Textbody">выведет её для пакета opera-stable в таком виде:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/mint-md5sum_001.png">
        <img alt="Изображение263" class="frameGraphics" id="263graphic" src="http://alv.me/wp-content/img/im_cin_img/mint-md5sum_001.png" style="border:1.0px solid #000080;padding:0;width:375.82742px;height:132.84158px" />
      </a>
      <a id="a263graphic"></a>
      <a id="bkm263graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/02/mint-md5sum_001.png"> </a>
    </p>
    <p class="Textbody">О команде search говорилось в очерке про утилиты CLI. А об остальных двух для полноты картины скажу здесь же.</p>
    <p class="Textbody">Утилита pastebin предназначена для быстрого размещёния в Сети фрагментов текста, которые почему-либо нежелательно делать доступными каким-либо иным образом. Делается это через сервис, предоставляемый проектом Mint. Так, командная конструкция</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ echo 'Утилита pastebin предназначена для быстрого размещёния в Сети' | pastebin</span> </p>
    <p class="Textbody">даст ткакой вывод:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">http://paste.linuxmint.com/view/u5i0</span> </p>
    <p class="Textbody">То есть введённый фрагмент будет доступен по указанному в выводже адресу (например, через браузер). Правда, русскоязычный текст по умолчанию окажется там в кодировке ISO 8859-5, так что надо озаботься тем, чтобы браузер поддерживал перекодирование страницы на лету.</p>
    <p class="Textbody">Ну а утилита highlight обеспечивает подсветку произвольного текстового фрагмента, заданного как её аргумент. Например, командная конструкция</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ echo 'Утилита pastebin предназначена для быстрого размещёния в Сети' | highlight code</span> </p>
    <p class="Textbody">на выходе даст подсвеченным фрагмент code:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/highlight_001.png">
        <img alt="Изображение264" class="frameGraphics" id="264graphic" src="http://alv.me/wp-content/img/im_cin_img/highlight_001-572x121.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:122.82583px" />
      </a>
      <a id="a264graphic"></a>
      <a id="bkm264graphic"></a>
    </p>
    <p class="Textbody">Теоретически рассуждая, если вывод этой конструкции передать по конвейеру команде pastebin, то и в Сети соответствующий фроагмент будет размещён в «подсвеченном» виде. Однако эксперимент показал, что сервис проекта Mint этого не поддерживает.</p>
    <h3 id="toc134"><a id="RefHeading17101713816058"></a><a id="bkmRefHeading17101713816058"></a><a id="toc133"></a><a id="bkmtoc133"></a><a id="RefHeading5441136957987"></a><a id="bkmRefHeading5441136957987"></a><a id="bkmRefHeading5441136957987"></a><a id="bkmbkmRefHeading5441136957987"></a>Применение</h3>
    <p class="Textbody">Утилита apt для Mint запускается одноимённой командой CLI с указанием внутренней команды, определяющей цель действия и, в большинстве случаев, аргумента (аргументов), в качестве которых выступает имя пакетов (или имена — их может быть сколько угодно):</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt command pkgname1 ... pkgname#</span> </p>
    <p class="Textbody">Некоторые часто используемые внутренние команды apt аргументов не требуют.</p>
    <p class="Textbody">Полный список внутренних команд apt для Mint можно получить «голой» командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt</span> </p>
    <p class="Textbody">вывод которой выглядит следующим образом:</p>
    <p class="Textbody"><span style="background-color:#dddddd">apt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Usage: apt command [options]</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">       apt help command [options]</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Commands:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">autoclean       - Erase old downloaded archive files</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">autoremove      - Remove automatically all unused packages</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">build           - Build binary or source packages from sources</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">build-dep       - Configure build-dependencies for source packages</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">changelog       - View a package's changelog</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">check           - Verify that there are no broken dependencies</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">clean           - Erase downloaded archive files</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">contains        - List packages containing a file</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">content         - List files contained in a package</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">deb             - Install a .deb package</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">depends         - Show raw dependency information for a package</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dist-upgrade    - Perform an upgrade, possibly installing and removing packages</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">download        - Download the .deb file for a package</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dselect-upgrade - Follow dselect selections</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">held            - List all held packages</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">help            - Show help for a command</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">hold            - Hold a package</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">install         - Install/upgrade packages</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">policy          - Show policy settings</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">purge           - Remove packages and their configuration files</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">rdepends        - Show reverse dependency information for a package</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">reinstall       - Download and (possibly) reinstall a currently installed package</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">remove          - Remove packages</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">search          - Search for a package by name and/or expression</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">show            - Display detailed information about a package</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">source          - Download source archives</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">sources         - Edit /etc/apt/sources.list with nano</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">unhold          - Unhold a package</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">update          - Download lists of new/upgradable packages</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">upgrade         - Perform a safe upgrade</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">version         - Show the installed version of a package</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">                        This apt has Super Cow Powers</span> </p>
    <p class="Textbody">Здесь для начала следует сказать о внутренних командах version и help. Первая теоретически должны выводить номер текущей версии apt для Mint, но практически не выводит ничего — лишь пустую строку. Команда же help без аргументов выведет список внутренних команд, идентичный приведённому выше. При указании аргумента — любой из внутренних команд она выведет её эквиваленты для apt-cache, apt-get или dpkg. Например:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt help search</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">"apt search" is equivalent to "aptitude search"</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt help install</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">"apt install" is equivalent to "sudo apt-get install"</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt help deb</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">"apt deb" is equivalent to "sudo dpkg -i"</span> </p>
    <p class="Textbody">Внутренние команды apt для Mint можно разделить на три группы, которые предназначены для:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">получения информации о пакетах; </p>
      </li>
      <li>
        <p class="Textbody">установки и удаления отдельных бинарных пакетов; </p>
      </li>
      <li>
        <p class="Textbody">общего обновления системы </p>
      </li>
      <li>
        <p class="Textbody">работы с пакетами исходных текстов. </p>
      </li>
    </ol>
    <p class="Textbody">Команды первой группы могут быть выполнены обычным пользователем, второй и третьей — требуют прав администратора. Однако для получения их утилита apt для Mint не нуждается в команде sudo, данной явным образом: она автоматически вызывается при попытке исполнения соответствующих внутренних команд. Например:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt install geany</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">[sudo] password for alv:</span> </p>
    <p class="Textbody">Тем не менее, внутренние команды apt для Mint целесообразно рассмотреть по трём указанным группам.</p>
    <h3 id="toc135"><a id="RefHeading17121713816058"></a><a id="bkmRefHeading17121713816058"></a><a id="toc134"></a><a id="bkmtoc134"></a><a id="RefHeading5461136957987"></a><a id="bkmRefHeading5461136957987"></a><a id="bkmRefHeading5461136957987"></a><a id="bkmbkmRefHeading5461136957987"></a>Информация о пакетах</h3>
    <p class="Textbody">Пакетный менеджмент начинается с поиска нужного пакета, для чего предназначена внутренняя команда search, требующая аргумента в виде ключевого слова. Поиск по ключевому слову осуществляется в именах пакетов и их кратких описаниях (т.н. резюме). Например, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt search geany</span> </p>
    <p class="Textbody">отыщет одноимённый пакет для установки этого текстового редактора (называемого, однако, «Небольшой и быстрой IDE») и все его плагины:</p>
    <p class="Textbody"><span style="background-color:#dddddd">p   geany                           - Небольшая и быстрая IDE</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">v   geany-abi-69                    -</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">v   geany-api-216                   -</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   geany-common                    - Небольшая и быстрая IDE — общие файлы</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   geany-plugin-addons             - Различные дополнительные модули для Geany</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   geany-plugin-codenav            - Модуль навигации по коду для Geany</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   geany-plugin-xmlsnippets        - XMLSnippets plugin for Geany</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   geany-plugins                   - Набор плагинов для Geany</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">p   geany-plugins-common            - Набор плагинов для Geany (переводы)</span> </p>
    <p class="Textbody">Важное отличие от аналога — команды apt-cache search: apt search показывает основной пакета (i — установленный, p — не установленный или «чисто» удалённый, и так далее) и дополнительный (A — автоматически установленный, h — с фиксированной версией, и так далее) статусы пакетов.</p>
    <p class="Textbody">Внутренняя команда held позволяет отсортировать пакеты с фиксированной версией, то есть те, которые не будут обновляться по команде apt upgrade (о ней буде сказано в следующем разделе).</p>
    <p class="Textbody">Подробную информацию об отдельном пакете можно получить с помощью внутренней команды show. Например,</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt show geany</span> </p>
    <p class="Textbody">выведет следующее:</p>
    <p class="Textbody"><span style="background-color:#dddddd">Пакет: geany</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Состояние: не установлен</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Версия: 1.23.1+dfsg-1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Приоритет: необязательный</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Раздел: universe/devel</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Сопровождающий: Ubuntu Developers &lt;ubuntu-devel-discuss@lists.ubuntu.com&gt;</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Архитектура: amd64</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Размер в распакованном виде: 2671 k</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Зависимости: libc6 (&gt;= 2.15), libcairo2 (&gt;= 1.6.0), libgcc1 (&gt;= 1:4.1.1),</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">                        libgdk-pixbuf2.0-0 (&gt;= 2.22.0), libglib2.0-0 (&gt;=</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">                        2.35.9), libgtk2.0-0 (&gt;= 2.22.0), libpango1.0-0 (&gt;=</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">                        1.18.0), libstdc++6 (&gt;= 4.1.1), geany-common (=</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">                        1.23.1+dfsg-1)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Пред-зависимости: multiarch-support</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Предлагает: libvte9, doc-base</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Конфликтует: geany</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Повреждает: geany-plugins-common (&lt; 0.21), geany-plugins-common (&lt; 0.21)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Предоставляет: geany-abi-69, geany-api-216</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Описание: Небольшая и быстрая IDE</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> Geany — нетребовательная к ресурсам интегрированная среда разработки программ,</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> маленькая и быстрая, с небольшим количеством зависимостей от других пакетов.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> использует только GTK2, поэтому для запуска Geany необходимы только</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> runtime-библиотеки GTK2.</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> The basic features of Geany are:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> * syntax highlighting</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> * code completion</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> * auto completion of constructs like if, for and while, XML and HTML</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> * call tips</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> * folding</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> * many supported filetypes like C, Java, PHP, HTML, Python, Perl, Pascal</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> * symbol lists</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> * embedded terminal emulation</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Сайт: http://www.geany.org</span> </p>
    <p class="Textbody">А сведения о смене версий пакета получаются с помощью внутренней команды changelog. Для Geany это выглядит так:</p>
    <p class="Textbody"><span style="background-color:#dddddd">geany (1.23.1+dfsg-1) unstable; urgency=low</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  * [3b1ced4] Imported Upstream version 1.23.1+dfsg</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  * [b418909] Update debian-branch in gbp.conf</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> — Chow Loong Jin &lt;hyperair@debian.org&gt;  Mon, 20 May 2013 00:18:56 +0800</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">geany (1.23+dfsg-2) unstable; urgency=low</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  * Upload to unstable, fixes FTBFS (Closes: #707368)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  * [a472a80] Enable parallel builds</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  * [17a6378] No-change bump of Standards-Version to 3.9.4</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  * [ea78f31] Add README.source describing git branch structure</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> — Chow Loong Jin &lt;hyperair@debian.org&gt;  Fri, 10 May 2013 15:27:35 +0800</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">И так далее.</p>
    <p class="Textbody">Более подробные, нежели вывод команды show, сведения о зависимостях пакета даёт пара внутренних команд depends и rdepends. Первая выводит полный список пакетов, от которых зависит заданный в качестве её аргумента — жёстких, рекомендуемых, предлагаемых и конфликтующих:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt depends geany</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">geany</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Зависит: libc6</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Зависит: libcairo2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Зависит: libgcc1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Зависит: libgdk-pixbuf2.0-0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Зависит: libglib2.0-0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Зависит: libgtk2.0-0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Зависит: libpango1.0-0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Зависит: libstdc++6</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Зависит: geany-common</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  ПредЗависит: multiarch-support</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">    multiarch-support:i386</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Предлагает: libvte9</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Предлагает: doc-base</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Ломает: geany-plugins-common</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Ломает: &lt;geany-plugins-common:i386&gt;</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">  Конфликтует: geany:i386</span> </p>
    <p class="Textbody">Команда же rdepends решает обратную задачу — выводит список пакетов, зависящих от данного:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt depends geany</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">geany</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Reverse Depends:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany:i386</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugins-common</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugins</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-xmlsnippets</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-webhelper</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-vc</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-updatechecker</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-treebrowser</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-tableconvert</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-spellcheck</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-shiftcolumn</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-sendmail</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-scope</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-prj</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-prettyprinter</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-pg</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-numberedbookmarks</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-multiterm</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-miniscript</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-markdown</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-macro</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-lua</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-lipsum</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-latex</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-insertnum</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-gproject</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-geniuspaste</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-gendoc</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-extrasel</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-doc</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-devhelp</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-debugger</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-commander</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-codenav</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-plugin-addons</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-common</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-common</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"> |deb-gview</span> </p>
    <p class="Textbody">Все приведённые выше внутренние команды дают информацию как об установленных пакетах, так и о пакетах, доступных в подключённых репозиториях. А вот команды contains и content работают только для установленных пакетов. Первая позволяет определить, к какому пакету принадлежит данный файл — именно таким способом была определена выше принадлежность утитлиты apt:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt contains /usr/local/bin/apt</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">mintsystem: /usr/local/bin/apt</span> </p>
    <p class="Textbody">А команда content выводит список всех файлов пакета с указанием их положения в файловой иерархии:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt content mintsystem</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/etc</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/etc/apt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/etc/apt/preferences.d</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/etc/apt/preferences.d/official-extra-repositories.pref</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/etc/bash_completion.d</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/etc/bash_completion.d/apt-linux-mint</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/etc/init.d</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/etc/init.d/mintsystem</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/usr/share/nemo</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/usr/share/nemo/actions</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/usr/share/nemo/actions/mint-md5sum.nemo_action</span> </p>
    <p class="Textbody">Наконец, последняя из «информационных» команд — policy. При указании в качестве аргумента имени установленного пакета она выводит такую о нём информацию:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt policy mintsystem</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">mintsystem:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Установлен: 7.9.7</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Кандидат:   7.9.7</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Таблица версий:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> *** 7.9.7 0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        700 http://linux-mint.froonix.org/ rebecca/main amd64 Packages</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        100 /var/lib/dpkg/status</span> </p>
    <p class="Textbody">А для пакета не установленного она будет такой:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt policy geany</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">geany:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Установлен: (отсутствует)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Кандидат:   1.23.1+dfsg-1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Таблица версий:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">     1.23.1+dfsg-1 0</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        500 http://gd.tuwien.ac.at/opsys/linux/ubuntu/archive/ trusty/universe amd64 Packages</span> </p>
    <p class="Textbody">Где числе перед URL — приоритет репозитория, в который входит пакет, оно берётся из файлов каталога /etc/apt/preferences.d. Большее число соовтетствует более высокому приоритету.</p>
    <p class="Textbody">Внутренняя команда policy была придумана для утилиты apt-cache дистрибутива Debian, где использовалась для управления приоритетами при совмещёнии в одной системе пакетов из его многочисленных веток — stable, testing, unstable, experimental. Не уверен, что она востребована в дистрибутиве Mint.</p>
    <h3 id="toc136"><a id="RefHeading17141713816058"></a><a id="bkmRefHeading17141713816058"></a><a id="toc135"></a><a id="bkmtoc135"></a><a id="RefHeading5481136957987"></a><a id="bkmRefHeading5481136957987"></a><a id="bkmRefHeading5481136957987"></a><a id="bkmbkmRefHeading5481136957987"></a>Работа с бинарными пакетами</h3>
    <p class="Textbody">Главное действие в отношении пакетов, которые были сочтены полезными — их установка. А основным инструментом установки является внутренняя команда install. В качестве аргументов она принимает имена пакетов — те самые, которые были найдены командой apt search и в полезности которых можно было убедиться командой apt show. Например, для установки чрезвычайно полезного текстового редактора Geany следует дать команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install geany</span> </p>
    <p class="Textbody">которая сначала запросит пароль пользователя с административным типом аккаунта:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">[sudo] password for alv:</span> </p>
    <p class="Textbody">А затем, после считывания локального списка пакетов и построения дерева зависимостей, сообщит о необходимости таковых, объёме скачиваемых пакетов и увеличении занятого дискового пространства после установки, запросив подтверждение серьёзности намерений:</p>
    <p class="Textbody"><span style="background-color:#dddddd">Чтение списков пакетов… Готово</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Построение дерева зависимостей</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Чтение информации о состоянии… Готово</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Будут установлены следующие дополнительные пакеты:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-common</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">НОВЫЕ пакеты, которые будут установлены:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany geany-common</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">обновлено 0, установлено 2 новых пакетов, для удаления отмечено 0 пакетов, и 37 пакетов не обновлено.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Необходимо скачать 3808 kБ архивов.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">После данной операции, объём занятого дискового пространства возрастёт на 9872 kB.</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Хотите продолжить? [Д/н]</span> </p>
    <p class="Textbody">Согласие предполагается по умолчанию, так что тут достаточно нажать Enter. После чего начинается скачивание пакетов из содержащего их репозитория, распаковка и инкорпорация компонентов в файловую иерархию, а также регистрация в базе данных и включение, если требуется, исполняемого файла в главное меню (для Geany — в секцимю Прграммирование, так как эта программа позиционируется её авторами как IDE — Integrated Development Environment, то есть интегрированная среда разработки). Основной статус пакета geany изменится на «установленный»:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt search geany | head -n 1</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">i   geany           - Небольшая и быстрая IDE</span> </p>
    <p class="Textbody">А пакет geany-common приобретёт ещё и статус автоматически установленного:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt search geany-common</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">i A geany-common    - Небольшая и быстрая IDE — общие файлы</span> </p>
    <p class="Textbody">Если в системе уже был установлен данный пакет более старой версии — он будет обновлён. А вот переустановить пакет той же версии (например, если он был безнадёжно испорчен в ходе экспериментов) команда install откажется, сообщив, что</p>
    <p class="Textbody"><span style="background-color:#dddddd">Уже установлена самая новая версия geany.</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">обновлено 0, установлено 0 новых пакетов, для удаления отмечено 0 пакетов, и 37 пакетов не обновлено.</span> </p>
    <p class="Textbody">Однако на этот предмет существует специальная команда reinstall, аргументом которой указывается установленный пакет, нуждающийся в исправлении.</p>
    <p class="Textbody">Локально отдельные пакеты могут быть установлены с помощью внутренней команды deb, аргументом которой должно быть полное имя файла пакета, если нужно, с указанием пути. Например, команда</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt deb sublime-text_3065_amd64.deb</span> </p>
    <p class="Textbody">установит текстовый редактор Sublime — разумеется, предварительно файл этого пакета должен быть скачан.</p>
    <p class="Textbody">Поскольку внутренняя команда deb — полный эквивалент конструкции sudo dpkg -i, она не занимается разрешением зависимостей, а только сообщает об их нарушении. Например, попытка установить в окружении Cinnamon файловый менджер Caja из среды MATE вызовет следующие сообщения:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt deb caja_1.8.2-0+rebecca_amd64.deb</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Выбор ранее не выбранного пакета caja.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">(Чтение базы данных … на данный момент установлен 188621 файл и каталог.)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Preparing to unpack caja_1.8.2-0+rebecca_amd64.deb ...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Unpacking caja (1.8.2-0+rebecca) ...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dpkg: зависимости пакетов не позволяют настроить пакет caja:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> caja зависит от libcaja-extension1 (= 1.8.2-0+rebecca), однако:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Пакет libcaja-extension1 не установлен.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> caja зависит от libmate-desktop-2-17, однако:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Пакет libmate-desktop-2-17 не установлен.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> caja зависит от mate-desktop, однако:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Пакет mate-desktop не установлен.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> caja зависит от caja-common (= 1.8.2-0+rebecca), однако:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Пакет caja-common не установлен.</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">dpkg: error processing package caja (--install):</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> проблемы зависимостей — оставляем не настроенным</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Processing triggers for man-db (2.6.7.1-1ubuntu1) ...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Processing triggers for mime-support (3.54ubuntu1.1) ...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Processing triggers for gnome-menus (3.10.1-0ubuntu2) ...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Processing triggers for desktop-file-utils (0.22-1ubuntu1) ...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Processing triggers for ubuntu-system-adjustments (2014.11.19) ...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">При обработке следующих пакетов произошли ошибки:</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"> caja</span> </p>
    <p class="Textbody">В отличие от внутренней команды install, команда deb не только обновит пакет до более новой версии, но и переустановит его версию текущую.</p>
    <p class="Textbody">Установленные пакеты иногда требуется и удалять. Этой цели в apt для Mint служат две внутренние команды — remove и purge, аргументами которых служат, очевидно, имена удаляемых пакетов. Первая удаляет файлы пакета, но сохраняет его общесистемные конфиги, вторая — удаляет также и их. Различие между ними отражается в основном статусе удалённого пакета — в первом случае его значение будет c, во втором — p, как и у пакетов, которые никогда не устанавливались.</p>
    <p class="Textbody">И remove, и purge автоматически удаляют все зависимые пакеты, список их выводится после ввода пользовательского пароля:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt purge libreoffice-impress</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">[sudo] password for alv:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Чтение списков пакетов… Готово</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Построение дерева зависимостей</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Чтение информации о состоянии… Готово</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Пакеты, которые будут УДАЛЕНЫ:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  libreoffice-impress* libreoffice-ogltrans*</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  libreoffice-presentation-minimizer*</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">обновлено 0, установлено 0 новых пакетов, для удаления отмечено 3 пакетов, и 5 пакетов не обновлено.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">После данной операции, объём занятого дискового пространства уменьшится на 6031 kB.</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Хотите продолжить? [Д/н]</span> </p>
    <p class="Textbody">Список удаляемых пакетов нужно читать очень внимательно, чтобы случайно не удалить что-нибудь жизненно необходимое.</p>
    <p class="Textbody">Пакеты, от которых зависит удаляемый, автоматически не удаляются ни remove, ни purge. В этом случае apt предлагает воспользоваться внутренней командой autoremove для очистки системы от «осиротелых» зависимостей:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt purge geany</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Чтение списков пакетов… Готово</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Построение дерева зависимостей</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Чтение информации о состоянии… Готово</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Следующий пакет устанавливался автоматически и больше не требуется:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany-common</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Для его удаления используйте «apt-get autoremove».</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Пакеты, которые будут УДАЛЕНЫ:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  geany*</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">обновлено 0, установлено 0 новых пакетов, для удаления отмечено 1 пакетов, и 5 пакетов не обновлено.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">После данной операции, объём занятого дискового пространства уменьшится на 2671 kB.</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Хотите продолжить? [Д/н]</span> </p>
    <p class="Textbody">Разумеется, в нашем случае мы обращаемся не к команде apt-get, всё в той же утилите apt для Mint:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt autoremove</span> </p>
    <p class="Textbody">Она не нуждается в аргументах и выполняет свою работу молча, не задавая вопросов. Перед её выполнением не вредно выполнить другую внутреннюю команду — check, проверяющую систему на предмет «сломанных» зависимостей.</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">apt check</span> </p>
    <p class="Textbody">[~]<br />Что при хорошем раскладе после ввода пароля должно дать такой результата:</p>
    <p class="Textbody"><span style="background-color:#dddddd">Чтение списков пакетов… Готово</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Построение дерева зависимостей</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Чтение информации о состоянии… Готово</span> </p>
    <p class="Textbody">А при плохом... плохого у меня до сих пор не было.</p>
    <p class="Textbody">Перед установкой пакетов из репозитория они предварительно скачиваются и помещаются в каталог /var/cache/apt/archives/. Со временем файлов пакетов накапливается много, а нужны они бывают только в исключительных случаях. Для избавления от них существуют в apt для Mint предусмотрены команды autoclean и clean. Первая удаляет из кеша только пакеты устаревших версий, сохраняя те, версии которых установлены в системе. Вторая же полностью очищает каталог /var/cache/apt/archives/.</p>
    <h3 id="toc137"><a id="RefHeading17161713816058"></a><a id="bkmRefHeading17161713816058"></a><a id="toc136"></a><a id="bkmtoc136"></a><a id="RefHeading5501136957987"></a><a id="bkmRefHeading5501136957987"></a><a id="bkmRefHeading5501136957987"></a><a id="bkmbkmRefHeading5501136957987"></a>Обновление системы</h3>
    <p class="Textbody">Сказанное выше касалось единичных пакетов или их серий — любая из перечисленных субкоманд принимает любое количество аргументов. Однако в утилите apt предусмотрены и внутренние команды для общего обновления пакетов, а также для тотального системы. Однако, прежде чем выполнить любую из них, необходимо провести обновление локального кеша пакетов, то есть получить списки новых и обновлённых пакетов. Делается это внутренней командой update:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt update</span> </p>
    <p class="Textbody">Её же в обязательном порядке следует выполнять после каждого изменения в репозиториях — подключения новых или отключения имевшихся. Теоретически для редактирования списков репозиториев в apt для Mint предназначена команда sources. Однако практически она бесполезна, так как вызывает текстовый редактор по умолчанию (nano) для редактирования /etc/apt/sources.list. В нашем же дистрибутиве этот файл содержит только репозиторий локального оптического диска, а все реально подключённые репозитории описываются в файлах каталога /etc/apt/sources.list.d.</p>
    <p class="Textbody">Для обновления всех, по возможности, пакетов установленной системы в apt для Mint существует внутренняя команда upgrade. Она выявит все пакеты, для которых в репозиториях доступны более свежие версии, выведет их список, объём для скачивания и прирост объёма занятого дискового пространства после выполнения процедуры, а также запросит подтвержения:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt upgrade</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Чтение списков пакетов… Готово</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Построение дерева зависимостей</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Чтение информации о состоянии… Готово</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Расчёт обновлений…Готово</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Пакеты, которые будут обновлены:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  gir1.2-gudev-1.0 libegl1-mesa libegl1-mesa-drivers libgbm1</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">…</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">обновлено 35, установлено 0 новых пакетов, для удаления отмечено 0 пакетов, и 0 пакетов не обновлено.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Необходимо скачать 36,3 MБ архивов.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">После данной операции, объём занятого дискового пространства возрастёт на 124 kB.</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Хотите продолжить? [Д/н]</span> </p>
    <p class="Textbody">В ходе выполнения upgrade обновляются по возможности все пакеты, за исключением тех, для разрешения зависимостей которых обновление потребует доустановки новых пакетов или удаления существующих. Для таких пакетов текущие версии будут сохранены.</p>
    <p class="Textbody">При использовании команды upgrade следует учитывать, что она обновляет в том числе и те компоненты, которые по умолчанию заблокированы для обновления через фирменный инструмент mintupdate — ядро и всё, что с ним связано, glibc, и так далее (пакеты уровней 4 и 5). Так что, прежде чем применять эту команду, следует либо всё взвесить и решиться на обновление указанных компонентов, либо явным образом зафиксировать их версии.</p>
    <p class="Textbody">Фиксация версий пакетов может потребоваться и в ряде других случаев — например, при использовании более неподдерживаемых, но по прежнему необходимых пакетов, пакетов, пересобранных с собственными опциями, и ещё некоторых. Она выполняется внутренней командой hold с указанием имени фиксируемого пакета (пакетов). После чего пакет приобретает основной статус h и не затрагивается обновлениями. Обратная процедура, то есть снятие фиксации, если в ней пропала необходимость, выполняется внутренней командой unhold.</p>
    <p class="Textbody">Для тотального обновления системы предназначена внутренняя команда dist-upgrade: она не только обновляет все пакеты, для которых обновления доступны, но может доустанавливать новые пакеты и удалять существующие, если это необходимо для разрешения зависимостей. Эта субкоманда применяется, например, при смене релиза дистрибутива — например, для перехода с Mint 17.0 Qiana на 17.1 Rebecca достаточно прописать одноимённые репозитории в файлах их описаний. И после этого дать команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt dist-upgrade</span> </p>
    <p class="Textbody">Есть и ещё несколько случаев, требующих применения dist-upgrade, а не просто upgrade — например, обновление версии рабочей среды (в данном случае Cinnamon) и некоторых других базовых компонентов системы.</p>
    <p class="Textbody">При тотальном обновлении через dist-upgrade следует помнить о том, что выше было сказано про upgrade. И если в данном случае обновление базовых компонентов системы (ядра etc.) необходимо, то о фиксации самосборных и неподдерживаемых пакетов посредством команды hold нужно позаботиться заблаговременно.</p>
    <p class="Textbody">В apt для Mint предусмотрена ещё одна внутренняя команда общего обновления — dselect-upgrade, эквивалентная конструкции sudo apt-get dselect-upgrade. Она выполняет обновление в соответствие со статусом пакетов, установленным по умолчанию для древней утилиты dselect — предшественницы aptitude. Поскольку самой этой утилиты в стандартной инсталляции Mint нет, изменить (и даже посмотреть эти умолчания затруднительно). Так что я бы воздержался от использования dselect-upgrade, тем более что ни малейшей необходимости обращаться к ней нет.</p>
    <h3 id="toc138"><a id="RefHeading17181713816058"></a><a id="bkmRefHeading17181713816058"></a><a id="toc137"></a><a id="bkmtoc137"></a><a id="RefHeading5521136957987"></a><a id="bkmRefHeading5521136957987"></a><a id="bkmRefHeading5521136957987"></a><a id="bkmbkmRefHeading5521136957987"></a>Работа с пакетами исходных текстов</h3>
    <p class="Textbody">Всё сказанное выше относилось к бинарным пакетам. Однако в утилите apt предусмотрены и средства для работы с пакетами исходных текстов. Так, с помощью внтуренней команды source можно просто скачать пакет, указанный в качестве её аргумента — разумеется, для этого должен быть подключён репозиторий исходников. Внутренняя команда build (эквивалент sudo dpkg-buildpackage) выполнит построение бинарного пакета (что требует соответствующего инструментария в установленном виде). А внутренняя команда build-dep ограничится конфигурированием необходимых для этого зависимостей, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">apt build-dep ubuntu-zfs</span> </p>
    <p class="Textbody">Это потребовалось мне в Rebecca 17.1 при сборке пакетов поддержки ZFS on Linux.</p>
    <h3 id="toc139"><a id="RefHeading17201713816058"></a><a id="bkmRefHeading17201713816058"></a><a id="toc138"></a><a id="bkmtoc138"></a><a id="RefHeading5541136957987"></a><a id="bkmRefHeading5541136957987"></a><a id="bkmRefHeading5541136957987"></a><a id="bkmbkmRefHeading5541136957987"></a>Итог</h3>
    <p class="Textbody">Можно видеть, что и по части манипулирования пакетами возможности утилиты apt широки и многогранны. То есть это действительно универсальное средство управления пакетами, в обыденной жизни способное почти всегда заменить все прочие — от низкоуровневой dpkg (обращение к которой потребуется только в исключительных случаях) до графического front-end'а — Synaptic'а. Ибо не уступает последнему в наглядности вывода информации о пакетах, позволяя манипулировать ими проще и быстрее. Рядом с apt для Mint его тёзка из одномиённого пакета (общего для всех deb based дистрибутивов) Debian/Ubuntu выглядит ограниченным функционально, а традиционные apt-cache и apt-get — несколько усложнёнными синтаксически. Что же до aptitude, то она в этом контексте кажется вообще излишней: apt для Mint обеспечивает почти все функции её командного режима, а в интерактивном режиме эта программа в дистрибутивах семейства Ubuntu и её клонах уже давно работает не вполне корректно.</p>
    <h3 id="toc140"><a id="RefHeading17221713816058"></a><a id="bkmRefHeading17221713816058"></a><a id="toc139"></a><a id="bkmtoc139"></a><a id="RefHeading5561136957987"></a><a id="bkmRefHeading5561136957987"></a><a id="bkmRefHeading5561136957987"></a><a id="bkmbkmRefHeading5561136957987"></a>Примечание: кратко об apt из APT</h3>
    <p class="Textbody">Если apt-cache и apt-get полностью заменяются утилитой apt для Mint, то, как ни странно, apt из одноимённого пакета имеет некоторые дополнительные функции, и потому заслуживает хоть и краткого, но рассмотрения. Как уже говорилось, в нашем дистрибутиве его следует запускать с указанием полного пути:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /usr/bin/apt</span> </p>
    <p class="Textbody">В приведённом виде эта команда выведет справку о внутренних командах этой утилиты — краткую, но вполне достаточную:</p>
    <p class="Textbody"><span style="background-color:#dddddd">CLI for apt.</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Basic commands:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> list - list packages based on package names</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> search - search in package descriptions</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> show - show package details</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> update - update list of available packages</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> install - install packages</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> remove  - remove packages</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> upgrade - upgrade the system by installing/upgrading packages</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> full-upgrade - upgrade the system by removing/installing/upgrading packages</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"> edit-sources - edit the source information file</span> </p>
    <p class="Textbody">Назначение большинства внутренних команд понятно без комментариев, из их имён и сопуствующих пояснений: search, show, install, remove, update и upgrade суть аналоги одноимённых внутренних команд apt для Mint (а также apt-cache и apt-search), full-upgrade идентична команде dist-upgrade, а edit-sources — команде sources.</p>
    <p class="Textbody">Так что единственной внутренней командой, не имеющей аналогов ни в связке apt-cache и apt-search, ни в apt для Mint, оказывается list. Но зато командой очень полезной:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">с опцией --installed она выводит список установленных пакетов (который иначе можно получить только командой dpkg -l или всякими конструкциями с grep); </p>
      </li>
      <li>
        <p class="Textbody">опция --upgradable выводит список пакетов, для которых имеются обновления; </p>
      </li>
      <li>
        <p class="Textbody">опция же --all-versions выдаёт на гора полный список доступных пакетов, специально отмечая установленные. </p>
      </li>
    </ul>
    <p class="Textbody">Тот же результат достигается командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ /usr/bin/apt list</span> </p>
    <p class="Textbody">без всяких опций. Так что внутренняя команда list в ряде случаев оказывается востребованной, почему я и придумал для неё специальный глобальный псевдоним в конфиге ~/.zshrc.</p>
    <h2 id="toc141"><a id="RefHeading17241713816058"></a><a id="bkmRefHeading17241713816058"></a><a id="toc140"></a><a id="bkmtoc140"></a><a id="RefHeading12781136957987"></a><a id="bkmRefHeading12781136957987"></a><a id="bkmRefHeading12781136957987"></a><a id="bkmbkmRefHeading12781136957987"></a>Управление пакетами: Synaptic</h2>
    <p class="Textbody">Система управления пакетами Synaptic — графический фронт-энд для утилит семейства APT, обычно используемыми для работы с пакетами deb-формата, а в некоторых дистрибутивах — и с пакетами rpm.</p>
    <h3 id="toc142"><a id="RefHeading17261713816058"></a><a id="bkmRefHeading17261713816058"></a><a id="toc141"></a><a id="bkmtoc141"></a><a id="RefHeading5581136957987"></a><a id="bkmRefHeading5581136957987"></a><a id="bkmRefHeading5581136957987"></a><a id="bkmbkmRefHeading5581136957987"></a>Введение</h3>
    <p class="Textbody">Как ни странно, Synaptic появился не в Debian, и вообще не в deb based системах: первые его версии были созданы в бразильском дистрибутиве Connectiva — том самом, разработчики которого впервые прикрутили apt-get для управления rpm-пакетами (под именем apt-rpm).Создателем Synaptic’а был Альфредо Кодзима (Alfredo Kojima), а позднее им занимался Густаво Нимейер (Gustavo Niemeyer), оба являвшиеся тогда, на рубеже тысячелетий, сотрудниками фирмы Connectiva. И именно и исключительно фронт-эндом к apt-rpm и выступал Synaptic в начальную пору своей жизни.</p>
    <p class="Textbody">После покупки Connectiva фирмой Mandrakesof (в январе 2005 года) связка apt-rpm и Synaptic была благополучно похерена в недрах объединённой Mandriva — в пользу собственных инструментов, urpmi и rpmdrake. Однако сама идея оказалась очень продуктивной — и ещё в 2001 году Михаэль Фогт (Michael Vogt) «дебианизировал» Synaptic, приспособив его для работы с собственно deb-пакетами. Хотя Фогт и по сей день является основным майнтайнером upstream-версии пакета, среди пользователей Debian’а, насколько мне известно, он широкого распространения не получил — предпочтение здесь отдавалось сначала собственно apt-утилитам, а затем и поныне — aptitude.</p>
    <p class="Textbody">Звёздный час Synaptic’а наступил с появлением в октябре 2004 года первой версии Ubuntu. Будучи основанным на библиотеке Gtk, он сразу и гармонично вписался в тогдашнее GNOME-окружение этого дистрибутива. А с возникновением в ноябре 2006 года Mint был включён в состав этого дистрибутива, чтобы с тех пор верой и правдой служить во всех его вариантах, включая даже KDE-редакцию. И, хотя здесь он «снизу» подпирается собственной, чрезвычайно функциональной реализацией apt, а «сверху» перекрывается Менеджером программ, в ряде случаев Synaptic оказывается самым эффективным средством для работы с пакетами.</p>
    <h3 id="toc143"><a id="RefHeading17281713816058"></a><a id="bkmRefHeading17281713816058"></a><a id="toc142"></a><a id="bkmtoc142"></a><a id="RefHeading5601136957987"></a><a id="bkmRefHeading5601136957987"></a><a id="bkmRefHeading5601136957987"></a><a id="bkmbkmRefHeading5601136957987"></a>Обзор</h3>
    <p class="Textbody">Как только что говорилось, Synaptic — это интегрирующая надстройка над утилитами семейства apt, но не над Mint'овской реализацией apt. Тем не менее, он предоставляет все функции, обеспечиваемые последней, а также командами apt-get и apt-cache. В их числе:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">поиск пакетов в репозиториях с определением их состояния и статуса; </p>
      </li>
      <li>
        <p class="Textbody">их установку и обновление с автоматическим разрешением зависимостей; </p>
      </li>
      <li>
        <p class="Textbody">удаление пакетов, в том числе и включая их зависимости; </p>
      </li>
      <li>
        <p class="Textbody">обновление базы данных пакетов из репозитория; </p>
      </li>
      <li>
        <p class="Textbody">тотальное обновление системы. </p>
      </li>
    </ul>
    <p class="Textbody">Кроме того, Synaptic включает средства настройки — в частности, доступа к репозиториям. В Mint для этой цели вызывается собственная утилита smintsource.</p>
    <p class="Textbody">Запуск Synaptic’а выполняется через главное меню панели приложений (Администрирование -&gt; Менеджер пакетов Synaptic) или любым другим традиционным для Mint способом.</p>
    <p class="Textbody">Очевидно, что установка и удаление пакетов потребует прав администратора, запрос на получение каковых (посредством механизма sudo, то есть с вводом пользовательского пароля) и последует после вызова Synaptic’а через меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_001.png">
        <img alt="Изображение265" class="frameGraphics" id="265graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_001-572x265.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:266.82584px" />
      </a>
      <a id="a265graphic"></a>
      <a id="bkm265graphic"></a>
    </p>
    <p class="Textbody">Если отказаться от ввода пароля, то Synaptic таким способом запущен не будет. Однако его таки можно запустить и от лица обычного пользователя — из командной строки терминала или минитерминала прямой командой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ synaptic</span> </p>
    <p class="Textbody">В этом случае появится такое предупреждение:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_002.png">
        <img alt="Изображение266" class="frameGraphics" id="266graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_002-572x185.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:186.85103px" />
      </a>
      <a id="a266graphic"></a>
      <a id="bkm266graphic"></a>
    </p>
    <p class="Textbody">Из которого явствует, что запущенный в пользовательском режиме Synaptic можно использовать для поиска пакетов и получения информации о них.Тем не менее, нормальный режим работы Synaptic’а — административный. И после ввода пароля пользователя (надо отметить, что по умолчанию во время появления панели для его ввода экран пригасает, а все управляющие элементы интерфейса блокируются) появляется окно примерно такого вида:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_003.png">
        <img alt="Изображение267" class="frameGraphics" id="267graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_003-572x382.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:383.84px" />
      </a>
      <a id="a267graphic"></a>
      <a id="bkm267graphic"></a>
    </p>
    <p class="Textbody">Как явствует из скриншота, в окне Synaptic’а мы имеем следующие основные элементы интерфейса:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">строку меню; </p>
      </li>
      <li>
        <p class="Textbody">панель инструментальных кнопок; </p>
      </li>
      <li>
        <p class="Textbody">два главных фрейма — список разделов репозитория и список пакетов выбранного раздела (по умолчанию показываются все пакеты); </p>
      </li>
      <li>
        <p class="Textbody">фрейм с кнопками выбора критериев для вывода пакетов; </p>
      </li>
      <li>
        <p class="Textbody">фрейм свойств конкретного пакета. </p>
      </li>
    </ul>
    <p class="Textbody">Последний фрейм пуст, если в правом главном фрейме не отмечен ни один пакет, как на предыдущем скриншоте. Но заполняется контентом при свершении выбора: в правом нижнем фрейме мы увидим описание пакета (если доступно, на русском)</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_004.png">
        <img alt="Изображение268" class="frameGraphics" id="268graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_004-572x382.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:383.84px" />
      </a>
      <a id="a268graphic"></a>
      <a id="bkm268graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_004.png"> </a>
    </p>
    <p class="Textbody">Если при этом нажать на кнопку Получить снимок экрана — то появится скриншот соответствующего пакета (буде таковой существует и имеет смысл):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_005.png">
        <img alt="Изображение269" class="frameGraphics" id="269graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_005-572x355.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:356.8542px" />
      </a>
      <a id="a269graphic"></a>
      <a id="bkm269graphic"></a>
    </p>
    <p class="Textbody">А при правом клике на имени пакета появляется контекстное меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_006.png">
        <img alt="Изображение270" class="frameGraphics" id="270graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_006.png" style="border:1.0px solid #000080;padding:0;width:435.84628px;height:269.84946px" />
      </a>
      <a id="a270graphic"></a>
      <a id="bkm270graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_006.png"> </a>
    </p>
    <p class="Textbody">Здесь-то, в пункте Свойства, и содержится главная информация о пакете — общие сведения</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_007.png">
        <img alt="Изображение271" class="frameGraphics" id="271graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_007-526x572.png" style="border:1.0px solid #000080;padding:0;width:527.84px;height:573.83685px" />
      </a>
      <a id="a271graphic"></a>
      <a id="bkm271graphic"></a>
    </p>
    <p class="Textbody">перечень зависимостей</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_008.png">
        <img alt="Изображение272" class="frameGraphics" id="272graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_008-526x572.png" style="border:1.0px solid #000080;padding:0;width:527.84px;height:573.83685px" />
      </a>
      <a id="a272graphic"></a>
      <a id="bkm272graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_008.png"> </a>
    </p>
    <p class="Textbody">список установленных файлов и путей к ним (доступно только для установленных пакетов)</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_009.png">
        <img alt="Изображение273" class="frameGraphics" id="273graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_009-526x572.png" style="border:1.0px solid #000080;padding:0;width:527.84px;height:573.83685px" />
      </a>
      <a id="a273graphic"></a>
      <a id="bkm273graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_009.png"> </a>
    </p>
    <p class="Textbody">доступные версии</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_010.png">
        <img alt="Изображение274" class="frameGraphics" id="274graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_010-526x572.png" style="border:1.0px solid #000080;padding:0;width:527.84px;height:573.83685px" />
      </a>
      <a id="a274graphic"></a>
      <a id="bkm274graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_010.png"> </a>
    </p>
    <p class="Textbody">и, наконец, описание пакета</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_011.png">
        <img alt="Изображение275" class="frameGraphics" id="275graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_011-526x572.png" style="border:1.0px solid #000080;padding:0;width:527.84px;height:573.83685px" />
      </a>
      <a id="a275graphic"></a>
      <a id="bkm275graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_011.png"> </a>
    </p>
    <p class="Textbody">Теперь пробежимся по критериям вывода пакетов. С группировкой пакетов по разделам всё более-менее ясно, тем более, что названия разделов почти все даны в русском переводе, а те немногие, что оставлены в оригинале (например, World Wide Web), и без перевода понятны.Следующий критерий отбора — по состоянию пакетов. После нажатия соответствующей кнопки в левом главном фрейме выводятся следующие категории:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Все; </p>
      </li>
      <li>
        <p class="Textbody">Не установленные; </p>
      </li>
      <li>
        <p class="Textbody">Не установленные (остались файлы настроек); </p>
      </li>
      <li>
        <p class="Textbody">Установленные; </p>
      </li>
      <li>
        <p class="Textbody">Установленные (вручную); </p>
      </li>
      <li>
        <p class="Textbody">Установленные (локально или устаревшие); </p>
      </li>
      <li>
        <p class="Textbody">Установленные (обновляемые). </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_012.png">
        <img alt="Изображение276" class="frameGraphics" id="276graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_012-572x382.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:383.84px" />
      </a>
      <a id="a276graphic"></a>
      <a id="bkm276graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_012.png"> </a>
    </p>
    <p class="Textbody">По происхождению пакеты разделяются на установленные локально (то есть с инсталляционного носителя или предварительно скачанные на диск) и из различных репозиториев — rebecca, trusty, PPA и так далее:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_013.png">
        <img alt="Изображение277" class="frameGraphics" id="277graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_013-572x382.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:383.84px" />
      </a>
      <a id="a277graphic"></a>
      <a id="bkm277graphic"></a>
    </p>
    <p class="Textbody">Про архитектуру всё понятно без комментариев — их нынче осталось всего ничего.</p>
    <p class="Textbody">Что касается кнопок Специальные фильтры и Результаты поиска, то о них мы поговорим позднее.</p>
    <p class="Textbody">А пока обратимся к спискам файлов, выводимых в правом главном фрейме. Если поглядеть на него внимательно, то слева можно увидеть две колонки иконок, причём вторая может либо изображать нечто жёлтенькое, либо быть пустой. Факт наличия жёлтой иконки указывает, что данный пакет поддерживается официально разработчиками дистрибутива. А отсутствие пиктограммы во второй колонке говорит о том, что пакет либо поддерживается сообществом (точнее, некими конкретными его представителями), либо, в рамках дистрибутива, не поддерживается вообще.</p>
    <p class="Textbody">Пиктограммы же первой колонки отражают статус пакет: установленный (зелёный квадратик), не установленный (квадратик не залитый), и так далее. Полную расшифровку значений пиктограмм можно получить через систему встроенной помощи: меню Справка -&gt; Описание значков:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_014.png">
        <img alt="Изображение278" class="frameGraphics" id="278graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_014.png" style="border:1.0px solid #000080;padding:0;width:445.82428px;height:509.8495px" />
      </a>
      <a id="a278graphic"></a>
      <a id="bkm278graphic"></a>
    </p>
    <p class="Textbody">А теперь вернёмся к контекстному меню. Из приведённого скриншота можно видеть, что для установленного пакета активизированы пункты:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Отметить для повторной установки — то есть реинсталляции, аналог команды apt reinstall; </p>
      </li>
      <li>
        <p class="Textbody">Отметить для удаления — удаление данного пакета, без конфигурационных файлов, аналог команды apt remove; </p>
      </li>
      <li>
        <p class="Textbody">Отметить для полного удаления — удаление данного пакета вместе с его конфигами, но не затрагивая зависимостей, аналог команды apt purge; </p>
      </li>
      <li>
        <p class="Textbody">свойства — его мы уже рассмотрели. </p>
      </li>
    </ul>
    <p class="Textbody">Для пакета не установленного по умолчанию доступны два пункта — Отметить для установки (аналог команды apt install) и всё те же Свойства. Не активизированы пункты Отметить для установки рекомендуемые (recommended) и предлагаемые (suggest) пакеты — они зависят от общих настроек Synaptic’а, и мы к ним ещё вернёмся.</p>
    <p class="Textbody">Подчеркну, что все отметки через контекстное меню не влекут за собой немедленной установки, обновления или удаления пакетов — эти действия будут выполнены только после надатия кнопки Применить.</p>
    <p class="Textbody">Теперь двинемся вверх по основным элементам интерфейса главного окна synapеic’а. Как уже говорилось, выше двух главных фреймов обнаруживается инструментальная панель, а на ней кнопки. Первой из них идёт кнопка Обновить — это ни что иное, как перечитывание базы данных репозиториев пакетов, тех, которые были определены в настройках (о чем будет говориться далее):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_015.png">
        <img alt="Изображение279" class="frameGraphics" id="279graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_015.png" style="border:1.0px solid #000080;padding:0;width:451.83374px;height:385.84317px" />
      </a>
      <a id="a279graphic"></a>
      <a id="bkm279graphic"></a>
    </p>
    <p class="Textbody">Здесь же можно наблюдать за ходом процесса попакетно:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_016.png">
        <img alt="Изображение280" class="frameGraphics" id="280graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_016-436x572.png" style="border:1.0px solid #000080;padding:0;width:437.84946px;height:573.83685px" />
      </a>
      <a id="a280graphic"></a>
      <a id="bkm280graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_016.png"> </a>
    </p>
    <p class="Textbody">А по его завершении пакеты, для которых доступны обновления, автоматически помечаются жёлтыми звёздочками в первой колонке:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_017.png">
        <img alt="Изображение281" class="frameGraphics" id="281graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_017-572x382.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:383.84px" />
      </a>
      <a id="a281graphic"></a>
      <a id="bkm281graphic"></a>
    </p>
    <p class="Textbody">Для претворения помеченного в действительность предназначена следующая кнопка, Применить — предложение выполнить над пакетами, отмеченными для установки, обновления или удаления, соответствующие действия.</p>
    <p class="Textbody">Кнопка Свойства вызывает ту же самую панель, что и пункт Свойства контекстного меню.</p>
    <p class="Textbody">О поиске стоит поговорить отдельно. Поле Быстрый поиск предназначено для обычного наращиваемого поиска в списке правого главного фрейма в соответствие с разделами, выбранными во фрейме левом. То есть, если в последнем выбрать раздел Все, а в поле ввести gnu, мы получим список всех пакетов, содержащих эти символы в имени, в резюме или в описании:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_018.png">
        <img alt="Изображение282" class="frameGraphics" id="282graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_018-572x343.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:344.8353px" />
      </a>
      <a id="a282graphic"></a>
      <a id="bkm282graphic"></a>
    </p>
    <p class="Textbody">Если же мы укажем точное (или предполагаемое) имя пакета (например, gnumeric), то получим список всех пакетов, непосредственно с ним связанных:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_019.png">
        <img alt="Изображение283" class="frameGraphics" id="283graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_019-572x343.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:344.8353px" />
      </a>
      <a id="a283graphic"></a>
      <a id="bkm283graphic"></a>
    </p>
    <p class="Textbody">Обращаю внимание на последнюю строку в выводе результатов поиска на скриншоте: ни в имени этого пакета, ни в его кратком описании слова gnumeric мы не увидим — это как ра пример поиска в полных описаниях — тех самых, которые выводятся в нижнем правом фрейме (или в закладке Общие панели Свойства). А вот кнопка Найти как раз и позволяет варьировать область поиска и его критерии:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_020.png">
        <img alt="Изображение284" class="frameGraphics" id="284graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_020-572x342.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:343.85263px" />
      </a>
      <a id="a284graphic"></a>
      <a id="bkm284graphic"></a>
    </p>
    <p class="Textbody">Как видно из скриншота, по умолчанию поиск проводится в именах пакетов и их описаниях. Однако область поиска можно ограничить только именами. Кроме того, поиск можно выполнять по имени майнтайнера пакета, номеру версии, зависимым или предоставляемым (suggest) пакетам:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_021.png">
        <img alt="Изображение285" class="frameGraphics" id="285graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_021.png" style="border:1.0px solid #000080;padding:0;width:375.82742px;height:268.82898px" />
      </a>
      <a id="a285graphic"></a>
      <a id="bkm285graphic"></a>
    </p>
    <p class="Textbody">Наконец, самый верхний интерфейсный элемент окна — строка главного меню. Однако на как раз на меню мы останавливаться не будем: смысл его пунктов в общих чертах понятен из названий, И к тому же по большей части они дублируются меню контекстным и кнопками инструментальной панели. Так что скажу-ка я лучше пару слов о настройке Synaptic'а.</p>
    <h3 id="toc144"><a id="RefHeading17301713816058"></a><a id="bkmRefHeading17301713816058"></a><a id="toc143"></a><a id="bkmtoc143"></a><a id="RefHeading5621136957987"></a><a id="bkmRefHeading5621136957987"></a><a id="bkmRefHeading5621136957987"></a><a id="bkmbkmRefHeading5621136957987"></a>Настройка</h3>
    <p class="Textbody">Как легко догадаться, за настройки Synaptic’а отвечает одноимённый пункт главного меню, содержащий подпункты:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Параметры; </p>
      </li>
      <li>
        <p class="Textbody">Репозитории; </p>
      </li>
      <li>
        <p class="Textbody">Фильтры; </p>
      </li>
      <li>
        <p class="Textbody">Установить внутренний параметр; </p>
      </li>
      <li>
        <p class="Textbody">Панель инструментов. </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_022.png">
        <img alt="Изображение286" class="frameGraphics" id="286graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_022.png" style="border:1.0px solid #000080;padding:0;width:346.8384px;height:176.83528px" />
      </a>
      <a id="a286graphic"></a>
      <a id="bkm286graphic"></a>
    </p>
    <p class="Textbody">Рассмотрим их последовательно.</p>
    <p class="Textbody">Пункт Параметры вызывает панель со множеством вкладок, позволяющих настроить общее поведение Synaptic’а:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Основное; </p>
      </li>
      <li>
        <p class="Textbody">Столбцы и шрифты; </p>
      </li>
      <li>
        <p class="Textbody">Цвета; </p>
      </li>
      <li>
        <p class="Textbody">Файлы; </p>
      </li>
      <li>
        <p class="Textbody">Сеть; </p>
      </li>
      <li>
        <p class="Textbody">Дистрибутив. </p>
      </li>
    </ul>
    <p class="Textbody">Вкладка Основное, кроме внешнего вида (включение или выключение чекбокса о показе информации в главном окне у меня не влечёт никаких последствий для оного), позволяет установить ряд очень важных параметров:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_023.png">
        <img alt="Изображение287" class="frameGraphics" id="287graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_023-572x347.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:348.84158px" />
      </a>
      <a id="a287graphic"></a>
      <a id="bkm287graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_023.png"> </a>
    </p>
    <p class="Textbody">Например, выводить ли запрос на изменение пакетов, от которых зависят другие пакеты — разумеется, лучше держать эту опцию включённой.</p>
    <p class="Textbody">Важно также определить, следует ли рассматривать рекомендуемые пакеты как зависимости, обязательные к установке — в умолчальной конфигурации Mint'овской реализации apt, (как и в обычном apt, надстройкой над которым является Synaptic), пакеты из категории recommended автоматически не устанавливаются. Так что если использовать apt и Sinaptic попеременно, лучше эту опцию не трогать.</p>
    <p class="Textbody">Выпадающее меню Удаление пакетов определяет, удалять ли их полностью (аналог команды apt purge, отмечено по умолчанию), или сохранять конфигурационные файлы (аналог apt remove).</p>
    <p class="Textbody">Меню пункта Обновить систему позволяет установить, использовать ли по умолчанию стандартное обновление, интеллектуальное (то есть с попыткой разрешения противоречий зависимостей) или выбирать метод обновления по запросу. Последнее время проблем с интеллектуальным обновлением, вроде, не отмечалось, так что можно остановиться на этом методе (тем более что он отмечен по умолчанию).</p>
    <p class="Textbody">В выпадающем меню Обновление устаревших сведений о пакетах можно выбрать опции — Всегда спрашивать, Автоматически или Игнорировать. Представляется, что первая, умолчальная, будет лучшим выбором.</p>
    <p class="Textbody">Прочие опции данной вкладки ясны из приведённого выше скриншота.</p>
    <p class="Textbody">Во вкладке Столбцы и шрифты определяется набор колонок вывода информации о пакетах и их порядок. Ну а со шрифтами всё ясно — можно использовать общесистемные шрифты, заданные глобально для всех приложений среды (в данном случае Cinnamon), или задать собственные, специально для Synaptic’а.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_024.png">
        <img alt="Изображение288" class="frameGraphics" id="288graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_024-572x347.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:348.84158px" />
      </a>
      <a id="a288graphic"></a>
      <a id="bkm288graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_024.png"> </a>
    </p>
    <p class="Textbody">Столь же очевиден смысл установок во вкладке Цвета:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_025.png">
        <img alt="Изображение289" class="frameGraphics" id="289graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_025-572x347.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:348.84158px" />
      </a>
      <a id="a289graphic"></a>
      <a id="bkm289graphic"></a>
    </p>
    <p class="Textbody">Во вкладке Файлы определяется, надо ли хранить в локальном кэше скачанные файлы пакетов, сохранять ли историю установок, а также задаётся время хранения файлов истории:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_026.png">
        <img alt="Изображение290" class="frameGraphics" id="290graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_026-572x347.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:348.84158px" />
      </a>
      <a id="a290graphic"></a>
      <a id="bkm290graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_026.png"> </a>
    </p>
    <p class="Textbody">Во вкладке Сеть при необходимости можно задать адреса прокси-серверов http и ftp, буде таковые используются:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_027.png">
        <img alt="Изображение291" class="frameGraphics" id="291graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_027-572x347.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:348.84158px" />
      </a>
      <a id="a291graphic"></a>
      <a id="bkm291graphic"></a>
    </p>
    <p class="Textbody">И, наконец, во вкладке Дистрибутив указывается режим обновления дистрибутива в рамках текущей версии — здесь я поменял умолчание (Всегда предпочитать новейшую версию) на :Предпочитать версии из rebecca</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_028.png">
        <img alt="Изображение292" class="frameGraphics" id="292graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_028-572x347.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:348.84158px" />
      </a>
      <a id="a292graphic"></a>
      <a id="bkm292graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_028.png"> </a>
    </p>
    <p class="Textbody">Пункт меню Репозитории, как уже упоминалось, самостоятельного значения не имеет — через него просто вызывается фирменная утилита mintsource.</p>
    <p class="Textbody">Смысл пункта Фильтры поиска (вспомним, что они фигурируют у нас среди кнопок левого нижнего фрейма главного окна Synaptic’а) в том, чтобы включить (или выключить) те или иные критерии поиска. Детально я с этим не разбирался, оставив на всякий случай всё так, как было по умолчанию:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_029.png">
        <img alt="Изображение293" class="frameGraphics" id="293graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_029-572x259.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:260.8542px" />
      </a>
      <a id="a293graphic"></a>
      <a id="bkm293graphic"></a>
    </p>
    <p class="Textbody">В пункте Установить внутренний параметр можно задать некие переменные для Synaptic'а, и определить их значения (необходимости в чём, впрочем, я до сих пор не испытывал):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_030.png">
        <img alt="Изображение294" class="frameGraphics" id="294graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_030-572x342.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:343.85263px" />
      </a>
      <a id="a294graphic"></a>
      <a id="bkm294graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_030.png"> </a>
    </p>
    <p class="Textbody">Ну а с пунктом Панель инструментов всё проще некуда — здесь устанавливается вид её кнопок: в виде только значков, только текста или их комбинации; можно также скрыть инструментальную панель вообще:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/synaptic_031.png">
        <img alt="Изображение295" class="frameGraphics" id="295graphic" src="http://alv.me/wp-content/img/im_cin_img/synaptic_031-572x293.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:294.83212px" />
      </a>
      <a id="a295graphic"></a>
      <a id="bkm295graphic"></a>
    </p>
    <p class="Textbody">На этом настройки Synaptic’а можно считать законченными. Как, впрочем, и вообще разговор о нём. Ибо, на мой взгляд, практическое применение этой программы в Mint весьма ограничено: для манипуляций с единичными пакетами эффективней apt в его «фирменной» реализации, для обыденных обновлений проще использовать mintupdate, а для глобального обновления при смене версий дистрибутива — опять же обратиться к apt dist-upgrade. Единственное, для чего я иногда использую Synaptic — это для удаления пакетов, и исключительно в силу большей наглядности процесса. Хотя и здесь есть альтернатива, о которой сейчас расскажу.</p>
    <h3 id="toc145"><a id="RefHeading17321713816058"></a><a id="bkmRefHeading17321713816058"></a><a id="toc144"></a><a id="bkmtoc144"></a><a id="RefHeading5641136957987"></a><a id="bkmRefHeading5641136957987"></a><a id="bkmRefHeading5641136957987"></a><a id="bkmbkmRefHeading5641136957987"></a>Удаление пакетов: нетрадиционный метод</h3>
    <p class="Textbody">Среда Cinnamon в Mint предлагает несколько неожиданный метод удаления пакетов — не проверял, имеет ли он место быть в других средах и дистрибутивах. А именно — правым кликом на имени программы вызывается контекстное меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/remove_032.png">
        <img alt="Изображение296" class="frameGraphics" id="296graphic" src="http://alv.me/wp-content/img/im_cin_img/remove_032-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a296graphic"></a>
      <a id="bkm296graphic"></a>
    </p>
    <p class="Textbody">В котором легко видеть пункт Удалить. И это не удаление пункта из меню, что можно сделать в редакторе последнего, а именно удаление пакета (после запроса пароля), вместе со всеми теми, что от него зависят:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/remove_033.png">
        <img alt="Изображение297" class="frameGraphics" id="297graphic" src="http://alv.me/wp-content/img/im_cin_img/remove_033.png" style="border:1.0px solid #000080;padding:0;width:370.83844px;height:288.8227px" />
      </a>
      <a id="a297graphic"></a>
      <a id="bkm297graphic"></a>
    </p>
    <p class="Textbody">Однако пакеты, от которых зависит удаляемый пакет, остаются в неприкосновенности, даже если никем более не используются. Так что после удаления пакетов описанным способом не лишним будет выполнить команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt autoremove</span> </p>
    <p class="Textbody">Описанный метод по наглядности, как мне кажется, превосходит удаление через Synaptic. Хотя он не очень удобен для массового удаления пакетов (например, после стандартной инсталляции), так как каждый пакет надо удалять индивидуально, да ещё и вводя пароль на каждый чих. Так что в этой ситуации лучше воспользоваться «традиционным» методом — командой apt purge. Однако для удаления единичных пакетов, тем более поставленных «на посмотреть», он подходит как нельзя лучше. Таким образом я удаляю пакеты, устанавливавшиеся в экспериментальных целях и не оправдавшие ожиданий. А также просто те, на которые упал глаз как ненужные после стандартной инсталляции.</p>
    <h2 id="toc146"><a id="RefHeading17341713816058"></a><a id="bkmRefHeading17341713816058"></a><a id="toc145"></a><a id="bkmtoc145"></a><a id="RefHeading12801136957987"></a><a id="bkmRefHeading12801136957987"></a><a id="bkmRefHeading12801136957987"></a><a id="bkmbkmRefHeading12801136957987"></a>Пользовательские приложения</h2>
    <p class="Textbody">Всё, что было описано в предыдущих очерках — и установка системы, и знакомство с его графической рабочей средой, и получение представлений о работе в командной оболочке, в том числе в лице лучшей их представительницы, Zsh, и овладение средствами управления пакетами — в конечном счёте преследовало одну цель: оптимальным образом применять Linux Mint для решения своих практических задач. Что осуществляется посредством пользовательских приложений, обозрение которых и будет предметом следующей серии очерков.</p>
    <p class="Textbody">Рабочие среды, они же десктопы, не случайно называются также средами интегрированными: кроме средств самообеспечения (оконный менеджер, менеджер сессий и так далее) и самоконфигурирования, они в обязательном порядке включают в себя более или менее обширный набор пользовательских приложений. Из которых важнейшими являются файловый менеджер, эмулятор терминала и текстовый редактор.</p>
    <p class="Textbody">Специфика среды Cinnamon — почти полное отсутствие собственных приложений. Что, тем не менее, не значит, что таковых нет после установки соответствующей редакции дистрибутива: «непременный джентльменский набор» применителя, включающий файловый менеджер Nemo, эмулятор терминала GNOME Terminal и текстовый редактор Gedit здесь присутствует. Правда, Nemo представляет собой клон GNOME'вского Nautilus'а, а остальные просто заимствованы из GNOME 3. Однако первый не просто далеко отошёл от прототипа, но и далеко превзошёл его по функционалу и настраиваемости, а терминал и редактор включены в Cinnamon в адаптированном к нему виде. И потому эти три кита интегрированного десктопа вполне могут считаться родными для нашей среды.</p>
    <p class="Textbody">Кроме того, в состав Cinnamon-редакции дистрибутива включён обширный набор пользовательских приложений, основанных на библиотеках Gtk и рассчитанных почти на все случаи жизни. Однако давать их подробное описание мне показалось скучным, тем более что большую их часть я не использую и, следовательно, знаю плохо. Поэтому, за редким исключением, они будут лишь кратко охарактеризованы (или вообще просто упомянуты). Основное же внимание я уделю альтернативным приложениям, которые постоянно применяю, люблю и знаю.</p>
    <h2 id="toc147"><a id="RefHeading17361713816058"></a><a id="bkmRefHeading17361713816058"></a><a id="toc146"></a><a id="bkmtoc146"></a><a id="RefHeading12821136957987"></a><a id="bkmRefHeading12821136957987"></a><a id="bkmRefHeading12821136957987"></a><a id="bkmbkmRefHeading12821136957987"></a>Файловый менеджер Nemo</h2>
    <p class="Textbody">Файловый менеджер среди базовых приложений занимает центральное положение: он является сердцем интегрированной рабочей среды, причём любой (даже Windows — кое-кому памятны разборки о неразрывной связи её Windows Explorer'ом). Без него она хотя и может существовать (как показали примеры «выпиливания» того же Explorer'а), но существование это лишается смысла (что, собственно, и продемонстрировали некогда «выпиливатели», правда, вопреки своей воле).</p>
    <p class="Textbody">Сказанное применимо и к Nemo в Cinnamon, причём в превосходной степени. Ибо он, в сущности, является единственным штатным приложением этой среды: прочие представители «малого джентльменского набора», из которых в ней присутствуют GNOME-терминал и текстовый редактор Gedit, выдернуты из GNOME и легко заменяются любыми аналогами, основанными на Gtk, что я покажу в следующих очерках. И только Nemo стоит свою вахту бессменно, потому что заменить его некем. Да и незачем — это уже давно очень хороший файловый менеджер, а в последней своей версии, 2.4 (той самой, что входит в состав Mint Rebecca) он стал ещё лучше.</p>
    <h3 id="toc148"><a id="RefHeading17381713816058"></a><a id="bkmRefHeading17381713816058"></a><a id="toc147"></a><a id="bkmtoc147"></a><a id="RefHeading5661136957987"></a><a id="bkmRefHeading5661136957987"></a><a id="bkmRefHeading5661136957987"></a><a id="bkmbkmRefHeading5661136957987"></a>Обзор возможностей</h3>
    <p class="Textbody">Итак, представляю героя нынешнего очерка: файловый менеджер Nemo. Вместе со всей средой Cinnamon он ответвился от GNOME с его Nautilus'ом на стадии версии 3.4, до того, как последний стал стремительно терять свою функциональность и настраиваемость. Поэтому Nemo сохранил исходные возможности Nautilus'а, а после отказа Cinnamon (в версии 2.0) от связи с кодовой базой GNOME 3, ещё и приумножил их.</p>
    <p class="Textbody">По умолчанию, при первом запуске, Nemo выглядит весьма непритязательно — примерно так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_001.png">
        <img alt="Изображение298" class="frameGraphics" id="298graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_001-572x415.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:416.8353px" />
      </a>
      <a id="a298graphic"></a>
      <a id="bkm298graphic"></a>
    </p>
    <p class="Textbody">То есть, казалось бы, Nautilus как Nautilus — визуальное отличие разве что в эмблемах на пиктограммах каталогов (которых раньше не было). Кстати, вплоть до версии 2.2 включительно Nemo под этим именем и фигурировал — и в главном меню Cinnamon, и во всплывающей подсказке при наведении на пиктограмму панели управления. Лишь в версии 2.4 он освободился от тяжкого наследния, и нынче и там, и там написано просто Файлы (Files в оригинальной локализации). Одновременно с этим появились и упомянутые только что эмблемы.</p>
    <p class="Textbody">Однако на деле Nemo оказывается не так прост. То, что он поддерживает вкладки — само собой разумеется, кто их нынче не поддерживает, даже Thunar. Однако далее: графическая строка адреса лёгким нажатием на загогулину справа от неё превращается в текстовую — и остаётся таковой в последующих сеансах, если не «опиктограммить» её обратно.</p>
    <p class="Textbody">Инструментальную панель легко пополнить пиктограммами перезагрузки, быстрого перехода в корневой и домашний каталоги, открытия терминала в текущем каталоге и создания нового каталога. Делается это через главное меню: Правка -&gt; Параметры -&gt; Панель инструментов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_002.png">
        <img alt="Изображение299" class="frameGraphics" id="299graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_002-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a299graphic"></a>
      <a id="bkm299graphic"></a>
    </p>
    <p class="Textbody">Назначение любой пиктограммы легко определяется по всплывающей подсказке.</p>
    <p class="Textbody">Саму строку главного меню можно скрыть через меню же: в пункте Вид снять отметку с подпункта Menubar. После этого строку меню можно быстро делать видимой и скрывать заново либо нажатием клавиши Alt, либо правым кликом мыши на панели инструментов или строке состояния. И так — до тех пор, пока не сделать строку меню видимой постоянно — тем же образом, что она была скрыта, то есть через меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_003.png">
        <img alt="Изображение300" class="frameGraphics" id="300graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_003-355x572.png" style="border:1.0px solid #000080;padding:0;width:356.8542px;height:573.83685px" />
      </a>
      <a id="a300graphic"></a>
      <a id="bkm300graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_003.png"> </a>
    </p>
    <p class="Textbody">Впрочем, я в постоянно видимом меню необходимости не вижу: большую часть обыденных действий можно (и проще) выполнять через пиктограммы панели инструментов или через контекстное меню по правому клику мыши. А меню вызывать только при необходимости — например, для пополнения списка закладок боковой панели (см. ниже).</p>
    <p class="Textbody">Вид контекстного меню различается в зависимости от того, где именно кликнуть. Если на пустом поле основного окна Nemo — в нём будут пункты создания каталога, файла или ярлыка запуска приложения, открытия в терминале, открытия Nemo с правами администратора, сортировки, показа и скрытия dot-файлов, вставки из буфера, масштабирования пиктограмм; последнее можно сделать и ползунком на строке состояния.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_004.png">
        <img alt="Изображение301" class="frameGraphics" id="301graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_004.png" style="border:1.0px solid #000080;padding:0;width:359.84px;height:464.8353px" />
      </a>
      <a id="a301graphic"></a>
      <a id="bkm301graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_004.png"> </a>
    </p>
    <p class="Textbody">При щелчке на пиктограмме одиночного файла пункты Открыть в Терминале и Открыть как Администратор, естественно, пропадают. Зато появляются пункты открытия с помощью приложения по умолчанию и «запасных» приложений для данного типа файлов (в примере на скриншоте ниже — для HTML-файлов), вырезания, «дублирования», создания симлинка и так далее:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_005.png">
        <img alt="Изображение302" class="frameGraphics" id="302graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_005-572x155.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:156.84157px" />
      </a>
      <a id="a302graphic"></a>
      <a id="bkm302graphic"></a>
    </p>
    <p class="Textbody">Среди «далее» отмечу безвозвратное удаление и сжатие, что для единичного файла означает именно сжатие каким-либо компрессором из доступных в системе, понятие тут архивирования смысла не имеет, хотя по умолчанию предлагается именно архив:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_006.png">
        <img alt="Изображение303" class="frameGraphics" id="303graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_006-572x160.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:161.83055px" />
      </a>
      <a id="a303graphic"></a>
      <a id="bkm303graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_006.png"> </a>
    </p>
    <p class="Textbody">Во избежание недоразумений следует подчеркнуть, что сам по себе Nemo ничего не сжимает и не архивирует. Он лишь вызывает менеджер архивов — nemo-fileroller. Который, впрочем, тоже ничего не делает, а обращается к низкоуровневым утилитам архивации (tar) и компрессии (gzip, bzip2, xz и так далее); наличием последних и определяется число доступных архивных форматов. При щелчке на пиктограмме архивного файла в контекстном меню появится пункт Распаковать сюда, который всё той же цепочкой (nemo-fileroller -&gt; архиватор/компрессор) развернёт архив в текущем каталоге.</p>
    <p class="Textbody">При щелчке на пиктограмме каталога пункты контекстного меню первого и второго случая как бы суммируются. Но к ним ещё присоединяются пункты открытия (на месте, в новом окне, в новой вкладке), настройки общего доступа, а также цветовая палитра, позволяющая окрасить пиктограмму каждого каталога в свой цвет (из числа предопределённых темой).</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_007.png">
        <img alt="Изображение304" class="frameGraphics" id="304graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_007-241x572.png" style="border:1.0px solid #000080;padding:0;width:242.82585px;height:573.83685px" />
      </a>
      <a id="a304graphic"></a>
      <a id="bkm304graphic"></a>
    </p>
    <p class="Textbody">Во всех трёх случаях контекстное меню завершается пунктом Свойства, содежимое которого тоже различается в зависимости от места клика. В частности, для одиночного файла имеется вкладка Открыть с помощью, в которой можно переопределить приложение по умолчанию, связанное с данным типом файлов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_008.png">
        <img alt="Изображение305" class="frameGraphics" id="305graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_008-572x355.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:356.8542px" />
      </a>
      <a id="a305graphic"></a>
      <a id="bkm305graphic"></a>
    </p>
    <p class="Textbody">Любопытна вкладка Эмблемы, впервые появившаяся в версии Nemo 2.4. Именно с её помощью можно к пиктограмме каждого каталога и файла, зависимости от их содержимого, миниатюрное изображение из заданного набора:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_009.png">
        <img alt="Изображение306" class="frameGraphics" id="306graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_009-572x355.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:356.8542px" />
      </a>
      <a id="a306graphic"></a>
      <a id="bkm306graphic"></a>
    </p>
    <p class="Textbody">Правда, делать это придётся вручную и по одному объекту.</p>
    <p class="Textbody">В итоге описанных выше действий по модификации внешности Nemo, в моей системе он приобрёл следующий вид:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_010.png">
        <img alt="Изображение307" class="frameGraphics" id="307graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_010-572x534.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:535.85266px" />
      </a>
      <a id="a307graphic"></a>
      <a id="bkm307graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_010.png"> </a>
    </p>
    <p class="Textbody">В боковой панели окна Nemo выводится список закладок — каталогов файловой системы с быстрым доступом, который можно пополнять произвольным образом, и «посторонних» (то есть автоматически не монтируемых) носителей, как внутренних, так и внешних. Из контекстного меню по правому клику они могут быть открыты в текущей вкладке, новой вкладке или новом окне:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_011.png">
        <img alt="Изображение308" class="frameGraphics" id="308graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_011.png" style="border:1.0px solid #000080;padding:0;width:251.85892px;height:166.85733px" />
      </a>
      <a id="a308graphic"></a>
      <a id="bkm308graphic"></a>
    </p>
    <p class="Textbody">Для «сторонних» носителей предусмотрены также пункты монтирования (без открытия) и отмонтирования:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_012.png">
        <img alt="Изображение309" class="frameGraphics" id="309graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_012.png" style="border:1.0px solid #000080;padding:0;width:251.85892px;height:217.84314px" />
      </a>
      <a id="a309graphic"></a>
      <a id="bkm309graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_012.png"> </a>
    </p>
    <p class="Textbody">Пользовательские закладки пополняются через главное меню: Закладки -&gt; Добавить в закладки. При этом они не сваливаются в одну кучу с предопределённым набором закладок (такими, как Desktop, Documents, etc.), а размещаются в специальной секции Bookmarks. Впрочем, перетаскиванием мышью их можно тасовать, как угодно. Кроме того, их можно удалять и переименовывать — и из контекстного меню, и из главного, через пункты Закладки -&gt; Изменить закладки:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_013.png">
        <img alt="Изображение310" class="frameGraphics" id="310graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_013.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:222.83214px" />
      </a>
      <a id="a310graphic"></a>
      <a id="bkm310graphic"></a>
    </p>
    <p class="Textbody">Исключение — «квазисистемные» закладки (Файловая система, Домашний каталог, Рабочий стол, Корзина) — для них эти функции недоступны.</p>
    <p class="Textbody">Кстати, закладка открывается одинарным щелчком: левой кнопкой мыши — в текущей вкладке, средней кнопкой — в новой вкладке. Для открытия же каталога из пиктограммы во вкладке по умолчанию требуется двойной щелчок левой кнопкой. Что, однако, легко изменить через меню: Правка -&gt; Параметры -&gt; Поведение:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_014.png">
        <img alt="Изображение311" class="frameGraphics" id="311graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_014-572x429.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:430.85733px" />
      </a>
      <a id="a311graphic"></a>
      <a id="bkm311graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_014.png"> </a>
    </p>
    <p class="Textbody">Наконец, в Nemo имеется двухпанельный режим, включаемый через меню Вид -&gt; Extra Pane. Само собой, в каждой панели можно вывести содержимое разных каталогов, да ещё и в нескольких независимых вкладках:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_018.png">
        <img alt="Изображение312" class="frameGraphics" id="312graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_018-572x235.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:236.85417px" />
      </a>
      <a id="a312graphic"></a>
      <a id="bkm312graphic"></a>
    </p>
    <p class="Textbody">На мой взгляд, совмещёние «многовкладочности» и «двухпанельности» — явный перебор. Но в ряде случаев временное включение второй панели (а это можно сделать быстро — клавишей F3) бывает полезным — например, при работе с облачными хранилищами.</p>
    <p class="Textbody">В Nemo имеются весьма богатые возможности поиска файлов, доступные из меню Переход -&gt; Поиск файлов или по нажатии на соответствующую кнопку инструментальной панели. Для начала поиск выполняется по одному критерию — местоположению:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_015.png">
        <img alt="Изображение313" class="frameGraphics" id="313graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_015-572x534.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:535.85266px" />
      </a>
      <a id="a313graphic"></a>
      <a id="bkm313graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_015.png"> </a>
    </p>
    <p class="Textbody">Круг поисков можно сузить, задав второй критерий — тип файла (в примере изображение PNG):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_016.png">
        <img alt="Изображение314" class="frameGraphics" id="314graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_016-572x534.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:535.85266px" />
      </a>
      <a id="a314graphic"></a>
      <a id="bkm314graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_016.png"> </a>
    </p>
    <p class="Textbody">Кроме таких абстрактных типов, как документ, музыка, презентация и так далее, более конкретно тип файла можно выбрать из длиннющего списка, вызываемого выбором пункта Другой тип:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_017.png">
        <img alt="Изображение315" class="frameGraphics" id="315graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_017-381x572.png" style="border:1.0px solid #000080;padding:0;width:382.85733px;height:573.83685px" />
      </a>
      <a id="a315graphic"></a>
      <a id="bkm315graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_017.png"> </a>
    </p>
    <p class="Textbody">Теоретически критериев поиска можно задать сколько угодно, только комбинировать можно только значения двух их вариантов — местоположения и типа файлов, так что больше двух критериев практического смысла не имеют.</p>
    <p class="Textbody">Иначе говоря, Nemo предоставляет большинство возможностей, которые мы вправе ожидать от современного «продвинутого» файлового менеджера. Если, конечно, вслед за разработчиками GNOME не считать признаком «современности» и «продвинутости» отсуствие возможностей...</p>
    <p class="Textbody">Перепробовав немалое число программ этого рода, могу со всей ответственностью утверждать, что по функциональности и настраиваемости Nemo уступает только старому Konqueror'у и современному Dolphin'у из KDE, да и то немного. В частности, в нём (мне) очень не хватает встроенного терминального окна — но это, пожалуй, единственное, чего на самом деле недостаёт. Тем более, что в принципе эта проблема решаема, как будет показано в следующем разделе.</p>
    <h3 id="toc149"><a id="RefHeading17401713816058"></a><a id="bkmRefHeading17401713816058"></a><a id="toc148"></a><a id="bkmtoc148"></a><a id="RefHeading5681136957987"></a><a id="bkmRefHeading5681136957987"></a><a id="bkmRefHeading5681136957987"></a><a id="bkmbkmRefHeading5681136957987"></a>Nemo и его терминал</h3>
    <p class="Textbody">Как только что было сказано, единственное, чего не хватает в Nemo по настоящему (для меня) — это встроенного терминала. Что, однако, решается установкой одного из «расширителей» этого файлового менеджера (nemo-extensions), именуемого nemo-terminal. Он происходит от некогда существовавшего, но потом заброшенного плагина к Nautilus'у, который, как ни странно, назывался nautilus-terminal. Который, в свою очередь, был придуман в незапамятные времена, когда Nautilus утратил терминальное окно как свою встроенную функцию.</p>
    <p class="Textbody">Пакет плагина nemo-terminal находится в официальном репозитории Mint, и потому ныне устанавливается стандартным образом, без всяких неожиданностей:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install nemo-terminal</span> </p>
    <p class="Textbody">После чего требуется «жёсткий» выход из Nemo, например, командой в терминале:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ nemo -q</span> </p>
    <p class="Textbody">Запущенный в следующий раз, Nemo будет уже с терминальным окошком в верхней части рабочей области вполне уродливого вида:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_019.png">
        <img alt="Изображение316" class="frameGraphics" id="316graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_019-572x242.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:243.8463px" />
      </a>
      <a id="a316graphic"></a>
      <a id="bkm316graphic"></a>
    </p>
    <p class="Textbody">Горячей клавишей F4 его можно скрыть с глаз долой и вызывать по необходимости. А чтобы терминальное окно не мозолило глаза при каждом запуске, достаточно убрать его клавишей F4 и повторить команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ nemo -q</span> </p>
    <p class="Textbody">И при следующем запуске Nemo окно его будет девственно чисто — о наличии терминала можно узнать, только опять нажав клавишу F4.</p>
    <p class="Textbody">Никаких настроек для терминала не обнаруживается. Можно только мышью изменить высоту терминального окна — но лишь для запущенного экземпляра Nemo, при повторном его запуске оно опять будет восстановлено в исходном размере.</p>
    <p class="Textbody">Теоретически конфиг nemo-terminal находится в каталоге /usr/share/glib-2.0/schemas/ и носит имя org.nemo.extensions.nemo-terminal.gschema.xml. Однако мои попытки изменить в нём что-либо (например, высоту окна по умолчанию) успехом не увенчались.</p>
    <p class="Textbody">Поскольку «расширитель» nemo-terminal — это скрипт на Python'е, вероятно, всякие настройки по умолчанию можно изменить прямой правкой соответствующего файла —<br />/usr/share/nemo-python/extensions/nemo_terminal.py, о чем будет сказано чуть позже.</p>
    <p class="Textbody">Командная оболочка в окне nemo-terminal — теоретически login shell данного пользователя, то есть в моём случае Zsh. По кранйней мере, об этом говорил вывод команды</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ echo $SHELL</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/bin/zsh</span> </p>
    <p class="Textbody">Но это был очень странный Zsh. В частности, он игнорировал все настройки в ~/.zshrc. Более того, в ответ на прямую команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ source ~/.zshrc</span> </p>
    <p class="Textbody">он выдавал ошибки буквально в каждой строке.</p>
    <p class="Textbody">А в остальном, прекрасная маркиза, все функции терминала выполнялись исправно — то есть в нём можно было вводить всякие разные команды. При смене каталога в основной панели Nemo происходила смена его и в окне терминала:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_020.png">
        <img alt="Изображение317" class="frameGraphics" id="317graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_020-572x242.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:243.8463px" />
      </a>
      <a id="a317graphic"></a>
      <a id="bkm317graphic"></a>
    </p>
    <p class="Textbody">В терминальное окно можно было перетаскивать мышью каталоги и файлы. В первом случае это было эквивалентом команды cd — и тут уже с синхронизацией пути в командой строке и основной панели. Файлы же открывались в той программе, которая закреплена за ними по умолчанию: текстовые файлы — в текстовом редакторе, html-файлы — в браузере, файлы изображений — в графическом вьювере, и так далее.</p>
    <p class="Textbody">Проблема же с неправильным поведением командной оболочки была решена Станиславом Шрамко aka stanis. Да, действительно, оказалось, что нужно чуток отредактировать файл /usr/share/nemo-python/extensions/nemo_terminal.py, а конкретно — вот эту его секцию</p>
    <p class="Textbody"><span style="background-color:#dddddd">def terminal_or_default():</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">    """Enforce a default value for terminal from GSettings"""</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">    terminalcmd = settings.get_string("terminal-shell")</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">    if (terminalcmd == "") or (terminalcmd is None):</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        terminalcmd = Vte.get_user_shell()</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">    return terminalcmd</span> </p>
    <p class="Textbody">Вписав туда (в любимом текстовом редакторе от лица администратора) после строки</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">    terminalcmd = settings.get_string("terminal-shell")</span> </p>
    <p class="Textbody">вот это:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">    terminalcmd = ""</span> </p>
    <p class="Textbody">Затем — «жёсткое» завершение работы Nemo:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ nemo -q</span> </p>
    <p class="Textbody">И при следующем запуске этого файлового менеджера в его терминальном окне красуется Zsh именно в том виде, до которого я его доводил годами. Что любопытно — после описанной процедуры nemo-terminal стал реагировать и на ручные изменения своего конфига. В частности, высота окна его увеличилась с пяти умолчальных строк до десяти, которые я раньше тщетно пытался ему внушить:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_021.png">
        <img alt="Изображение318" class="frameGraphics" id="318graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_021-572x242.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:243.8463px" />
      </a>
      <a id="a318graphic"></a>
      <a id="bkm318graphic"></a>
    </p>
    <p class="Textbody">В общем, nemo-terminal не превращает Nemo в Dolphin, но в любом случае лучше хоть какой-то терминал, чем вообще никакого. Тем более, что работа над его совершенствованием будет продолжена. А пока его далёкий от эстетического совершенства вид можно скрывать, вызывая терминальное окно только при необходимости.</p>
    <h3 id="toc150"><a id="RefHeading17421713816058"></a><a id="bkmRefHeading17421713816058"></a><a id="toc149"></a><a id="bkmtoc149"></a><a id="RefHeading5701136957987"></a><a id="bkmRefHeading5701136957987"></a><a id="bkmRefHeading5701136957987"></a><a id="bkmbkmRefHeading5701136957987"></a>Некоторые расширения Nemo</h3>
    <p class="Textbody">Пакет nemo-terminal — не единственный из «расширителей» этого файлового менеджера (nemo-extensions). С полным их списком можно ознакомиться, например, с помошью конструкции примерно такого вида:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt search nemo | grep " nemo-"</span> </p>
    <p class="Textbody">В которой следует не забыть про пробел после открывающей кавычки — иначе в выводе будет много лишнего. А так он сведётся к списку из примерно 30 строк:</p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-compare                    - Context menu comparison extension for Nemo</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">i   nemo-data                       - data files for nemo</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-dbg                        - file manager and graphical shell for Cinna</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-dbg:i386                   - file manager and graphical shell for Cinna</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">i   nemo-terminal                   - Nemo extension to enable an embedded termi</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">p   nemo-terminal:i386              - Nemo extension to enable an embedded termi</span> </p>
    <p class="Textbody">Который, кстати, можно ещё сократить, отсортировав пакеты для ненужной архитектуры (в моём случае — для i386) довольно неуклюжей (лучше не придумал) конструкцией:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt search nemo | grep " nemo-" | grep -v i386</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-compare                    - Context menu comparison extension for Nemo</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">i   nemo-data                       - data files for nemo</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-dbg                        - file manager and graphical shell for Cinna</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-dropbox                    - Dropbox integration for Nemo</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">i   nemo-emblems                    - Change a folder or file emblem</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-filename-repairer          - Nemo extension for filename encoding repai</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">i   nemo-fileroller                 - File Roller integration for Nemo</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">i   nemo-folder-color-switcher      - Change a folder color</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-gtkhash                    - nemo extension for computing checksums and</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-image-converter            - nemo extension to mass resize or rotate im</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-keyboard                   - pure QML keyboard for the Maliit framework</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-media-columns              - Nemo Extension</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-pastebin                   - Nemo extension to send files to a pastebin</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-preview                    - nemo-preview is a quick previewer for nemo</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-rabbitvcs                  - Nemo extension for RabbitVCS</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   nemo-seahorse                   - seahorse plugins and utilities for encrypt</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">i   nemo-share                      - Nemo extension to share folder using Samba</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">i   nemo-terminal                   - Nemo extension to enable an embedded termi</span> </p>
    <p class="Textbody">Большинство «расширителей», не установленных по умолчанию, как зависимости пакета nemo (например, nemo-emblems — это тоже «расширитель»), относятся ко всяким средствам разработки, а nemo-terminal мы только что установили собственноручно. Однако и среди оставшихся простой советский применитель может выискать кое-что для себя полезное.</p>
    <p class="Textbody">В этом массиве полезностей — nemo-gtkhash, очень простое средство вычисления check-сумм, добавляющее соответствующий пункт в контекстное меню Nemo. Вроде бы ничего особенного — руки не отваляться дать соответствующую команду в CLI. Однако есть ситуации, когда этот «расширитель» оказывается удобней. Вот одна из них:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_022.png">
        <img alt="Изображение319" class="frameGraphics" id="319graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_022-572x260.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:261.83685px" />
      </a>
      <a id="a319graphic"></a>
      <a id="bkm319graphic"></a>
    </p>
    <p class="Textbody">Ну вы меня поняли, ага?</p>
    <p class="Textbody">Далее, полезным может оказаться «расширитель» nemo-image-converter, предназначенный для массовой обработки графических файлов — их масштабирования и вращения. Он также встраивается в контекстное меню Nemo. Например, если выделить в текущем каталоге несколько PNG-файлов (или любых других файлов растровых изображений), и затем щелкнуть правой кнопкой мыши, то в появившемся контекстном меню можно будет увидеть пункты Масштабировать изображения... и Rotate Images...:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_023.png">
        <img alt="Изображение320" class="frameGraphics" id="320graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_023.png" style="border:1.0px solid #000080;padding:0;width:350.84473px;height:567.82745px" />
      </a>
      <a id="a320graphic"></a>
      <a id="bkm320graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_023.png"> </a>
    </p>
    <p class="Textbody">Первый, как это ни парадоксально, обеспечивает именно масштабирование картинок. А каким образом это может происходить — становится понятно при беглом вгляде на скриншот вызываемой им панели:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_024.png">
        <img alt="Изображение321" class="frameGraphics" id="321graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_024-572x314.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:315.8463px" />
      </a>
      <a id="a321graphic"></a>
      <a id="bkm321graphic"></a>
    </p>
    <p class="Textbody">Точно так же, и столь же прозрачно, действует ротация, что видно на соответствующем скриншоте:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_025.png">
        <img alt="Изображение322" class="frameGraphics" id="322graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_025.png" style="border:1.0px solid #000080;padding:0;width:487.8526px;height:332.8542px" />
      </a>
      <a id="a322graphic"></a>
      <a id="bkm322graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_025.png"> </a>
    </p>
    <p class="Textbody">К которому остаётся разве что добавить, что вращать изображения можно на 90 градусов посолонь и противусолонь, на 180 градусов, а также на произвольные углы с шагом в один градус.</p>
    <p class="Textbody">И ещё: разумеется, масштабирование и вращение применимы и к единичному изображению. Однако наибольшую пользу они принесут в случае, когда надо сотни скриншотов вписать в формат web-страницы. Или массив отснятых фотографий перевести из портретной ориентации в альбомную (или наоборот). А для этих целей данный «расширитель» кажется мне очень востребованным.</p>
    <p class="Textbody">А вот действие nemo-filename-repairer, напротив, распространяется только на каталоги — лишь при правом клике на имени каталога в контекстном меню появляется пункт Repair filename.... Вот только, увы, у меня в системе нет ни одного каталога с именем в неправильной кодировке, и вообще практически нет файлов с именами, отличными от чистого ASCII, так что проверить, как это всё действует, не могу. А потому оставляю освещёние этого вопроса заинтересованным лицам. Как и знакомство с прочими «расширителями», не окученными ранее. Хотя об одном из них, nemo-dropbox, расскажу в следующем разделе.</p>
    <h3 id="toc151"><a id="RefHeading17441713816058"></a><a id="bkmRefHeading17441713816058"></a><a id="toc150"></a><a id="bkmtoc150"></a><a id="RefHeading5721136957987"></a><a id="bkmRefHeading5721136957987"></a><a id="bkmRefHeading5721136957987"></a><a id="bkmbkmRefHeading5721136957987"></a>Nemo и Dropbox</h3>
    <p class="Textbody">Назначение «расширителя» nemo-dropbox, как следует из его имени — обеспечить интеграцию Nemo с соответствующим облачным хранилищем. И делает он это так. Сразу после завершения установки, например, командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install nemo-dropbox</span> </p>
    <p class="Textbody">предлагается «вчистую» закрыть все, возможно, открытые экземпляры Nemo:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ nemo -q</span> </p>
    <p class="Textbody">А вслед за тем запустить из главного меню Cinnamon программу, которая так и называется — Dropbox, находится в секции Интернет и вызывает для начала свой собственный инсталлятор:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_026.png">
        <img alt="Изображение323" class="frameGraphics" id="323graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_026.png" style="border:1.0px solid #000080;padding:0;width:401.83054px;height:259.8337px" />
      </a>
      <a id="a323graphic"></a>
      <a id="bkm323graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_026.png"> </a>
    </p>
    <p class="Textbody">Программа скачивается:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_027.png">
        <img alt="Изображение324" class="frameGraphics" id="324graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_027.png" style="border:1.0px solid #000080;padding:0;width:411.8463px;height:175.8526px" />
      </a>
      <a id="a324graphic"></a>
      <a id="bkm324graphic"></a>
    </p>
    <p class="Textbody">А затем вызывается панель её установщика:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_028.png">
        <img alt="Изображение325" class="frameGraphics" id="325graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_028.png" style="border:1.0px solid #000080;padding:0;width:513.8558px;height:507.8463px" />
      </a>
      <a id="a325graphic"></a>
      <a id="bkm325graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_028.png"> </a>
    </p>
    <p class="Textbody">Поскольку аккаунт Dropbox'а у меня существует с незапамятных времён (хотя я им почти не пользуюсь), ввожу свои учётные данные</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_029.png">
        <img alt="Изображение326" class="frameGraphics" id="326graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_029.png" style="border:1.0px solid #000080;padding:0;width:513.8558px;height:507.8463px" />
      </a>
      <a id="a326graphic"></a>
      <a id="bkm326graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_029.png"> </a>
    </p>
    <p class="Textbody">Жму кнопку Next и жду установления коннекта. После чего совершаю выбор типа установки. Рекомендуемый Typical создаст каталог для синхронизации с Dropbox'ом в моём домашнем. Это меня по некоторым причинам ни в коем случае не устраивает, поэтому приходится выбирать Advanced, хотя ничего такого авантажного мне не требуется. Так что следующим шагом выбираю подходящее место для каталога Dropbox:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_030.png">
        <img alt="Изображение327" class="frameGraphics" id="327graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_030.png" style="border:1.0px solid #000080;padding:0;width:513.8558px;height:507.8463px" />
      </a>
      <a id="a327graphic"></a>
      <a id="bkm327graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_030.png"> </a>
    </p>
    <p class="Textbody">Далее по умолчанию предлагается синхронизировать все каталоги Dropbox'а. Это мне тоже ни к чему, поэтому меняю на каталоги по собственному выбору. В ответ программа хочет провести среди меня разъяснительную работу, объяснив, что такое каталоги вообще и каталог Dropbox в частности:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_031.png">
        <img alt="Изображение328" class="frameGraphics" id="328graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_031.png" style="border:1.0px solid #000080;padding:0;width:513.8558px;height:507.8463px" />
      </a>
      <a id="a328graphic"></a>
      <a id="bkm328graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_031.png"> </a>
    </p>
    <p class="Textbody">Отказываюсь, нажав кнопку Skip Tour. В ответ предлагается финишировать, открыв при это каталог Dropbox'а:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_032.png">
        <img alt="Изображение329" class="frameGraphics" id="329graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_032.png" style="border:1.0px solid #000080;padding:0;width:513.8558px;height:507.8463px" />
      </a>
      <a id="a329graphic"></a>
      <a id="bkm329graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_032.png"> </a>
    </p>
    <p class="Textbody">Запускается Nemo, в нём открывается каталог /home/data/Dropbox, а в него очень быстро помещается то, что лежало у меня в Drop'локе (это я только что неологизм придумал).</p>
    <p class="Textbody">Все описанные события происходили на Ноутбучке, а настоящий текст сочинялся параллельно на большой машине. Так что собираю все сделанные скриншоты (те, что были приведены выше) и отправляю их в Drop'лако. Поскольку на большой машине описанныя процедура была проделана ещё раньше, скриншоты через посредство Drop'лака уже там. Дописываю последний абзац этого мини-очерка — и занимаюсь вставкой в него иллюстраций. Результат перед вами.</p>
    <h3 id="toc152"><a id="RefHeading17461713816058"></a><a id="bkmRefHeading17461713816058"></a><a id="toc151"></a><a id="bkmtoc151"></a><a id="RefHeading5741136957987"></a><a id="bkmRefHeading5741136957987"></a><a id="bkmRefHeading5741136957987"></a><a id="bkmbkmRefHeading5741136957987"></a>Nemo и Яндекс.Диск</h3>
    <p class="Textbody">Только что мы разобрались с ихним буржуазным облачным сервисом Dropbox'ом. Но ведь и мы не лыком шиты — у нас есть его собрат по поднебесному ремеслу, Яндекс.Диск, который подключается ничуть не сложнее. И даже проще, поскольку задача сводится к настройке подключения по WebDAV. Для чего нужно отправиться в боковую панель, найти там раздел Сеть, а в нём — закладку Сеть, на которой и щёлкнуть, чтобы получить вот такую картину:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_033.png">
        <img alt="Изображение330" class="frameGraphics" id="330graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_033-572x402.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:403.8337px" />
      </a>
      <a id="a330graphic"></a>
      <a id="bkm330graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_033.png"> </a>
    </p>
    <p class="Textbody">Нажимается Enter. В появившейся панельке авторизации вводится пароль доступа к сервисам Яндекса:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_034.png">
        <img alt="Изображение331" class="frameGraphics" id="331graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_034.png" style="border:1.0px solid #000080;padding:0;width:431.84003px;height:313.84314px" />
      </a>
      <a id="a331graphic"></a>
      <a id="bkm331graphic"></a>
    </p>
    <p class="Textbody">Всё — подключение свершилось. Теперь между локальными дисками и Яндекс.Диском можно взаимодействовать через Copy&amp;Paste. А можно клавишей F3 включить двухпанельный режим:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/nemo_035.png">
        <img alt="Изображение332" class="frameGraphics" id="332graphic" src="http://alv.me/wp-content/img/im_cin_img/nemo_035-572x438.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:439.85266px" />
      </a>
      <a id="a332graphic"></a>
      <a id="bkm332graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/nemo_035.png"> </a>
    </p>
    <p class="Textbody">И проникнуться его полезностью — файлы и каталоги можно просто таскать мышью туда и сюда.</p>
    <p class="Textbody">Справедливости ради следует сказать, что у Яндекса имеется и свой клиент для работы с ихним диском, причём и в версии под абстрактный Linux. Однако по ряду причин я его не использую, и потому ничего о нём сказать не могу.</p>
    <h2 id="toc153"><a id="RefHeading17481713816058"></a><a id="bkmRefHeading17481713816058"></a><a id="toc152"></a><a id="bkmtoc152"></a><a id="RefHeading12841136957987"></a><a id="bkmRefHeading12841136957987"></a><a id="bkmRefHeading12841136957987"></a><a id="bkmbkmRefHeading12841136957987"></a>Программы эмуляции терминала</h2>
    <p class="Textbody">Роль терминальных программ в жизни современного применителя Linux переоценить трудно. Это связано с постепенным отмиранием чисто текстовой консоли — ведь давно минули времена, когда она обеспечивала больший комфорт для глаз, нежели любой графический режим. На нынешних LCD-мониторах, да ещё и широкоформатных, стандартный текстовый режим 80x25 способен лишь вышибить скупую мужскую слезу (иногда — в буквальном смысле слова). А режимы нестандартные, реализуемые через фреймбуфер, во-первых, часто требуют настройки, во-вторых, не для всех видеокарт доступны, в-третьих, всё равно не всегда обеспечивают должный комфорт.</p>
    <p class="Textbody">С другой стороны, с появлением хороших TTF-шрифтов и развитием методов обеспечения их качественного рендеринга, работа в оконой системе X стала очень комфортной и приятной. А поскольку эффективность применения интерфейса командной строки (CLI) никто ещё не отменил — в качестве поля для него целесообразно использовать именно эмуляторы терминала в графическом режиме.</p>
    <h3 id="toc154"><a id="RefHeading17501713816058"></a><a id="bkmRefHeading17501713816058"></a><a id="toc153"></a><a id="bkmtoc153"></a><a id="RefHeading5761136957987"></a><a id="bkmRefHeading5761136957987"></a><a id="bkmRefHeading5761136957987"></a><a id="bkmbkmRefHeading5761136957987"></a>GNOME Terminal</h3>
    <p class="Textbody">В Cinnamon-редакции Mint штатным эмулятором терминала выступает программа GNOME Terminal. Как нетрудно догадаться по её имени, она заимствована из среды GNOME (с адаптацией для Cinnamon). И в виде пакета gnome-terminal устанавливается при стандартной инсталляции дистрибутива. После чего запускается через главное меню: Стандартные -&gt; Терминал, открываясь примерно в таком виде:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_001.png">
        <img alt="Изображение333" class="frameGraphics" id="333graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_001-572x326.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:327.82742px" />
      </a>
      <a id="a333graphic"></a>
      <a id="bkm333graphic"></a>
    </p>
    <p class="Textbody">Обращаю внимание на отсутствие строки главного меню по умолчанию. Включить показ его можно через меню контекстное, по правому клику мыши:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_002.png">
        <img alt="Изображение334" class="frameGraphics" id="334graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_002.png" style="border:1.0px solid #000080;padding:0;width:235.83372px;height:248.83528px" />
      </a>
      <a id="a334graphic"></a>
      <a id="bkm334graphic"></a>
    </p>
    <p class="Textbody">Оно включает следующие пункты: Файл, Правка, Вид, Терминал и упомянутая ранее Справка. Через последний пункт, в подпункте О программе, можно посмотреть список её авторов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_003.png">
        <img alt="Изображение335" class="frameGraphics" id="335graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_003.png" style="border:1.0px solid #000080;padding:0;width:472.8479px;height:393.85577px" />
      </a>
      <a id="a335graphic"></a>
      <a id="bkm335graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_003.png"> </a>
    </p>
    <p class="Textbody">И переводчиков интерфейса на русский язык:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_004.png">
        <img alt="Изображение336" class="frameGraphics" id="336graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_004.png" style="border:1.0px solid #000080;padding:0;width:472.8479px;height:393.85577px" />
      </a>
      <a id="a336graphic"></a>
      <a id="bkm336graphic"></a>
    </p>
    <p class="Textbody">А по остальным пунктам можно оценить возможности GNOME Terminal.</p>
    <p class="Textbody">В меню Файл присутствуют следующие пункты:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Открыть терминал — создание нового терминального окна; </p>
      </li>
      <li>
        <p class="Textbody">Открыть вкладку — создание вкладки (tab) в текущем окне, в которой запускается собственный экземпляр командной оболочки пользователя; </p>
      </li>
      <li>
        <p class="Textbody">Создать профиль — об этом мы поговорим, когда займёмся настройками терминала; </p>
      </li>
      <li>
        <p class="Textbody">Закрыть вкладку и Закрыть окно, смысл которых очевиден. </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_005.png">
        <img alt="Изображение337" class="frameGraphics" id="337graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_005.png" style="border:1.0px solid #000080;padding:0;width:313.84314px;height:176.83528px" />
      </a>
      <a id="a337graphic"></a>
      <a id="bkm337graphic"></a>
    </p>
    <p class="Textbody">Здесь пока остаётся только добавить, что GNOME Terminal поддерживает количество вкладок, ограниченное только здравым смыслом и соображениями удобства. Каждая вкладка по умолчанию имеет заголовок Terminal, но его легко изменить на любой мнемонически осмысленный через контекстное меню по щелчку правой кнопкой мыши на табе:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_006.png">
        <img alt="Изображение338" class="frameGraphics" id="338graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_006-572x362.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:363.84628px" />
      </a>
      <a id="a338graphic"></a>
      <a id="bkm338graphic"></a>
    </p>
    <p class="Textbody">Правда, при перезапуске заданные заголовки не сохраняются, восстанавливаясь как безликий Terminal. Но постоянный заголовок можно приписать вкладке другим способом, о чем мы поговорим, когда займёмся настройками.</p>
    <p class="Textbody">Через то же самое контекстное меню вкладки можно перемещать — влево или вправо. Впрочем, это можно сделать, и просто перетаскивая любой таб мышью. Далее, если в терминальном окне открыто две и более вкладок, в главное меню добавляется пункт Вкладки, предназначенный для манипулирования оными. Помимо переключения между вкладками и их перетасовки, он позволяет также отцепить вкладку — то есть выделить её в собственное терминальное окно:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_007.png">
        <img alt="Изображение339" class="frameGraphics" id="339graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_007-572x362.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:363.84628px" />
      </a>
      <a id="a339graphic"></a>
      <a id="bkm339graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_007.png"> </a>
    </p>
    <p class="Textbody">В меню Правка — стандартные для всех нынешних GUI'ёв пункты: Копировать, Вставить, Выделить всё. Назначение их своеобычное, так что и задерживаться на них не будем:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_008.png">
        <img alt="Изображение340" class="frameGraphics" id="340graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_008.png" style="border:1.0px solid #000080;padding:0;width:333.83685px;height:207.8274px" />
      </a>
      <a id="a340graphic"></a>
      <a id="bkm340graphic"></a>
    </p>
    <p class="Textbody">А о пунктах Профили, Комбинации клавиш, Настройки профиля поговорим, когда дело дойдёт до триариев... то есть до конфигурирования.</p>
    <p class="Textbody">В меню Вид — пункты показа/скрытия меню, переключения в полноэкранный режим и обратно (по клавише F11) и масштабирования:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_009.png">
        <img alt="Изображение341" class="frameGraphics" id="341graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_009.png" style="border:1.0px solid #000080;padding:0;width:339.8463px;height:166.85733px" />
      </a>
      <a id="a341graphic"></a>
      <a id="bkm341graphic"></a>
    </p>
    <p class="Textbody">Масштабирование выполняется также обычными комбинациями клавиш — Control++, Control+- и Control+0 (увеличение, уменьшение и приведение к исходному размеру, соответственно).</p>
    <p class="Textbody">В меню Терминал — такие пункты:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Изменить профиль, рассмотрение которого пока отложим, тем более что он ещё не активизирован; </p>
      </li>
      <li>
        <p class="Textbody">Установить заголовок — действие, аналогичное таковому через контекстное меню вкладки; </p>
      </li>
      <li>
        <p class="Textbody">Установить кодировку символов — изменить чарсет вывода вместо определённого общесистемной локалью; чрезвычайно полезная опция, когда при юникодовской кодировке приходится читать старые тексты в KOI8 или CP1251; </p>
      </li>
      <li>
        <p class="Textbody">Сброс — теоретически удаление текущего сождержимого командной строки, аналогично комбинации Control+C; практически никакого эффекта не оказывает; </p>
      </li>
      <li>
        <p class="Textbody">Сброс и очистка — кроме удаления содержимого командной строки (действительно работает), ещё и очищает экран от вывода предыдущих команд, аналогично действию команды clear. </p>
      </li>
    </ul>
    <p class="Textbody">Кроме того, в меню Терминал можно изменить размеры окна, выбрав одно из четырёх фиксированных значений (в символах): 80x24, 80x43, 132x24, 132x43. Впрочем, перемасштабировать терминальное окно произвольным образом с помощью мыши тоже не запрещается.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_010.png">
        <img alt="Изображение342" class="frameGraphics" id="342graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_010-572x222.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:223.8526px" />
      </a>
      <a id="a342graphic"></a>
      <a id="bkm342graphic"></a>
    </p>
    <p class="Textbody">Ну а через меню Справка, кроме упомянутых ранее сведений о программе, можно вызвать и собственно руководство по программе:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_011.png">
        <img alt="Изображение343" class="frameGraphics" id="343graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_011-512x572.png" style="border:1.0px solid #000080;padding:0;width:513.8558px;height:573.83685px" />
      </a>
      <a id="a343graphic"></a>
      <a id="bkm343graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_011.png"> </a>
    </p>
    <p class="Textbody">Удобство использования любой терминальной программы во многом определяется гибкостью и простотой её настроек. Посмотрим, что нам в этом отношении может предложить GNOME Terminal.</p>
    <p class="Textbody">Все настройки терминала осуществляются через модификацию профилей в соответствующем пункте меню Правка. По умолчанию имеется всего один профиль, который так и называется - Default. Однако через меню Файл -&gt; Создать профиль их можно определить сколько угодно:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_012.png">
        <img alt="Изображение344" class="frameGraphics" id="344graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_012.png" style="border:1.0px solid #000080;padding:0;width:411.8463px;height:150.83212px" />
      </a>
      <a id="a344graphic"></a>
      <a id="bkm344graphic"></a>
    </p>
    <p class="Textbody">После задания имени профиля, определения, на каком из существующих он будет основываться (а пока, кроме профиля Default, основываться больше не на чем), и нажатия кнопки Создать появляется собственно панель настройки, содержащая серию вкладок:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_013.png">
        <img alt="Изображение345" class="frameGraphics" id="345graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_013-572x318.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:319.8526px" />
      </a>
      <a id="a345graphic"></a>
      <a id="bkm345graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_013.png"> </a>
    </p>
    <p class="Textbody">Как видно из скриншота, во вкладке Общие можно изменить имя профиля (если это необходимо), задать шрифт — системный, определённый в общих настройках Cinnamon, или любой произвольный, разрешив или запретив, заодно, полужирное его начертание, включить или выключить строку меню и звуковые сигналы (например, при ошибках), изменить форму курсора и задать символы — ограничители командного «слова», выделяемого двойным щелчком мыши, наконец, размер терминального окна.</p>
    <p class="Textbody">Во вкладке Заголовок и команда определяются:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">исходный заголовок терминала; </p>
      </li>
      <li>
        <p class="Textbody">поведение заголовка в зависимости от устанавливаемого исполняемой программой — замещёние исходного, присоединение к нему, и так далее; </p>
      </li>
      <li>
        <p class="Textbody">запуск командной оболочки как обычной интерактивной или регистрационной оболочки пользователя (login shell); при обычных настройках bash разницы между ними почти нет (у меня так нет вообще), но при желании это положение можно изменить, особенно, если использовать не bash, а zsh; </p>
      </li>
      <li>
        <p class="Textbody">запуск иной команды вместо пользовательского шелла: так, для разработчиков это может быть интерпретатор любимого языка программирования, а для обычных пользователей — например, Midnight Commander; </p>
      </li>
      <li>
        <p class="Textbody">поведение терминального окна по завершении исполняемой в нём команды — закрытие терминала или перезапуск команды. </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_014.png">
        <img alt="Изображение346" class="frameGraphics" id="346graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_014-572x318.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:319.8526px" />
      </a>
      <a id="a346graphic"></a>
      <a id="bkm346graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_014.png"> </a>
    </p>
    <p class="Textbody">Во вкладке Цвета определяются цвет текста и фона — приводимый скриншот в комментариях не нуждается:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_015.png">
        <img alt="Изображение347" class="frameGraphics" id="347graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_015-572x318.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:319.8526px" />
      </a>
      <a id="a347graphic"></a>
      <a id="bkm347graphic"></a>
    </p>
    <p class="Textbody">С вкладкой Тип фона также всё ясно — его можно сделать сплошным (тем, что был определён в предыдущей вкладке), задать фоновое изображение (в том числе и с прокруткой оного) или установить прозрачность — в этом случае сквозь терминальное окно будут просвечивать обои рабочего стола:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_016.png">
        <img alt="Изображение348" class="frameGraphics" id="348graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_016-572x318.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:319.8526px" />
      </a>
      <a id="a348graphic"></a>
      <a id="bkm348graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_016.png"> </a>
    </p>
    <p class="Textbody">Во вкладке Прокрутка устанавливается положение полоски скроллинга и задаётся (в строках) длина прокручиваемой истории команд:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_017.png">
        <img alt="Изображение349" class="frameGraphics" id="349graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_017-572x318.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:319.8526px" />
      </a>
      <a id="a349graphic"></a>
      <a id="bkm349graphic"></a>
    </p>
    <p class="Textbody">Наконец, во вкладке Совместимость можно переопределить назначение клавиш Backspace и Delete. Зачем это может понадобиться — исчерпывающе сказано в комментарии (как правило, не за чем):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_018.png">
        <img alt="Изображение350" class="frameGraphics" id="350graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_018-572x318.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:319.8526px" />
      </a>
      <a id="a350graphic"></a>
      <a id="bkm350graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_018.png"> </a>
    </p>
    <p class="Textbody">После создания дополнительных профилей их имена появляются как альтернативы выбора в меню Файл -&gt; Открыть терминал — в новом терминальном окне будет запущен выбранный профиль:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_019.png">
        <img alt="Изображение351" class="frameGraphics" id="351graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_019.png" style="border:1.0px solid #000080;padding:0;width:520.8479px;height:176.83528px" />
      </a>
      <a id="a351graphic"></a>
      <a id="bkm351graphic"></a>
    </p>
    <p class="Textbody">Однако, как явствует из меню Файл -&gt; Открыть вкладку, и в каждой вкладке одного и того же окна теперь может быть выбран тот или иной профиль, со всеми своими атрибутами — шрифтом, расцветкой, заголовком, типом фона и так далее:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_020.png">
        <img alt="Изображение352" class="frameGraphics" id="352graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_020.png" style="border:1.0px solid #000080;padding:0;width:520.8479px;height:176.83528px" />
      </a>
      <a id="a352graphic"></a>
      <a id="bkm352graphic"></a>
    </p>
    <p class="Textbody">Это удобно для различения вкладок разного назначения. Так, я определяю разные параметры для обычного пользовательского профиля и профиля вкладки, в которой я обычно получаю права root'а (командой sudo -i). Список заданых профилей можно просмотреть через меню Правка -&gt; Профили:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_021.png">
        <img alt="Изображение353" class="frameGraphics" id="353graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_021-572x296.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:297.85574px" />
      </a>
      <a id="a353graphic"></a>
      <a id="bkm353graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_021.png"> </a>
    </p>
    <p class="Textbody">И, к слову сказать, выбрать профиль можно не только при открытии окна или вкладки, но и для уже открытых: это делается через главное меню Терминал -&gt; Использовать профиль или меню контекстное. Перенастройка любого профиля также может быть выполнена в любой момент после его создания: через меню Правка -&gt; Настроить профиль или через кнопку Изменить на панели списка профилей вызывается та же самая настроечная панель, что и при создании профиля.</p>
    <p class="Textbody">Завершая разговор о настройках, обратимся к пропущенному нами ранее пункту меню Правка -&gt; Комбинации клавиш. Как явствует из названия и скриншота, здесь можно переопределить сочетания клавиш, привязанные к любому из определённых по умолчанию действий:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/01-gnome_022.png">
        <img alt="Изображение354" class="frameGraphics" id="354graphic" src="http://alv.me/wp-content/img/im_cin_img/01-gnome_022-572x376.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:377.83057px" />
      </a>
      <a id="a354graphic"></a>
      <a id="bkm354graphic"></a>
    </p>
    <p class="Textbody">Для этого достаточно дважды щёлкнуть по строке нужного действия и нажать новую комбинацию. Правда, определить собственное действие, отсутствующее в списке, не получится.</p>
    <p class="Textbody">Таким образом, можно видеть, что по своей функциональности GNOME Terminal вполне соответствует своему назначению. И к нему можно подбирать не столько альтернативы, сколько дополнения.</p>
    <h3 id="toc155"><a id="RefHeading17521713816058"></a><a id="bkmRefHeading17521713816058"></a><a id="toc154"></a><a id="bkmtoc154"></a><a id="RefHeading5781136957987"></a><a id="bkmRefHeading5781136957987"></a><a id="bkmRefHeading5781136957987"></a><a id="bkmbkmRefHeading5781136957987"></a>Terminator</h3>
    <p class="Textbody">Таким дополнением к GNOME Terminal может стать терминальная программа Terminator. Она имеется в официальном репозитории в виде одноимённого пакета, который устанавливается стандартным образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install terminator</span> </p>
    <p class="Textbody">После этого программа обнаруживается в секции Администрирование главного меню Cinnamon, где она носит имя Терминатор. И после запуска выглядит следующим образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_023.png">
        <img alt="Изображение355" class="frameGraphics" id="355graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_023-572x353.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:354.851px" />
      </a>
      <a id="a355graphic"></a>
      <a id="bkm355graphic"></a>
    </p>
    <p class="Textbody">Как и в GNOME Terminal, в Terminator'е строки меню нет — но не по умолчанию, а от слова «вообще»: все действия выполняются через контекстное меню по правому клику мыши:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_024.png">
        <img alt="Изображение356" class="frameGraphics" id="356graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_024.png" style="border:1.0px solid #000080;padding:0;width:307.8337px;height:408.8227px" />
      </a>
      <a id="a356graphic"></a>
      <a id="bkm356graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_024.png"> </a>
    </p>
    <p class="Textbody">И первый же взгляд на контекстное меню выявляет главную (и убийственную) фичу Terminator'а — возможность разбиения терминального окна на произвольное количество субтерминалов, каждый из которых имеет свою титульную строку, и в каждом запущен независимый экземпляр командной оболочки:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_025.png">
        <img alt="Изображение357" class="frameGraphics" id="357graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_025-539x572.png" style="border:1.0px solid #000080;padding:0;width:540.8416px;height:573.83685px" />
      </a>
      <a id="a357graphic"></a>
      <a id="bkm357graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_025.png"> </a>
    </p>
    <p class="Textbody">Число субтерминалов ограничено только целесообразностью и здравым смыслом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_025a.png">
        <img alt="Изображение358" class="frameGraphics" id="358graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_025a-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a358graphic"></a>
      <a id="bkm358graphic"></a>
    </p>
    <p class="Textbody">Не запрещается и создание вкладок, причём каждая вкладка может быть разбита независимо от других.</p>
    <p class="Textbody">Временно развернуть один из субтерминалов на всё окно можно выбором пункта Раскрыть терминал. При этом скрываются и все вкладки, кроме текущей, а в контекстном меню появляется пункт Восстановить все терминалы, возвращающий разбиение на субтерминалы и делающий видимыми ранее открытые вкладки.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_026.png">
        <img alt="Изображение359" class="frameGraphics" id="359graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_026.png" style="border:1.0px solid #000080;padding:0;width:284.8542px;height:268.82898px" />
      </a>
      <a id="a359graphic"></a>
      <a id="bkm359graphic"></a>
    </p>
    <p class="Textbody">Для полного снятия разбиения на субтерминалы предназначен пункт Закрыть контекстного меню.</p>
    <p class="Textbody">Из того же контекстного меню можно видеть, что Terminator позволяет переключать кодировку вывода — независимо для каждой вкладки и каждого субтерминала.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_027.png">
        <img alt="Изображение360" class="frameGraphics" id="360graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_027-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a360graphic"></a>
      <a id="bkm360graphic"></a>
    </p>
    <p class="Textbody">Причём список доступных кодировок трудно обозрим, и включает все кодировки кириллицы, о которых я только слышал:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_028.png">
        <img alt="Изображение361" class="frameGraphics" id="361graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_028-313x572.png" style="border:1.0px solid #000080;padding:0;width:314.8258px;height:573.83685px" />
      </a>
      <a id="a361graphic"></a>
      <a id="bkm361graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_028.png"> </a>
    </p>
    <p class="Textbody">В пункте Параметры, как обычно, вызывает панель настройки программы о пяти вкладках. В первой, Global, настраивается фокусировка, положение вкладок (они могут располагаться с любой стороны окна), расцвета титульных строк субтерминалов и вкладок, и так далее:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_029.png">
        <img alt="Изображение362" class="frameGraphics" id="362graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_029-572x468.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:469.82428px" />
      </a>
      <a id="a362graphic"></a>
      <a id="bkm362graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_029.png"> </a>
    </p>
    <p class="Textbody">Во вкладке Profiles — шесть субвкладок, смысл которых понятен из скриншотов или по аналогии с настройкой профилей GNOME Terminal:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_030.png">
        <img alt="Изображение363" class="frameGraphics" id="363graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_030-572x468.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:469.82428px" />
      </a>
      <a id="a363graphic"></a>
      <a id="bkm363graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_031.png">
        <img alt="Изображение364" class="frameGraphics" id="364graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_031-572x468.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:469.82428px" />
      </a>
      <a id="a364graphic"></a>
      <a id="bkm364graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_031.png"> </a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_032.png">
        <img alt="Изображение365" class="frameGraphics" id="365graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_032-572x468.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:469.82428px" />
      </a>
      <a id="a365graphic"></a>
      <a id="bkm365graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_033.png">
        <img alt="Изображение366" class="frameGraphics" id="366graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_033-572x468.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:469.82428px" />
      </a>
      <a id="a366graphic"></a>
      <a id="bkm366graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_033.png"> </a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_034.png">
        <img alt="Изображение367" class="frameGraphics" id="367graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_034-572x468.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:469.82428px" />
      </a>
      <a id="a367graphic"></a>
      <a id="bkm367graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_035.png">
        <img alt="Изображение368" class="frameGraphics" id="368graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_035-572x468.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:469.82428px" />
      </a>
      <a id="a368graphic"></a>
      <a id="bkm368graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_035.png"> </a>
    </p>
    <p class="Textbody">Профиль может быть определён для каждого субтерминала и каждой вкладки независимо друг от друга.</p>
    <p class="Textbody">Вкладка Layouts позволяет создать разбиение окна на субтерминалы и привязать его к определённому профилю:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_036.png">
        <img alt="Изображение369" class="frameGraphics" id="369graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_036-572x468.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:469.82428px" />
      </a>
      <a id="a369graphic"></a>
      <a id="bkm369graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_036.png"> </a>
    </p>
    <p class="Textbody">Во вкладке Keybindings настраиваются горячие клавиши:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_037.png">
        <img alt="Изображение370" class="frameGraphics" id="370graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_037-572x468.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:469.82428px" />
      </a>
      <a id="a370graphic"></a>
      <a id="bkm370graphic"></a>
    </p>
    <p class="Textbody">Во вкладке Plugins включаются и выключаются дополнительные модули:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_038.png">
        <img alt="Изображение371" class="frameGraphics" id="371graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_038-572x468.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:469.82428px" />
      </a>
      <a id="a371graphic"></a>
      <a id="bkm371graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_038.png"> </a>
    </p>
    <p class="Textbody">Они отражаются в контекстном меню. Например, включение модуля TerminalSot добаляет в него пункт Снимок окна терминала:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_039.png">
        <img alt="Изображение372" class="frameGraphics" id="372graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_039.png" style="border:1.0px solid #000080;padding:0;width:307.8337px;height:486.83215px" />
      </a>
      <a id="a372graphic"></a>
      <a id="bkm372graphic"></a>
    </p>
    <p class="Textbody">Который предлагается сохранить в виде файла:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/02-terminator_040.png">
        <img alt="Изображение373" class="frameGraphics" id="373graphic" src="http://alv.me/wp-content/img/im_cin_img/02-terminator_040-572x449.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:450.851px" />
      </a>
      <a id="a373graphic"></a>
      <a id="bkm373graphic"></a>
    </p>
    <p class="Textbody">В отличие от GNOME Terminal, где все изменения вступают в силу немедленно, после включения или отключения любой опции, в Terminator'е они претворяются в действительность в момент закрытия панели настроек. Аналога кнопки Применить, характерной для KDE-приложений, также не имеется.</p>
    <p class="Textbody">В общем, функционал Terminator'а может быть востредован в ряде случаев. Однако настройки его не вполне прозначны, и потому в повседневной жизни проще применять GNOME Terminal.</p>
    <h3 id="toc156"><a id="RefHeading17541713816058"></a><a id="bkmRefHeading17541713816058"></a><a id="toc155"></a><a id="bkmtoc155"></a><a id="RefHeading5801136957987"></a><a id="bkmRefHeading5801136957987"></a><a id="bkmRefHeading5801136957987"></a><a id="bkmbkmRefHeading5801136957987"></a>Выпадающий терминал Tilda</h3>
    <p class="Textbody">Некогда, с подачи Сергея Голубева, проникся я идеей выпадающих (drop-down) терминалов — тогда в виде Yakuake, ибо работал преимущественно в среде KDE. Проникся настолько, что почти перестал применять обычный эмулятор терминала, в те времена Konsole: практически во всех случаях удобней оказывалось прибегнуть либо к терминальному окну, встроенному в файловый менеджер (будь то Konqueror или Dolphin) или текстовый редактор (сиречь Kate), либо вызвать терминал выпадающий.</p>
    <p class="Textbody">Переключившись на рабочие среды, основанные на Gtk (Xfce, Unity, Cinnamon), я начал подыскивать аналогичные средства эмуляции терминального режима. Как было сказано в очерке про Nemo, с терминалом, встраиваемым в этот файловые менеджеры, в конце концов решилась. А по части выпадающих терминалов имелся изрядный выбор: Terra Terminal, Guake и Tilda.</p>
    <p class="Textbody">К сожалению, первая из названных программ прекратила своё развитие, а две остальные я применял попеременно, пока в итоге не остановился последней: основанная на Gtk 3, Tilda, как мне кажется, лучше вписывается в окружение Cinnamon, базирующееся на тех же библиотеках, нежели Guake, в основе которой лежит Gtk 2. Впрочем, с практической точки зрения, разница между этими двумя программами не велика. И по описанию Tilda легко понять, как работать с Guake, буде такая необходимость возникнет.</p>
    <p class="Textbody">Пакет Tilda входит в официальный репозиторий Mint (точнее, в ту его часть, которая напрямую заимствована из Ubuntu), и потому устанавливается стандартно:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install tilda</span> </p>
    <p class="Textbody">После чего Tilda может быть запущена из одноимённого пункта секции Администрирование главного меню Cinnamon. Однако для любого выпадающего терминала такой метод запуска имеет не много смысла — он всегда должен быть под рукой. И потому надо обеспечить Tilda постоянное присутствие посредством Системных настроек и их пункта Автозагрузка:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/03-tilda_041.png">
        <img alt="Изображение374" class="frameGraphics" id="374graphic" src="http://alv.me/wp-content/img/im_cin_img/03-tilda_041-572x441.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:442.83844px" />
      </a>
      <a id="a374graphic"></a>
      <a id="bkm374graphic"></a>
    </p>
    <p class="Textbody">Однако первый раз имеет смысл запустить Tilda из главного меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/03-tilda_042.png">
        <img alt="Изображение375" class="frameGraphics" id="375graphic" src="http://alv.me/wp-content/img/im_cin_img/03-tilda_042-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a375graphic"></a>
      <a id="bkm375graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/03-tilda_042.png"> </a>
    </p>
    <p class="Textbody">И заняться её настройками: соответствующая панель при первом запуске вызывается автоматически:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/03-tilda_043.png">
        <img alt="Изображение376" class="frameGraphics" id="376graphic" src="http://alv.me/wp-content/img/im_cin_img/03-tilda_043-572x364.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:365.84946px" />
      </a>
      <a id="a376graphic"></a>
      <a id="bkm376graphic"></a>
    </p>
    <p class="Textbody">Правда, на скриншоте дан вид с уже сделанными мной настройками, но смысл их, я думаю, понятен без комментариев — как и настроек в остальных вкладках панели. Остановлюсь только на трёх моментах.</p>
    <p class="Textbody">Во вкладке Внешний вид можно не только задать размеры терминального окна, но и его центрирование — не только по горизонтали, но и по вертикали, включить анимацию и её направление:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/03-tilda_044.png">
        <img alt="Изображение377" class="frameGraphics" id="377graphic" src="http://alv.me/wp-content/img/im_cin_img/03-tilda_044-572x364.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:365.84946px" />
      </a>
      <a id="a377graphic"></a>
      <a id="bkm377graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/03-tilda_044.png"> </a>
    </p>
    <p class="Textbody">При центрировании по обеим осям и включённой анимации выпадающий терминал можно при желании превратить в терминал, «всплывающий» посреди экрана:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/03-tilda_045.png">
        <img alt="Изображение378" class="frameGraphics" id="378graphic" src="http://alv.me/wp-content/img/im_cin_img/03-tilda_045-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a378graphic"></a>
      <a id="bkm378graphic"></a>
    </p>
    <p class="Textbody">Во вкладке Заголовок и команда можно изменить начальный заголовок терминала и расположение заголовка, автоматически присваиваемого запущенной в нём командой (например, Midnight Commander):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/03-tilda_046.png">
        <img alt="Изображение379" class="frameGraphics" id="379graphic" src="http://alv.me/wp-content/img/im_cin_img/03-tilda_046-572x364.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:365.84946px" />
      </a>
      <a id="a379graphic"></a>
      <a id="bkm379graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/03-tilda_046.png"> </a>
    </p>
    <p class="Textbody">Во вкладке Сочетание клавиш устанавливается способ вызова терминала — по умолчанию почему-то это клавиша F1. Что я немедленно заменил на стандартную для программ такого рода клавишу F12:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/03-tilda_047.png">
        <img alt="Изображение380" class="frameGraphics" id="380graphic" src="http://alv.me/wp-content/img/im_cin_img/03-tilda_047-572x364.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:365.84946px" />
      </a>
      <a id="a380graphic"></a>
      <a id="bkm380graphic"></a>
    </p>
    <p class="Textbody">Повторное нажатие той же клавиши убирает выпадающий терминал с глаз долой.</p>
    <p class="Textbody">Можно переопределить и комбинации клавиш для выполнения других действий. А по умолчанию работают все стандартные для большинства терминальных программ хоткеи:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Shift+Control+T — создание новой вкладки; </p>
      </li>
      <li>
        <p class="Textbody">Shift+Control+W — закрытие текущей вкладки; </p>
      </li>
      <li>
        <p class="Textbody">Control+PageUp — переход на предыдущую вкладку; </p>
      </li>
      <li>
        <p class="Textbody">Control+PageDown — переход на следующую вкладку; </p>
      </li>
      <li>
        <p class="Textbody">Shift+Control+C — копирование выделенного фрагмента в буфер; </p>
      </li>
      <li>
        <p class="Textbody">Shift+Control+V — вставка содержимого буфера позицию курсора; </p>
      </li>
      <li>
        <p class="Textbody">Shift+Control+Q — выход из Tilda. </p>
      </li>
    </ul>
    <p class="Textbody">Из контекстного меню по правому мышиному клику можно открыть новую вкладку и закрыть существующую, копировать и вставлять выделенные мышью блоки, переключиться в полноэкранный режим и вызвать панель настроек:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/03-tilda_048.png">
        <img alt="Изображение381" class="frameGraphics" id="381graphic" src="http://alv.me/wp-content/img/im_cin_img/03-tilda_048.png" style="border:1.0px solid #000080;padding:0;width:181.82426px;height:258.85104px" />
      </a>
      <a id="a381graphic"></a>
      <a id="bkm381graphic"></a>
    </p>
    <p class="Textbody">Кроме контекстного меню, новую вкладку, как только что было сказано, можно создать и обычными для большинства терминальных программ хоткеями — Shift+Control+T. Каждой новой вкладке присваивается заголовок, установленный в панели настроек по умолчанию. Вкладки можно перемещать, просто перетаскивая их мышью.</p>
    <p class="Textbody">На этом функционал программы исчерпывается — однако больше от неё ничего и не нужно. А свои непосредственные функции — представить интерфейс командной строки в нужном месте и в нужное время, Tilda выполняет исправно и к тому же быстро — заметно быстрее, чем Guake.</p>
    <h2 id="toc157"><a id="RefHeading17561713816058"></a><a id="bkmRefHeading17561713816058"></a><a id="toc156"></a><a id="bkmtoc156"></a><a id="RefHeading12861136957987"></a><a id="bkmRefHeading12861136957987"></a><a id="bkmRefHeading12861136957987"></a><a id="bkmbkmRefHeading12861136957987"></a>Текстовые редакторы</h2>
    <p class="Textbody">Текстовый редактор — третья из важнейших программ «джентльменского набора применителя». И потому этот очерк будет посвящён их рассмотрению — как вообще, так и на конкретных примерах.</p>
    <h3 id="toc158"><a id="RefHeading17581713816058"></a><a id="bkmRefHeading17581713816058"></a><a id="toc157"></a><a id="bkmtoc157"></a><a id="RefHeading5821136957987"></a><a id="bkmRefHeading5821136957987"></a><a id="bkmRefHeading5821136957987"></a><a id="bkmbkmRefHeading5821136957987"></a>Введение</h3>
    <p class="Textbody">Текстовый редактор в равной степени необходим программисту и сисадмину, веб-мастеру и блогеру, а также массе трудящихся, чья сфера деятельности с IT никак не связана: «традиционным» журналистам, писателям и поэтам, редакторам и переводчикам, научным работникам... короче говоря, всем работникам профессий, которые в советское время было принято называть творческими. И всем, чьё творчество связано со СЛОВОМ.</p>
    <p class="Textbody">Правда, за исключением первых трёх категорий, большинство творческих работников об этом и не подозревают — за исключением, конечно, тех немногих из них, кто в одной из своих прошлых жизней каким-то боком не пересекался с IT-сферой. А потому, сочиняя свою нетленку или прелагая чужую, они обычно пользуются таким неуклюжим инструментам, как word processor (которые по русски почему-то называются текстовыми процессорами, хотя на самом деле text processor — это нечто совсем иное). И неважно, как этот инструмент называется — MS Writer'ом, AOo Writer'ом, Libre Writer'ом или даже AbiWord'ом — важно, что все они разрабатывались для изготовления бюрократических циркуляров, а не для творческой работы.</p>
    <p class="Textbody">Разумеется, представители клана творческо-технологического, в частности, линуксописатели (в том числе и автор этих строк), предпринимали многочисленные попытки изменить существующее положение дел, открыв глаза собратьям по клану творческо-гуманитарному на мощь и величие текстовых редакторов вкупе с набором несложных утилит командной строки, таких, как cat, split, find, grep etc., или их графических фронт-эндов. Попытки эти, за небольшими частными исключениями, терпели фетяску. В том числе и потому, что многие из них предпринимались с негодными средствами, но к этому вопросу я ещё вернусь в заключительных строках.</p>
    <p class="Textbody">В Cinnamon-редакции Mint в роли штатного текстового редактора выступает Gedit. Однако, если GNOME Terminal, как было только что показано, способен выполнять свои обязанности вполне справно, то Gedit определённо требует подбора альтернативы. Так что ниже я очень вкратце рассмотрю базовую его функциональность. А потом перейду к описанию альтернатив, которых оказывается целых две — текстовые редакторы (или лёгкие IDE) Geany и Komodo Edit.</p>
    <h3 id="toc159"><a id="RefHeading17601713816058"></a><a id="bkmRefHeading17601713816058"></a><a id="toc158"></a><a id="bkmtoc158"></a><a id="RefHeading5841136957987"></a><a id="bkmRefHeading5841136957987"></a><a id="bkmRefHeading5841136957987"></a><a id="bkmbkmRefHeading5841136957987"></a>Текстовый редактор Gedit</h3>
    <p class="Textbody">Текстовый редактор Gedit, подобно GNOME Terminal, заимствован из среды GNOME 3. Устанавливаясь по умолчанию при стандартной инсталляции, он вызывается из секции Стандартные главного меню Cinnamon, где фигурирует под именем просто Текстовый редактор. Его можно также запустить, щёлкнув на имени чисто текстового файла (plain text, )7 Или, зафиксировав курсор на имени, например, html-файла, правым кликом мыши вызвать контекстное меню, выбрав в нём пункт Open with -&gt; Текстовый редактор:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_49.png">
        <img alt="Изображение382" class="frameGraphics" id="382graphic" src="http://alv.me/wp-content/img/im_cin_img/04-gedit_49.png" style="border:1.0px solid #000080;padding:0;width:514.8385px;height:495.82742px" />
      </a>
      <a id="a382graphic"></a>
      <a id="bkm382graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_49.png"> </a>
    </p>
    <p class="Textbody">После чего он предстаёт примерно в таком виде:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_50.png">
        <img alt="Изображение383" class="frameGraphics" id="383graphic" src="http://alv.me/wp-content/img/im_cin_img/04-gedit_50-572x366.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:367.85263px" />
      </a>
      <a id="a383graphic"></a>
      <a id="bkm383graphic"></a>
    </p>
    <p class="Textbody">Последующие файлы будут открываться в том же окне — в новых его вкладках. Для ориентации в которых можно включить боковую панель (через меню Вид или клавишей F9):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_51.png">
        <img alt="Изображение384" class="frameGraphics" id="384graphic" src="http://alv.me/wp-content/img/im_cin_img/04-gedit_51-572x366.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:367.85263px" />
      </a>
      <a id="a384graphic"></a>
      <a id="bkm384graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_51.png"> </a>
    </p>
    <p class="Textbody">Как видно на скриншоте, Gedit обеспечивает подсветку синтаксиса разных языков программирования, а также языков разметки. Из других особенностей можно отметить наращиваемый поиск (здесь он называется последовательным), как в браузерах. Только здесь он вызывается комбинацией клавиш Control+K:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_52.png">
        <img alt="Изображение385" class="frameGraphics" id="385graphic" src="http://alv.me/wp-content/img/im_cin_img/04-gedit_52-572x366.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:367.85263px" />
      </a>
      <a id="a385graphic"></a>
      <a id="bkm385graphic"></a>
    </p>
    <p class="Textbody">Имеется также проверка орфографии, в том числе и автоматическая, а также статистика документа (в меню Сервис):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_53.png">
        <img alt="Изображение386" class="frameGraphics" id="386graphic" src="http://alv.me/wp-content/img/im_cin_img/04-gedit_53.png" style="border:1.0px solid #000080;padding:0;width:447.8274px;height:289.84314px" />
      </a>
      <a id="a386graphic"></a>
      <a id="bkm386graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_53.png"> </a>
    </p>
    <p class="Textbody">В Gedit настраиваются (Правка -&gt; Параметры) режим «мягкого» переноса, включение/выключение нумерации строк и так далее:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_54.png">
        <img alt="Изображение387" class="frameGraphics" id="387graphic" src="http://alv.me/wp-content/img/im_cin_img/04-gedit_54-572x509.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:510.83212px" />
      </a>
      <a id="a387graphic"></a>
      <a id="bkm387graphic"></a>
    </p>
    <p class="Textbody">Можно поменять шрифт и цветовую схему:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_55.png">
        <img alt="Изображение388" class="frameGraphics" id="388graphic" src="http://alv.me/wp-content/img/im_cin_img/04-gedit_55-572x509.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:510.83212px" />
      </a>
      <a id="a388graphic"></a>
      <a id="bkm388graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_55.png"> </a>
    </p>
    <p class="Textbody">Во вкладке Модули включаются или отключаются дополнительные функции, такие, как изменение регистра выделенного текста и другие (ряд модулей включён по умолчанию):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_56.png">
        <img alt="Изображение389" class="frameGraphics" id="389graphic" src="http://alv.me/wp-content/img/im_cin_img/04-gedit_56-572x509.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:510.83212px" />
      </a>
      <a id="a389graphic"></a>
      <a id="bkm389graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/04-gedit_56.png"> </a>
    </p>
    <p class="Textbody">В репозитории для Gedit доступно несколько плагинов, большинство из которых ориантировано на специальные задачи разработчиков или Tex-верстальщиков. Однако пакет gedit-plugins — более общего назначения, почему и подлежит и подлежит установке:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install gedit-plugins</span> </p>
    <p class="Textbody">После этого во вкладке Модули добавляется ряд новых функций, таких, как автоматическое закрытие скобок и кавычек, знакомство с которыми оставляю на усмотрение заинтересованных лиц.</p>
    <p class="Textbody">Мне Gedit кажется откровенно скучным. Кроме того, не вполне понятно его позиционирование: в качестве лёгкого редактора, предназначенного для правки конфигов (подобно Mousepad или Leafpad) он явно избыточен, а для всамделишней работы с большими текстами — недостаточно функционален, даже при условии установки дополнительных плагинов. В частности, в нём напрочь отсутствует возможность работы с проектами, что обесценивало для меня любые иные его достоинства, даже если бы таковые нашлись. И потому в следующих очерках я обращусь к возможным альтернативам Gedit'а.</p>
    <h3 id="toc160"><a id="RefHeading17621713816058"></a><a id="bkmRefHeading17621713816058"></a><a id="toc159"></a><a id="bkmtoc159"></a><a id="RefHeading5861136957987"></a><a id="bkmRefHeading5861136957987"></a><a id="bkmRefHeading5861136957987"></a><a id="bkmbkmRefHeading5861136957987"></a>Альтернативные редакторы: введение</h3>
    <p class="Textbody">Таким образом, Gedit не подходит для сочинения объёмных материалов, хотя бы серии статей в рамках одной темы, не говоря уже о книгах, когда приходится работать со множеством взаимосвязанных текстовых документов. И тут, как ни странно, оказывается, что требования к текстовому редактору со стороны применителя-текстовика часто пересекаются с таковыми разработчика, сочиняющего что-либо посложнее Hello, world!, с некоторым, иногда большим, числом файлов, предназначенных для реализации одной задачи. И потому обоим нашим героям от текстового редактора требуется средства управления проектами и манипуляций файлами. Причём не обязательно файлами только текстовыми — ведь некоторые авторы имеют обыкновение иллюстрировать своим материалы.</p>
    <p class="Textbody">Кроме того, сочинение оригинальных материалов не сводится к их набору из головы (ну или кто чем эти материалы сочиняет). Потому что набор текста оказывается неотделимым от его редактирования. Под которым в рассматриваемом случае подразумевается не только (и не столько) исправление орфографических ошибок и опечаток, сколько стилистическая правка. Которая часто требует свободного перемещёния между строками, абзацами и даже страницами уже набранного текста. И тут очень важной оказывается развитая система кейбиндингов, позволяющая мгновенно, без нудного стучания по клавишам Left и Right, Up и Down, переместиться к участку текста, требующего стилистической правки.</p>
    <p class="Textbody">Предвижу возражение: стилистическую правку можно отложить на потом — после полного набора текста. И с негодованием его отвергаю: каждый, для кого стилистика текста — не пустой звук, знает, что удачный стилистический оборот, неожиданно пришедший в голову по ассоциации, может испариться из неё на следующей странице, не оставив ничего, кроме сожаления:</p>
    <p class="Textbody">Ай да я, ай да сукин сын: так здорово придумал — и забыл...</p>
    <p class="Textbody">Наконец, ещё одна составляющая набора и редактирования текста — разметка. Да, я понимаю стремление отделить <span style="text-decoration:line-through">мух от котлет</span> набор и вёрстку. Но дело в том, что при работе на онлайн (а большинство нынешних сочинителей с оффлайном завязали) разметка оказывается частью стилистики, и подлежит немедленному претворению в жизнь. Иначе ищи потом <span style="text-decoration:line-through">ветра в поле</span> фрагмента, который хотел бы выделить перечёркнутым начертанием, тегом strong или emphasis. Не говоря уж о ссылках на использованные по ходу дела материалы, про которые тоже легко забыть, или которые потом приходится долго искать.</p>
    <p class="Textbody">В штатном режиме текстовые редакторы предполагают единственный способ ввода тегов (или элементов разметки TeX'а, если речь идёт о подготовке к «бумаге»): вручную. Что а) скучно, б) долго, в) чревато ошибками. И, наконец, просто отвлекает от процесса сочинительства. Но тут на помощь приходит режим записи макрокоманд, привязываемых к хоткеям. А вот этот режим в текстовом редакторе может отсутствовать или присутствовать. А если присутствует — может быть реализованным по разному: просто, но слабо, мощно, но сложно; в идеале, конечно, мощно и просто.</p>
    <p class="Textbody">Так что выбор редактора очень сильно влияет на эффективность работы с текстом на всех её стадиях — от сочинения до разметки. И эффективность эта определяется не только наличием «рюшечек и менюшечек» или их отсутствием, а зависит от многих факторов. И потому следующие несколько абзацев посвящены этому вопросу. Только сразу предупреждаю: тем, кто полагает, что Vim/Emacs наше фсио, лучше их не читать. Как, впрочем, и весь этот очерк...</p>
    <p class="Textbody">Программисты находят решение своих задач в применении всякого рода IDE, то есть интегрированных сред разработки (Integrated Development Environment). Интегрированных сред для сочинительства нарративных текстов ещё никем не придумано. Но в этом качестве отлично могут выступить программы, которые лежат там, где кончаются текстовые редакторы и начинаются IDE. А вот их список оказывается очень коротким. Если исключить практически сошедший со сцены NEdit и его клон QEdit, так на эту сцену и не вышедший (в причины обоих явлений вдаваться не буду), то он сведётся к двум с половиной позициям: Komodo Edit за номером один, Geany за номером два и Kate за номером полтора.</p>
    <p class="Textbody">Почему столь унижен Kate? Да потому, что, хотя в нём собственные средства управления проектами появились едва ли впервые среди текстовых редакторов такого рода (апологеты Vim и особенно Emacs, подождите немного), по сию пору остаются в зачаточном состоянии. Хотя этот редактор несравненен по части управления файлами, но это — лишь одна из сторон проектного менеджмента. К тому же Kate, будучи приложением KDE, не очень хорошо вписывается в среду Cinnamon.</p>
    <p class="Textbody">Между тем Geany, хотя по части управления файлами он и отстал от Kate, все остальные аспекты управления проектами развивались со страшной научно-фантастической силой. И ныне этот некогда просто текстовый редактор именуется обычно лёгкой IDE. Хотя именно вследствие своей лёгкости, то есть — не перегруженности чисто программистскими фичами, он отлично подходит на роль основного инструмента применителя-текстовика.</p>
    <p class="Textbody">Однако оказывается, что Komodo Edit превосходит Geany и по части управления проектами (в частности, позволяя одновременно держать открытыми несколько разных), так и в плане файловых манипуляций, включая в себя полноценный файловый менеджер с функциями просмотра изображений. Средства навигации по тексту в нём чрезвычайно изобильны и настраиваемы беспредельно. А уж по части сочинения макросов с ним не может конкурировать ни один текстоый редактор из тех, что я видел.</p>
    <p class="Textbody">А что же Emacs и Vim? — спросите вы меня. Отвечаю: это те самые попытки с негодными средствами, о которых я упоминал в начале этой страницы. Да, и из того, и из другого мострактора (монстроидального редактора) можно сделать интегрированную среду для разработки любого рода текстов — от исходников до «нарративников». Но её придётся делать, затрачивая силы и время. А подчас ещё и приобретая по ходу дела некие специфические навыки, например, для Emacs'а — программирования на Lisp. Навыки, которые применителю-текстовику больше никогда и нигде не понадобятся.</p>
    <p class="Textbody">Поэтому меня умиляет, когда на всяких форумах на вопрос о выборе текстового редактора технологически продвинутые граждане в качестве универсального решения предлагают Vim/Emacs (в зависимости от своей религиозной ориентации). Для меня это просто показатель непонимания означенными гражданами специфики сочинительской работы. А ведь профессиональный сочинитель воспримет (и воспринимает) такой совет как форменное издевательство. Ибо в том же Geany или Komodo Edit он мог бы иметь всё ему необходимое «искаропки» — хотя он об этом пока и не подозревает.</p>
    <p class="Textbody">Так что далее будут последовательно рассмотрены обе редакторские альтернативы — каждая из них заслуживает отдельного полноценного очерка.</p>
    <h2 id="toc161"><a id="RefHeading17641713816058"></a><a id="bkmRefHeading17641713816058"></a><a id="toc160"></a><a id="bkmtoc160"></a><a id="RefHeading12881136957987"></a><a id="bkmRefHeading12881136957987"></a><a id="bkmRefHeading12881136957987"></a><a id="bkmbkmRefHeading12881136957987"></a>Текстовый редактор Geany</h2>
    <h3 id="toc162"><a id="RefHeading17661713816058"></a><a id="bkmRefHeading17661713816058"></a><a id="toc161"></a><a id="bkmtoc161"></a><a id="RefHeading5881136957987"></a><a id="bkmRefHeading5881136957987"></a><a id="bkmRefHeading5881136957987"></a><a id="bkmbkmRefHeading5881136957987"></a>Вступление</h3>
    <p class="Textbody">Текстовый редактор Geany (буду называть его так, хотя он и представляется как лёгкая IDE) разрабатывается Энрико Трёгером (Enrico Tröger) и Ником Трелевеном (Nick Treleaven), базируется на библиотеке Gtk 2, распространяется под лицензией GNU GPL v2 (по крайней мере до сих пор). Он присутствует присутствует в официальном репозитории Mint и устанавливается командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install geany</span> </p>
    <p class="Textbody">Geany способен выполнять практически все функции обычного текстового редактора, как то: инверсию регистров, дублирование текущей строки или выделения, подсветку синтаксиса многих языков программирования и разметки, развитые средства поиска и замены (в том числе с использованием регулярных выражений и escape-последовательностей, учетом регистра и так далее), включать или выключать динамический перенос строк; короче, практически всё, что требуется при наборе и редактировании текста. И не обязательно текста исходного — нарративного тоже, о чем будет рассказано в конце этой заметки.</p>
    <p class="Textbody">Поддержка проектов выводит эту программу в категорию редакторов развитых, делая его способным к обработке серии взаимосвязанных файлов. А встроенный эмулятор терминала полезен не только программистам, но незаменим также для линуксописателей. Автодополнение языковых конструкций (имеются ввиду языки программирования и разметки) — также функция, подчас не лишняя для простых юзеров, имеющих дело, например, с созданием HTML-документов.</p>
    <p class="Textbody">Настоящая заметка посвящена общему описанию редактора Geany и методам его использования при работе с обычными текстами и HTML-документами. Не будучи программистами, авторы не затрагивают вопросы применения этой программы в качестве собственно IDE.</p>
    <p class="Textbody">Запускается Geany из главного меню панели задач или рабочего стола (Разработка -&gt; Geany), после чего в открытом окне программы можно видеть следующие интерфейсные элементы (рис. 1):</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">заголовок с именем текущего открытого файла и указанием полного пути к нему; </p>
      </li>
      <li>
        <p class="Textbody">строку главного меню; </p>
      </li>
      <li>
        <p class="Textbody">панель инструментов; </p>
      </li>
      <li>
        <p class="Textbody">боковую панель; </p>
      </li>
      <li>
        <p class="Textbody">окно ввода и редактирования текста с вкладками открытых документов по верхнему краю; </p>
      </li>
      <li>
        <p class="Textbody">окно сообщений; </p>
      </li>
      <li>
        <p class="Textbody">статусную строку. </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_057.png">
        <img alt="Изображение390" class="frameGraphics" id="390graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_057-572x440.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:441.85574px" />
      </a>
      <a id="a390graphic"></a>
      <a id="bkm390graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_057.png"> </a>
    </p>
    <p class="Textbody">Вид главного меню предопределён используемой в Geany библиотекой Gtk+, остальные же элементы, в терминологии программы именуемые виджетами, настраиваются внутренними её средствами.</p>
    <p class="Textbody">Основные элементы интерфейса редактора — окно ввода, боковая панель и окно сообщений — масштабируемы, как, разумеется, и главное окно; выполненные в сеансе изменения размеров можно сохранить навсегда, о чем будет сказано в разделе про настройку программы.</p>
    <p class="Textbody">Главное меню программы включает следующие пункты:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Файл; </p>
      </li>
      <li>
        <p class="Textbody">Правка; </p>
      </li>
      <li>
        <p class="Textbody">Поиск; </p>
      </li>
      <li>
        <p class="Textbody">Вид; </p>
      </li>
      <li>
        <p class="Textbody">Документ; </p>
      </li>
      <li>
        <p class="Textbody">Проект; </p>
      </li>
      <li>
        <p class="Textbody">Сборка; </p>
      </li>
      <li>
        <p class="Textbody">Инструменты; </p>
      </li>
      <li>
        <p class="Textbody">Справка. </p>
      </li>
    </ul>
    <p class="Textbody">Рассмотрим эти пункты последовательно.</p>
    <h3 id="toc163"><a id="RefHeading17681713816058"></a><a id="bkmRefHeading17681713816058"></a><a id="toc162"></a><a id="bkmtoc162"></a><a id="RefHeading5901136957987"></a><a id="bkmRefHeading5901136957987"></a><a id="bkmRefHeading5901136957987"></a><a id="bkmbkmRefHeading5901136957987"></a>Файл</h3>
    <p class="Textbody">Пункты меню Файл сгруппированы в несколько блоков:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_058.png">
        <img alt="Изображение391" class="frameGraphics" id="391graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_058.png" style="border:1.0px solid #000080;padding:0;width:370.83844px;height:572.8542px" />
      </a>
      <a id="a391graphic"></a>
      <a id="bkm391graphic"></a>
    </p>
    <p class="Textbody">Первый из них посвящен созданию новых файлов. Пункт Создать предполагает открытие в окне редактирования пустого документа. Пункт Создать из шаблона предоставляет на выбор с десяток вариантов, позволяющих создать исходный файл с предопределённым шаблоном для нескольких языков программирования (Си, Си++, PHP, Python, Ruby и так далее) и разметки (html, tex).</p>
    <p class="Textbody">В начале каждого шаблона содержится комментарий (обозначенный в соответствие с синтаксисом выбранного языка), включающий имя файла, указание на копирайт создателя (откуда оно берётся — мы увидим позднее) и традиционный для программ Open Source отказ от гарантий:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_059.png">
        <img alt="Изображение392" class="frameGraphics" id="392graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_059-572x455.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:456.82266px" />
      </a>
      <a id="a392graphic"></a>
      <a id="bkm392graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_059.png"> </a>
    </p>
    <p class="Textbody">Далее следует «скелет», типичный для данного языка. Например, для HTML-файла он выглядит следующим образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_060.png">
        <img alt="Изображение393" class="frameGraphics" id="393graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_060-572x440.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:441.85574px" />
      </a>
      <a id="a393graphic"></a>
      <a id="bkm393graphic"></a>
    </p>
    <p class="Textbody">Сначала идет определение типа документа (!DOCTYPE) и тег html с соответствующими атрибутами. Затем — заголовочный блок с титулом HTML-страницы, указанием набора символов (соответствующим по умолчанию текущей локали) и программы-генератора (то есть самой Geany), открывающий и закрывающий теги body и закрывающий тег html. Рассмотрение шаблона показывает, что он соответствует спецификации XHTML, поэтому при создании чистого HTML-документа (pure html) лучше начинать это дело с «чистого листа».</p>
    <p class="Textbody">Следующий блок пунктов меню Файл касается открытия существующих документов, том числе выбранного файла и одного из списка недавно открывавшихся документов (по умолчанию в списке десять позиций).</p>
    <p class="Textbody">Блок сохранения файлов включает пункты: Сохранить (текущий файл), Сохранить как, то есть под другим именем (если файл был создан из шаблона — это единственно доступный вариант, причём соответствующий суффикс, например .html, выводится автоматически), Сохранить все (открытые документы), Загрузить заново, то есть считать документ заново, например, если он был изменён внешней программой (с потерей несохранённых результатов текущего редактирования) и Загрузить заново как, что предоставляет возможность сменить текущий набор символов (по-простому говоря, изменить кодировку документа).</p>
    <p class="Textbody">Пункт Свойства вызывает панель с указанием типа файла, его размера и полного пути к нему, кодировки, атрибутов времени (модификации, изменения статуса, последнего доступа), принадлежности и прав доступа:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_061.png">
        <img alt="Изображение394" class="frameGraphics" id="394graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_061.png" style="border:1.0px solid #000080;padding:0;width:404.85416px;height:502.85733px" />
      </a>
      <a id="a394graphic"></a>
      <a id="bkm394graphic"></a>
    </p>
    <p class="Textbody">Далее следуют пункты, относящиеся к печати, закрытию (текущего документа или всех открытых) и, наконец, выход из программы.</p>
    <h3 id="toc164"><a id="RefHeading17701713816058"></a><a id="bkmRefHeading17701713816058"></a><a id="toc163"></a><a id="bkmtoc163"></a><a id="RefHeading5921136957987"></a><a id="bkmRefHeading5921136957987"></a><a id="bkmRefHeading5921136957987"></a><a id="bkmbkmRefHeading5921136957987"></a>Правка</h3>
    <p class="Textbody">В меню Правка также имеет блочную структуру:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_062.png">
        <img alt="Изображение395" class="frameGraphics" id="395graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_062.png" style="border:1.0px solid #000080;padding:0;width:380.8542px;height:503.84003px" />
      </a>
      <a id="a395graphic"></a>
      <a id="bkm395graphic"></a>
    </p>
    <p class="Textbody">Сначала следует блок пунктов для обычных действий над текстом — Отменить и Вернуть (последние изменения, откат и возврат многоступенчатые), Вырезать, Копировать, Вставить и Удалить, а также Выделить всё.</p>
    <p class="Textbody">Все эти операции дублируются стандартными для современных GUI комбинациями клавиш, типа Control+X, Control+C и Control+V для вырезания, копирования и вставки выделенного фрагмента соответственно. Причём ныне комбинации эти работают и при русской раскладке клавиатуры.</p>
    <p class="Textbody">Пункт Форматирование позволяет:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">переключить регистр выделенного текста; </p>
      </li>
      <li>
        <p class="Textbody">закомментировать строку или снять с неё комментарий; </p>
      </li>
      <li>
        <p class="Textbody">продублировать строку или выделенный фрагмент текста; </p>
      </li>
      <li>
        <p class="Textbody">увеличить или уменьшить отступ текущей строки или выделенной группы строк; </p>
      </li>
      <li>
        <p class="Textbody">отправить выделенный текст на обработку какой-либо команде, после чего вывод этой команды заменит исходное выделение; правда, команды обработки предварительно нужно определить — это делается в этом же подпункте; данная возможность неоценима для линуксописателя (и не только для «линуксо-»). </p>
      </li>
    </ul>
    <p class="Textbody">Пункт Вставить комментарии подразумевает нечто совсем иное, нежели близкий по звучанию подпункт из Форматирования. Он предлагает на выбор включить в документ такие фиксированные фрагменты, как отказ от гарантий (о котором говорилось ранее), BSD- и GPL-уведомления. Хотя и просто закомментировать несколько пустых строк можно тоже.</p>
    <p class="Textbody">Далее идут пункты Вставить дату (с возможностью выбора формата оной) и Вставить include (по умолчанию не активизировано).</p>
    <p class="Textbody">И, наконец, пункт Параметры: в нём можно выполнить настройки программы, к которым мы вернёмся после того, как рассмотрим возможности, предоставляемые Geany без всяких настроек.</p>
    <h3 id="toc165"><a id="RefHeading17721713816058"></a><a id="bkmRefHeading17721713816058"></a><a id="toc164"></a><a id="bkmtoc164"></a><a id="RefHeading5941136957987"></a><a id="bkmRefHeading5941136957987"></a><a id="bkmRefHeading5941136957987"></a><a id="bkmbkmRefHeading5941136957987"></a>Поиск</h3>
    <p class="Textbody">Развитые функции поиска и замены — одно из важнейших отличий «настоящих» текстовых редакторов от «буквонабивалок» класса Notepad'а. И Geany здесь стыдиться нечего:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_063.png">
        <img alt="Изображение396" class="frameGraphics" id="396graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_063.png" style="border:1.0px solid #000080;padding:0;width:423.82742px;height:372.8416px" />
      </a>
      <a id="a396graphic"></a>
      <a id="bkm396graphic"></a>
    </p>
    <p class="Textbody">При запуске поиска на экране появляется панель со строкой, где вводится искомая последовательность символов, и серией чекбоксов, определяющих его условия. Поисковая панель не блокирует доступ к окну редактирования; в частности, в обрабатываемом тексте можно выделить фрагмент и щелчком средней кнопки мыши и операцией копирования поместить его в поисковую строку. Предусматривается поиск в двух режимах — обычном и расширенном.</p>
    <p class="Textbody">Обычный режим поиска предполагает поиск последовательности символов, поиск последующего или предыдущего, осуществляемые в пределах текущего документа. Возможно использование регулярных выражений, учёт регистра и так далее:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_064.png">
        <img alt="Изображение397" class="frameGraphics" id="397graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_064-572x208.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:209.83057px" />
      </a>
      <a id="a397graphic"></a>
      <a id="bkm397graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_064.png"> </a>
    </p>
    <p class="Textbody">Перейдя с помощью чекера Найти всё в расширенный режим поиска, оный можно осуществить в текущем документе, во всех открытых файлах, а также установить метки на строки, содержащие искомую последовательность символов.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_065.png">
        <img alt="Изображение398" class="frameGraphics" id="398graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_065-572x208.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:209.83057px" />
      </a>
      <a id="a398graphic"></a>
      <a id="bkm398graphic"></a>
    </p>
    <p class="Textbody">Пункт Найти в файлах позволяет указать каталог, во всех файлах которого следует выполнить поиск введённой последовательности символов, в том числе, при желании, и в подкаталогах любой степени вложенности. При поиске возможно использование обычных и расширенных регулярных выражений для grep, который, судя по всему, и выполняет собственно поиск в этом случае.</p>
    <p class="Textbody">Поиск предполагает возможность замены найденного — и таковая в Geany имеется. И также осуществляется в двух режимах. В обычном режиме замена происходит последовательно, по мере нахождения очередной подлежащей замене последовательности символов. Нажав всё ту же кнопку Заменить все, можно перейти в расширенный режим, дающий возможность замены в выделенном фрагменте текста, в документе целиком, а также в сессии, то есть во всех документах, открытых в данный момент</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_066.png">
        <img alt="Изображение399" class="frameGraphics" id="399graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_066-572x237.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:238.8573px" />
      </a>
      <a id="a399graphic"></a>
      <a id="bkm399graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_066.png"> </a>
    </p>
    <p class="Textbody">Возможностью, предоставляемой функцией Найти выделенное нас не удивить — собственно, и при обычном поиске в строке для оного по умолчанию будет помещён выделенный фрагмент, если таковой имелся. А вот с функцией Найти предыдущее выделенное мы ещё не сталкивались — что не делает её менее полезной в ряде ситуаций. Ну и Переход на строку (по заданному её номеру) видится вполне уместным среди функций поиска и замены.</p>
    <h3 id="toc166"><a id="RefHeading17741713816058"></a><a id="bkmRefHeading17741713816058"></a><a id="toc165"></a><a id="bkmtoc165"></a><a id="RefHeading5961136957987"></a><a id="bkmRefHeading5961136957987"></a><a id="bkmRefHeading5961136957987"></a><a id="bkmbkmRefHeading5961136957987"></a>Вид</h3>
    <p class="Textbody">В меню Вид, как нетрудно догадаться, устанавливается визуальное представление как интерфейсных элементов редактора, так и редактируемого документа:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_067.png">
        <img alt="Изображение400" class="frameGraphics" id="400graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_067.png" style="border:1.0px solid #000080;padding:0;width:383.84px;height:327.82742px" />
      </a>
      <a id="a400graphic"></a>
      <a id="bkm400graphic"></a>
    </p>
    <p class="Textbody">Так, первый его пункт, Выбрать шрифт, изменяет таковой в окне редактирования — но только на время текущего сеанса (глобальная замена шрифта выполняется через пункт Правка -&gt; Параметры, до которого мы со временем доберёмся).</p>
    <p class="Textbody">Пункт Показать/скрыть все панели убирает с экрана панель инструментов, вкладки для открытых документов, окно сообщений и статусную строку — словом, всё, кроме боковой панели (которая, как мы сейчас увидим, тоже может быть отключена) и окна редактирования, максимально расширяя пространство для последнего. Хотя нет, максимальным поле для приложения своих писательских склонностей становится, если включить ещё и полноэкранный режим, что делается через следующий, одноименный пункт меню Вид (или достигается нажатием клавиши F11).</p>
    <p class="Textbody">Далее следует блок пунктов, включающих или отключающих основные интерфейсные элементы главного окна редактора, такие как окно сообщений, панель инструментов, боковая панель, маркер строк (то есть подсветка строки, на которой расположен курсор), номера строк. В комментариях это, видимо, не нуждается.</p>
    <p class="Textbody">Пункты Увеличить, Уменьшить и В обычном размере выполняют масштабирование содержимого окна редактирования, подобно тому, как это делается в браузерах со времен Netscape какой-то бородатой версии. Кстати, и выполняется масштабирование также теми самыми, вот уже много лет привычными клавишами — Control+»серый плюс», Control+»сервый минус» и Control+0, а не только через меню.</p>
    <h3 id="toc167"><a id="RefHeading17761713816058"></a><a id="bkmRefHeading17761713816058"></a><a id="toc166"></a><a id="bkmtoc166"></a><a id="RefHeading5981136957987"></a><a id="bkmRefHeading5981136957987"></a><a id="bkmRefHeading5981136957987"></a><a id="bkmbkmRefHeading5981136957987"></a>Документ</h3>
    <p class="Textbody">Пункты меню Документ включают или выключают динамический перенос строк и использование автоотступов (только в текущем сеансе, для увековечивания установленной ситуации нужно обратиться всё к тем же Параметрам), определяют представление отступа — символами табуляции или наборами пробелов, устанавливают для текущего документа режим «только для чтения» (лишь в пределах Geany, изменять его внешними программами никто не запрещает):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_068.png">
        <img alt="Изображение401" class="frameGraphics" id="401graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_068.png" style="border:1.0px solid #000080;padding:0;width:362.82584px;height:527.84px" />
      </a>
      <a id="a401graphic"></a>
      <a id="bkm401graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_068.png"> </a>
    </p>
    <p class="Textbody">Далее следуют пункты:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">использовать кодировку Unicode с меткой порядка байтов (BOM), что, насколько нам известно, необходимо только для различения вариантов UTF-16 и UTF-32; </p>
      </li>
      <li>
        <p class="Textbody">установить тип файла для: </p>
        <ul style="margin-top:0;margin-bottom:0;list-style-type:bullet;clear:left">
          <li>
            <p class="Textbody">языка программирования (ассемблер, Си, Си++, Java и так далее), </p>
          </li>
          <li>
            <p class="Textbody">языка скриптинга (shell, Perl, Python, PHP, Ruby, JavaScript и др.), </p>
          </li>
          <li>
            <p class="Textbody">языка разметки (CSS, DockBook, HTML, XML), и </p>
          </li>
          <li>
            <p class="Textbody">прочих языков (конфиги, diff-файлы, LaTeX и так далее), </p>
          </li>
        </ul>
        <p class="Textbody">в соответствие с чем осуществляются подсветка синтаксиса и автодополнение языковых конструкций; например, в файле, тип которого определен как HTML, закрывающие теги будут ставиться автоматически после набора тега открывающего;</p>
      </li>
      <li>
        <p class="Textbody">установить кодировку — они сгруппированы по регионам (западноевропейские, восточноевропейские, восточноазиатские и прочие), внутри которых уже выбираются собственно наборы символов; кириллические кодировки, если используется не UTF-8, следует искать среди восточноевропейских; </p>
      </li>
      <li>
        <p class="Textbody">установить символ конца строки в стиле Unix, DOS или Mac; </p>
      </li>
      <li>
        <p class="Textbody">убирать остаточные пробелы и заменять символы табуляции соответствующим количеством пробелов; </p>
      </li>
      <li>
        <p class="Textbody">удалить маркеры на строках, которые были помечены при поиске; </p>
      </li>
    </ul>
    <p class="Textbody">ещё раз напомним, что все установки в меню Документ действуют только для текущего файла.</p>
    <h3 id="toc168"><a id="RefHeading17781713816058"></a><a id="bkmRefHeading17781713816058"></a><a id="toc167"></a><a id="bkmtoc167"></a><a id="RefHeading6001136957987"></a><a id="bkmRefHeading6001136957987"></a><a id="bkmRefHeading6001136957987"></a><a id="bkmbkmRefHeading6001136957987"></a>Проект</h3>
    <p class="Textbody">Средства управления проектами в Geany, как штатные, так и альтернативные,, реализованные в качестве плагинов, будут предметом отдельного мини-очерка.</p>
    <h3 id="toc169"><a id="RefHeading17801713816058"></a><a id="bkmRefHeading17801713816058"></a><a id="toc168"></a><a id="bkmtoc168"></a><a id="RefHeading6021136957987"></a><a id="bkmRefHeading6021136957987"></a><a id="bkmRefHeading6021136957987"></a><a id="bkmbkmRefHeading6021136957987"></a>Сборка</h3>
    <p class="Textbody">Это меню предназначено в основном для сочинителей исходных текстов. Однако один из его пунктов, а именно, Выполнить, может представлять интерес и для тех, кто сочиняет тексты просто. В частности, файл HTML при выборе этого пункта будет просто-напросто открыт в браузере. Каком — поговорим чуть позже.</p>
    <h3 id="toc170"><a id="RefHeading17821713816058"></a><a id="bkmRefHeading17821713816058"></a><a id="toc169"></a><a id="bkmtoc169"></a><a id="RefHeading6041136957987"></a><a id="bkmRefHeading6041136957987"></a><a id="bkmRefHeading6041136957987"></a><a id="bkmbkmRefHeading6041136957987"></a>Инструменты</h3>
    <p class="Textbody">В меню Инструменты можно видеть такие пункты:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_069.png">
        <img alt="Изображение402" class="frameGraphics" id="402graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_069.png" style="border:1.0px solid #000080;padding:0;width:218.82584px;height:203.85889px" />
      </a>
      <a id="a402graphic"></a>
      <a id="bkm402graphic"></a>
    </p>
    <p class="Textbody">Из них интересен, во первых, пункт Выбор цвета — он выводит панель, в которой можно выбрать цвет из палитры, задать его значение численно или определить, с помощью «пипетки», по образцу, ткнув в любую область экрана (не обязательно в пределах окна Geany)</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_070.png">
        <img alt="Изображение403" class="frameGraphics" id="403graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_070-572x286.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:287.84px" />
      </a>
      <a id="a403graphic"></a>
      <a id="bkm403graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_070.png"> </a>
    </p>
    <p class="Textbody">Далее, Подсчёт слов — абсолютно необходимый инстструмент всякого профессионального сочинителя (то есть зарабатывающего сочинительством на хлеб). Ибо он выводи не только количество слов, но также строк и, главное, символов (с пробелами), для всего документа или выбранной его части:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_071.png">
        <img alt="Изображение404" class="frameGraphics" id="404graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_071.png" style="border:1.0px solid #000080;padding:0;width:264.8227px;height:171.84631px" />
      </a>
      <a id="a404graphic"></a>
      <a id="bkm404graphic"></a>
    </p>
    <p class="Textbody">И, наконец, Менеджер модулей — в этом пункте можно включить использование различных плагинов плагинов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_072.png">
        <img alt="Изображение405" class="frameGraphics" id="405graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_072.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:451.83374px" />
      </a>
      <a id="a405graphic"></a>
      <a id="bkm405graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_072.png"> </a>
    </p>
    <p class="Textbody">Подробнее этот вопрос будет рассмотрен в соответствующем миниочерке. А разбираться с прочими пунктами меню Инструменты япредоставляю заинтересованным лицам.</p>
    <h3 id="toc171"><a id="RefHeading17841713816058"></a><a id="bkmRefHeading17841713816058"></a><a id="toc170"></a><a id="bkmtoc170"></a><a id="RefHeading6061136957987"></a><a id="bkmRefHeading6061136957987"></a><a id="bkmRefHeading6061136957987"></a><a id="bkmbkmRefHeading6061136957987"></a>Справка</h3>
    <p class="Textbody">Во многих свободных программах это вполне формальный пункт главного меню, сводящийся к указанию официального сайта проекта, списка его участников, лицензии и тому подобных элементов матрицы Остапа Бендера «Азиатский орнамент». Однако Geany принадлежит к тем немногим программам Open Source, которые являют собой приятное исключение.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_073.png">
        <img alt="Изображение406" class="frameGraphics" id="406graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_073.png" style="border:1.0px solid #000080;padding:0;width:277.82425px;height:265.84314px" />
      </a>
      <a id="a406graphic"></a>
      <a id="bkm406graphic"></a>
    </p>
    <p class="Textbody">Первый пункт меню, собственно Справка, вызывает очень подробную (хотя и англоязычную) документацию по программе в формате HTML. Причём вызывает не из Сети, а с локальной машины, куда она была помещёна при инсталляции. Останавливаться на её содержании я не буду, но к прочтению всячески рекомендую.</p>
    <p class="Textbody">Следующий пункт — Сочетания клавиш. Это не просто справка по существующим клавишным комбинациям, а руководство к действию, о чём недвусмысленно говорит надпись сразу под заголовком панели:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_074.png">
        <img alt="Изображение407" class="frameGraphics" id="407graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_074-572x331.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:332.8542px" />
      </a>
      <a id="a407graphic"></a>
      <a id="bkm407graphic"></a>
    </p>
    <p class="Textbody">И если последовать совету разработчиков и нажать кнопку Изменить, то оказываешься как раз в том месте настроек Geany, в котором горячие клавиши и можно переопределить. И где мы скоро окажемся.</p>
    <p class="Textbody">Далее можно увидеть ссылку на официальный сайт проекта — также весьма информативный. Во всяком случае, в разделы <a href="http://alv.me/»http://www.geany.org/Documentation/Manual»" target="_blank»">Manual</a> и <a href="http://www.geany.org/Documentation/FAQ" target="_blank">FAQ</a> заглянуть явно стоит. Как и в следующий пункт, Wiki, который приведёт нас <a href="http://wiki.geany.org/" target="_blank">вот сюда</a>.</p>
    <p class="Textbody">И, наконец, в пункте О программе приведены сведения о её разработчиках и переводчиках интерфейса.</p>
    <h3 id="toc172"><a id="RefHeading17861713816058"></a><a id="bkmRefHeading17861713816058"></a><a id="toc171"></a><a id="bkmtoc171"></a><a id="RefHeading6081136957987"></a><a id="bkmRefHeading6081136957987"></a><a id="bkmRefHeading6081136957987"></a><a id="bkmbkmRefHeading6081136957987"></a>Инструментальная панель</h3>
    <p class="Textbody">Инструментальная панель включена в редакторе Geany по умолчанию, хотя, как мы видели, расширения рабочего пространства ради, её можно и убрать — временно, через меню Вид, или постоянно, через пункты Правка -&gt; Параметры. Действия через пиктограммы в основном дублируют основные операции, доступные через главное меню, хотя некоторые из них и своеобразны.</p>
    <p class="Textbody">Первые две пиктограммы в ряду инструментов — создание нового файла и открытие существующего. Далее следуют две пиктограммы — сохранения текущего файла и сохранения всех открытых в сеансе документов, а также иконка перечитывания текущего файла с диска, а затем косой серый крестик закрытия текущего документа; если последний содержал не сохранённые изменения, последует запрос на подтверждение действия с вариантами — Отменить, Не сохранять и Сохранить:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_075.png">
        <img alt="Изображение408" class="frameGraphics" id="408graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_075.png" style="border:1.0px solid #000080;padding:0;width:480.8227px;height:148.82896px" />
      </a>
      <a id="a408graphic"></a>
      <a id="bkm408graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_075.png"> </a>
    </p>
    <p class="Textbody">Стрелки Назад и Вперед подобны таковым в браузерах, только перемещают они в пределах текущего документа — на предыдущую и последующую позиции курсора.</p>
    <p class="Textbody">Три следующие пиктограммы вызывают компиляцию текущего файла, его сборку (на разнице между этими понятиями останавливаться не буду) и просмотр или запуск (в зависимости от типа).</p>
    <p class="Textbody">Следующая в этом ряду пиктограмма — выбор цвета, который происходит точно так же, как было описано в разделе про меню Инструменты.</p>
    <p class="Textbody">Далее следует два поля ввода. В первом можно поместить текст для поиска, во втором — номер строки, на которую требуется перейти. Нажатие на сопровождающие их кнопки вызывает соответствующие действия.</p>
    <p class="Textbody">И последняя на панели инструментов пиктограмма — выход из редактора с запросом на сохранение не записанных перед тем изменений.</p>
    <p class="Textbody">Мы привели набор пиктограмм, имеющихся в инструментальной панели по умолчанию. В одном из следующих разделов мы увидим, что он может быть как пополнен (хотя и не в очень широких рамках), так и урезан произвольным образом.</p>
    <h3 id="toc173"><a id="RefHeading17881713816058"></a><a id="bkmRefHeading17881713816058"></a><a id="toc172"></a><a id="bkmtoc172"></a><a id="RefHeading6101136957987"></a><a id="bkmRefHeading6101136957987"></a><a id="bkmRefHeading6101136957987"></a><a id="bkmbkmRefHeading6101136957987"></a>Поле редактирования, боковая панель и окно сообщений</h3>
    <p class="Textbody">Покончив с обзором элементов управления редактором — главного меню и инструментальной панели, перейдём к основным рабочим областям его интерфейса.</p>
    <p class="Textbody">Главная рабочая область текстового редактора — это, разумеется, поле ввода и редактирования текста. Но как раз про него-то можно сказать меньше всего — разве только то, что в нём действительно можно вводить и редактировать текст :), и что оно имеет полосу прокрутки оного.</p>
    <p class="Textbody">Хотя нет, самое главное: вдоль верхней границы рабочего поля идут вкладки для переключения между открытыми документами, имеющие также кнопку закрытия — такой же косой серый крестик, что и на инструментальной панели. Вкладки вновь открываемых документов по умолчанию возникают справа от существующих. Впрочем, вкладки эти можно перетасовать как угодно простым перетаскиванием мышью.</p>
    <p class="Textbody">Боковая панель служит целям навигации по текущему документу, перемещёнию между документами открытыми и просмотру дерева файлов, как открытых, так и не открытых. И, соответственно этому, имеет три вкладки.</p>
    <p class="Textbody">Первая из них — Символы. Для HTML-документов тут фигурируют разметочные теги, в частности, заголовков соответствующих уровней (H1, H2 и так далее) и заключённый в них текст с указанием номера строки. То есть мы можем видеть своего рода гипертекстовое оглавление: щелчок мышью на одном из заголовков во вкладке тегов приводит к перемещёнию на него в тексте рабочего поля:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_076.png">
        <img alt="Изображение409" class="frameGraphics" id="409graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_076-572x440.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:441.85574px" />
      </a>
      <a id="a409graphic"></a>
      <a id="bkm409graphic"></a>
    </p>
    <p class="Textbody">По умолчанию заголовки отсортированы по имени, то есть в алфавитном порядке. Через контекстное меню, вызываемое щелчком правой кнопки мыши в боковой панели, их можно пересортировать в порядке появления в тексте, как в обычном оглавлении:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_077.png">
        <img alt="Изображение410" class="frameGraphics" id="410graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_077-572x440.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:441.85574px" />
      </a>
      <a id="a410graphic"></a>
      <a id="bkm410graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_077.png"> </a>
    </p>
    <p class="Textbody">Вкладка Документы боковой панели — это просто список открытых в данный момент файлов, между которыми можно переключаться точно так же, как и по вкладкам поля редактирования. Через контекстное меню, вызываемое щелчком правой кнопки мыши, файл под курсором можно сохранить, обновить или закрыть. Действие пункта Показать полный путь будет распространено на все файлы вкладки.</p>
    <p class="Textbody">Наконец, вкладка Файлы появится только после того, как через менеджер плагинов будет включён плагин Просмотр файлов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_078.png">
        <img alt="Изображение411" class="frameGraphics" id="411graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_078.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:451.83374px" />
      </a>
      <a id="a411graphic"></a>
      <a id="bkm411graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_078.png"> </a>
    </p>
    <p class="Textbody">В этой вкладке выводится содержимое текущего каталога (рис. 15), и в ней можно перемещаться, как в обычном файловом менеджере. Собственно, этот плагин и представляет собой упрощённый файловый менеджер с ограниченной функциональностью: щелчком правой кнопки мыши вызывается контекстное меню, через которое можно открыть файл в окне редактирования, открыть его во внешней программе, вызвать поиск, аналогично пункту Найти в файлах из меню Поиск. Обладает эта вкладка и собственной маленькой инструментальной панелькой с четырьмя пиктограммами, с помощью которых можно переместиться на уровень вверх, обновить содержимое вкладки, перейти в домашний каталог и в каталог, который содержит документ, являющийся текущим для поля редактирования:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_079.png">
        <img alt="Изображение412" class="frameGraphics" id="412graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_079-572x440.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:441.85574px" />
      </a>
      <a id="a412graphic"></a>
      <a id="bkm412graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_079.png"> </a>
    </p>
    <p class="Textbody">Теперь окно сообщений. Оно тоже включает в себя отдельные вкладки — целых пять штук:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Статус; </p>
      </li>
      <li>
        <p class="Textbody">Компилятор; </p>
      </li>
      <li>
        <p class="Textbody">Сообщения; </p>
      </li>
      <li>
        <p class="Textbody">Заметки; </p>
      </li>
      <li>
        <p class="Textbody">Терминал. </p>
      </li>
    </ul>
    <p class="Textbody">При вкладке Статус (она включается по умолчанию при запуске программы) в окне сообщений выводится своего рода журнал операций над текущими файлами, в котором фиксируются время открытия каждого файла, всех сохранений и закрытия. Аналогичные операции над проектами (поскольку они также представляют собой файлы, только остающиеся как бы за кадром) протоколируются тут также.</p>
    <p class="Textbody">При переходе к вкладке Компилятор в окне сообщений выводится информация о ходе сборки текущего файла (запущенной через меню Построить -&gt; Собрать. В нашем случае попытка «собрать» HTML-файл закончилась тем, чего и следовало ожидать — сообщением об ошибке.</p>
    <p class="Textbody">Вкладка Сообщения задействуется только при поиске сообщений — никаких других применений ей не находится.</p>
    <p class="Textbody">С переходом к вкладке Заметки окно сообщений превращается в своего рода текстовый мини-редактор, о чем нас и информирует появляющаяся при переключении надпись:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">Здесь можно писать все, что угодно, используйте это для заметок и быстрых записей</span> </p>
    <p class="Textbody">Действительно, теперь в окне сообщений можно вводить текст и редактировать его как угодно. Разве что сохранить в виде файла непосредственно не получится. Но текст можно скопировать в «мышиный» или Иксовый буфер и поместить уже в окно редактирования (или в любую другую программу, способную обрабатывать тексты).</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_080.png">
        <img alt="Изображение413" class="frameGraphics" id="413graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_080-572x440.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:441.85574px" />
      </a>
      <a id="a413graphic"></a>
      <a id="bkm413graphic"></a>
    </p>
    <p class="Textbody">Пятая вкладка — Терминал. С переключением на неё окно сообщений становится действительно полноценным терминальным окном с командной строкой пользовательского шелла, в которой можно вводить практически любые команды, в чем и состоит её ценность для линуксописателя: результаты выполнения команды можно тут же «скопипастить» в сочиняемую статью.</p>
    <p class="Textbody">Последний элемент интерфейса нашего редактора, также отключаемый — строка состояния вдоль нижнего края окна сообщений. В ней выводятся: номер строки и колонки для текущего положения курсора, режим работы редактора (вставки или замены), тип конца строки, кодировка документа и тип его файла.</p>
    <h3 id="toc174"><a id="RefHeading17901713816058"></a><a id="bkmRefHeading17901713816058"></a><a id="toc173"></a><a id="bkmtoc173"></a><a id="RefHeading6121136957987"></a><a id="bkmRefHeading6121136957987"></a><a id="bkmRefHeading6121136957987"></a><a id="bkmbkmRefHeading6121136957987"></a>Настройка</h3>
    <p class="Textbody">Мы рассмотрели интерфейс и возможности Geany по умолчанию. Теперь давайте поглядим, как их можно модифицировать под свои потребности и привычки.</p>
    <p class="Textbody">Как уже говорилось, практически все настройки Geany выполняются посредством меню Правка -&gt; Параметры, вызывающего панель с одиннадцатью вкладками:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">Общее; </p>
      </li>
      <li>
        <p class="Textbody">Интерфейс; </p>
      </li>
      <li>
        <p class="Textbody">Панель инструментов; </p>
      </li>
      <li>
        <p class="Textbody">Отображение; </p>
      </li>
      <li>
        <p class="Textbody">Редактор; </p>
      </li>
      <li>
        <p class="Textbody">Файлы; </p>
      </li>
      <li>
        <p class="Textbody">Инструменты; </p>
      </li>
      <li>
        <p class="Textbody">Шаблоны; </p>
      </li>
      <li>
        <p class="Textbody">Привязки; </p>
      </li>
      <li>
        <p class="Textbody">Печать; </p>
      </li>
      <li>
        <p class="Textbody">Терминал. </p>
      </li>
    </ol>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_081.png">
        <img alt="Изображение414" class="frameGraphics" id="414graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_081-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a414graphic"></a>
      <a id="bkm414graphic"></a>
    </p>
    <p class="Textbody">Рассмотрим последовательно, какие возможности они предоставляют.</p>
    <p class="Textbody">Во вкладке Общее — две секции, Запуск и Прочее, содержащих чекбоксы включения/отключения соответствующих функций. В первой из них отмечается, загружать ли при старте редактора файлы из последней сессии, включать ли виртуальный терминал (тот самый, на который можно будет переключиться в окне сообщений) и поддержку дополнительных плагинов, о которых говорилось выше.</p>
    <p class="Textbody">При завершении работы можно сохранить позицию и размеры главного окна программы и его составляющих — боковой панели и окна сообщений; здесь же указывается, запрашивать ли подтверждение при выходе из редактора.</p>
    <p class="Textbody">Далее можно указать пути к рабочему каталогу при запуске и к файлам проекта. Они не обязаны совпадать — в некоторых случаях удобно файлы всех проектов держать в отдельном от рабочих файлов месте.</p>
    <p class="Textbody">В секции Прочее, как и положено, настраивается всякая всячина, как то:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">включение звукового сигнала при ошибках; </p>
      </li>
      <li>
        <p class="Textbody">переход к дежурным сообщениям при получении оных и, напротив, подавление вывода дежурных сообщений; </p>
      </li>
      <li>
        <p class="Textbody">включенние автофокусировки окон по перемещёнию курсора мыши, без щелчка оной, — это удобно, если надо постоянно приходится переключаться между окном редактирования и окном сообщений; </p>
      </li>
      <li>
        <p class="Textbody">скрытие панели поиска по его завершении; </p>
      </li>
      <li>
        <p class="Textbody">помещёние слова под курсором в поисковую строку при обращении к функциям поиска и замены. </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_082.png">
        <img alt="Изображение415" class="frameGraphics" id="415graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_082-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a415graphic"></a>
      <a id="bkm415graphic"></a>
    </p>
    <p class="Textbody">Внешний вид редактора и его основных элементов определяется во вкладке Интерфейс:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_083.png">
        <img alt="Изображение416" class="frameGraphics" id="416graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_083-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a416graphic"></a>
      <a id="bkm416graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_083.png"> </a>
    </p>
    <p class="Textbody">Здесь для боковой панели можно включить или выключить отображение списка символов и списка документов; отображения списка файлов здесь нет — как уже говорилось, оно определяется включением соответствующего плагина. Так что, если отключить вывод и списка символов, и списка документов, исчезнет и список файлов. Ну а с включением показа полных путей к файлам открытых документов всё ясно без комментариев.</p>
    <p class="Textbody">Шрифты — как их гарнитура, так и размер, — можно установить независимо для окна редактирования, для боковой панели и для окна сообщений. Забегая вперед, заметим, что терминал в окне сообщений также настраивается независимо от остальных элементов редактора.</p>
    <p class="Textbody">Далее, экономии места ради, можно выключить вкладки для открытых файлов в окне редактирования. Если же их оставить, то можно отключить показ кнопки закрытия на вкладках, во избежание случайного нажатия на неё. Ну и позиция открытия новых вкладок при создании документа — слева или справа от текущей — также может быть переопределена.</p>
    <p class="Textbody">Положение вкладок задаётся для главных виджетов программы относительно их самих независимо, и они могут располагаться по любому краю панели или окна, хотя их позиция по умолчанию наиболее разумна — разве что можно было бы поспорить относительно «верха» и «низа» для окна редактирования и «права» и «лева» — для окна сообщений.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_084.png">
        <img alt="Изображение417" class="frameGraphics" id="417graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_084-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a417graphic"></a>
      <a id="bkm417graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_084.png"> </a>
    </p>
    <p class="Textbody">Как говорилось в разделе Панель инструментов, она может быть отключена, или набор кнопок на ней изменён. Это делается в одноименной вкладке отметками в соответствующих чекбоксах. Можно также изменить внешний вид кнопок (в виде только иконок, только текста или того и другого) и их размер (большой, как по умолчанию, или маленький).</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_085.png">
        <img alt="Изображение418" class="frameGraphics" id="418graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_085-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a418graphic"></a>
      <a id="bkm418graphic"></a>
    </p>
    <p class="Textbody">Набор пиктограмм на инструментальной панели настраивается в отдельном окошке, вызываемом нажатием соответствующей кнопки. Тут, я думаю, всё поонятно из скриншота:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_086.png">
        <img alt="Изображение419" class="frameGraphics" id="419graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_086-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a419graphic"></a>
      <a id="bkm419graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_086.png"> </a>
    </p>
    <p class="Textbody">Во вкладке Редактор устанавливаются правила поведения в окне редактирования, такие как:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">включение и выключение режима переноса слов; </p>
      </li>
      <li>
        <p class="Textbody">отключение режима Drag-and-Drop; </p>
      </li>
      <li>
        <p class="Textbody">удаление остаточных пробелов в конце строк, перед символом её окончания; </p>
      </li>
    </ul>
    <p class="Textbody">и так далее — детали можно видеть на серии скриншотов.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_087.png">
        <img alt="Изображение420" class="frameGraphics" id="420graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_087-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a420graphic"></a>
      <a id="bkm420graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_088.png">
        <img alt="Изображение421" class="frameGraphics" id="421graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_088-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a421graphic"></a>
      <a id="bkm421graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_088.png"> </a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_089.png">
        <img alt="Изображение422" class="frameGraphics" id="422graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_089-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a422graphic"></a>
      <a id="bkm422graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_090.png">
        <img alt="Изображение423" class="frameGraphics" id="423graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_090-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a423graphic"></a>
      <a id="bkm423graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_090.png"> </a>
    </p>
    <p class="Textbody">Комментарий требуентся тольк для последнего скриншота и его секции Маркер длинной строки. При включении режима динамического переноса строк служит для различения «истинных» строк (фиксируемых символами конца строки, в случае стиля Unix — LF) и строк «экранных», создаваемых за счет переноса слов по границе экрана, длина которых зависит от размера окна редактирования. Варианты выбора маркера — отмечать цветом текст строки, фон текста (цвет может быть изменен) или выключить вообще (последнее имеет смысл, если режим переноса слов не используется).</p>
    <p class="Textbody">Во вкладке Файлы сначала определяется кодировка по умолчанию для вновь создаваемых файлов и устанавливается кодировка, в которой должны открываться файлы уже существующие. По умолчанию значения обоих параметров берутся из системной локали, но в общем случае совпадать они не обязаны.</p>
    <p class="Textbody">Далее включаются (или, напротив, выключаются) действия, производимые при записи файлов: удаление остаточных пробелов, обязательный ввод новой строки в конце файла (необходимо для некоторых конфигов), замена символов табуляции эквивалентным числом пробелов. Длина списка недавно открывавшихся файлов (выводимого при действиях через меню Файл -&gt; Недавние файлы) также указывается в этой вкладке.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_091.png">
        <img alt="Изображение424" class="frameGraphics" id="424graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_091-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a424graphic"></a>
      <a id="bkm424graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_091.png"> </a>
    </p>
    <p class="Textbody">Вкладка Инструменты к панели инструментов не имеет никакого отношения: здесь определяются внешние программы, вызываемые для выполнения определённых действий. Пользователю нужно следить за тем, чтобы умолчальные значения всех полей, подходящие в большинстве случаев, всё же соответствовали реалиям его системы. То есть чтобы для действие Терминал осуществлялось в окне предпочитаемого эмулятора терминала, для поиска текстовых фрагментов применялась нужная утилита grep-семейства.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_092.png">
        <img alt="Изображение425" class="frameGraphics" id="425graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_092-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a425graphic"></a>
      <a id="bkm425graphic"></a>
    </p>
    <p class="Textbody">Во вкладке Шаблоны вводятся те самые личные сведения, которые потом окажутся в комментариях ко всем файлам, создаваемым посредством действий Файл -&gt; Создать из шабла -&gt; [тип файла]: имя и фамилия автора, адрес его электронной почты и тому подобное. В отличие от всех остальных изменений, вступающих в действие немедленно по нажатии кнопки Применить или OK в правом нижнем углу панели настроек, переопределение сведений о шаблоне обретёт силу только при следующем запуске Geany.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_093.png">
        <img alt="Изображение426" class="frameGraphics" id="426graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_093-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a426graphic"></a>
      <a id="bkm426graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_093.png"> </a>
    </p>
    <p class="Textbody">Во вкладке Сочетания клавиш, как легко догадаться, можно переопределить «горячие» клавиши для всех действий, предусмотренных в редакторе Geany, а также приписать их тем действиям, к которым никакие клавишные комбинации по умолчанию не определены. То есть сделать то, к чему нас призывали разработчики в меню Помощь -&gt; Горячие клавиши.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_094.png">
        <img alt="Изображение427" class="frameGraphics" id="427graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_094-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a427graphic"></a>
      <a id="bkm427graphic"></a>
    </p>
    <p class="Textbody">Для переопределения существующих клавишных комбинаций или создания новых достаточно выделить в списке нуждающееся в этом действие и нажать кнопку Изменить (или просто щелкнуть на нём дважды). После этого, по появлении панельки Захватить клавишу, надо набрать желаемую комбинацию клавиш, которые тут же высветятся на панельке, и затем нажать кнопку OK.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_095.png">
        <img alt="Изображение428" class="frameGraphics" id="428graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_095.png" style="border:1.0px solid #000080;padding:0;width:438.83212px;height:138.85101px" />
      </a>
      <a id="a428graphic"></a>
      <a id="bkm428graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_095.png"> </a>
    </p>
    <p class="Textbody">Клавиатурные комбинации можно редактировать и напрямую: для этого надо лишь, выделив строку подлежащего изменению действия, щелкнуть мышью непосредственно на обозначении горячих клавиш для него, после чего ввести желаемые значения вручную.</p>
    <p class="Textbody">Я не буду останавливаться на вопросе, какие сочетания горячих клавиш следует использовать для тех или иных действий: это вопрос сугубо личный, можно даже сказать — интимный.</p>
    <p class="Textbody">Мало что скажу также и о вкладке Печать, ибо следуем заповеди POSIX'ивистов, сформулированной Сергеем Голубевым:</p>
    <p class="Textbody">Не настроил принтер — сохранил дерево.</p>
    <p class="Textbody">Так что тем, кто деревьев не жалеет, в содержимом этой вкладки предоставляется разбираться самостоятельно.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_096.png">
        <img alt="Изображение429" class="frameGraphics" id="429graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_096-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a429graphic"></a>
      <a id="bkm429graphic"></a>
    </p>
    <p class="Textbody">А вот на содержании вкладки Терминал стоит остановиться подробнее.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_097.png">
        <img alt="Изображение430" class="frameGraphics" id="430graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_097-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a430graphic"></a>
      <a id="bkm430graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_097.png"> </a>
    </p>
    <p class="Textbody">Перво-наперво здесь можно определить шрифт для терминального окна, его цвет и цвет фона — это делается через панель выбора цвета, о которой мы говорили при рассмотрении главного меню. Весьма элегантно выглядит оформление в общих тонах всего редактора, что легко сделать с помощью упомянутой ранее «пипетки». Впрочем, можно задать и фоновое изображение. Ну а шрифт и его размер каждый определяет в соответствие со своими вкусами и диоптриями.</p>
    <p class="Textbody">Далее определяется число строк терминальной «истории» и запускаемая в терминальном окне командная оболочка (по умолчанию это будет login shell данного пользователя). Под терминальную «историю» на нынешних машинах можно отвести сколь угодно большое число строк.</p>
    <p class="Textbody">Опции Прокрутка по нажатию на клавиши и Прокрутка по мере вывода в комментариях не нуждаются. Переопределение горячих клавиш Geany может быть полезным, если они пересекаются с кейбиндингами используемой командной оболочки. Ну и отключение вызова меню через горячую клавишу F10 может пригодиться, если в терминальном окне предполагается запускать программу типа Midnight Commander.</p>
    <p class="Textbody">Включение опции Следовать пути текущего файла приведет к тому, что при каждом переключении между документами из разных каталогов, открытыми в поле редактирования, смена текущего каталога будет происходить и в командной строке. Полезно это, вредно ли, или безразлично, — зависит от конкретной ситуации.</p>
    <p class="Textbody">Опция Выполнять программы в терминале предписывает направление исполнения отлаживаемых программ и скриптов в наш встроенный виртуальный терминал, вместо того, чтобы вызывать отдельное терминальное окно (той самой программы, которая ранее была указана в поле Терминал вкладки Инструменты). Такая возможность удобна, но именно при отладке обнаруживается её недостаток: остановить неправильно работающую программу во встроенном терминале не всегда возможно.</p>
    <p class="Textbody">На этом настройку терминала можно считать законченной. Заметим только, что точно так же её можно осуществить непосредственно из вкладки Терминал окна сообщений — через контекстное меню по щелчку правой кнопкой мыши.</p>
    <p class="Textbody">Собственно, и настройки Geany вообще тоже закончены. Как и вообще разговор о его базовой функциональности — на содержании вкладки Разноеостанавливаться не буду, так как никаких параметров там не менял, вняв соответствующему предупреждению:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_097a.png">
        <img alt="Изображение431" class="frameGraphics" id="431graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_097a-572x351.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:352.8479px" />
      </a>
      <a id="a431graphic"></a>
      <a id="bkm431graphic"></a>
    </p>
    <p class="Textbody">Настало время подвести предварительные итоги. Главный из которых таков: есть мнение, что использование этой программы целесообразно для любых текстовых работ, превышающих сложностью редактирование двух-трёх строчек в пятистрочном сценарии. Автор настоящего очерка, в частности, на протяжении ряда лет применял Geany для создания документов в форматах plain text и HTML. Удобство его для сочинительских целей определяется возможностями выполнения команд в терминальном окне параллельно с их описанием в поле редактирования, мгновенной проверки работоспособности командных конструкций, автоматизацией ввода наиболее часто используемых HTML-тегов, сочетанием средств навигации внутри находящегося в работе текста с функциями обзора файловой системы и многим, многим другим. А дополнительный функционал редактору придают многочисленные плагины, к рассмотрению которых мы и переходим.</p>
    <h3 id="toc175"><a id="RefHeading17921713816058"></a><a id="bkmRefHeading17921713816058"></a><a id="toc174"></a><a id="bkmtoc174"></a><a id="RefHeading6141136957987"></a><a id="bkmRefHeading6141136957987"></a><a id="bkmRefHeading6141136957987"></a><a id="bkmbkmRefHeading6141136957987"></a>Geany и его плагины</h3>
    <p class="Textbody">Надеюсь, на прошлых страницах мне удалось продемонстрировать, что Geany и своём первозданном виде предоставляет в распоряжение применителя массу возможностей для работы с текстом. Однако функционал его многократно усугубляется бесчисленными дополнения — так называемыми плагинами (plugins). Чтобы получить представление о их количестве, достаточно в CLI задать поиск по шаблону geany-plugin:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt search geany-plugin | wc -l</span> </p>
    <p class="Textbody">вывод которой в Mint 17.1 Rebecca на момент сочинения этих строк будет таким:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">     66</span> </p>
    <p class="Textbody">То есть на 20.01.2015 для Geany сочинено 66 примерно плагинов. Почему примерно — сейчас расскажу.</p>
    <p class="Textbody">Дело в том, что три пакета из выведенного списка играют особую роль. Это — geany-plugins-common, geany-plugin-addons и geany-plugins. Первый из них, как можно догадаться по его имени, содержит компоненты, общие для всех плагинов, то есть локально-зависимые. Как-правило, он устанавливается в качестве зависимости любого другого «плагинного» пакета.</p>
    <p class="Textbody">Пакет geany-plugin-addons включает в себя ряд мелких дополнений (addons) к Geany, не удостоившихся самостоятельного пакета. В его составе такие небесполезные мелочи, как:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">DocList — кнопка на панели инструментов, вызывающая список открытых документов и предложения их закрытия: </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_098.png">
        <img alt="Изображение432" class="frameGraphics" id="432graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_098.png" style="border:1.0px solid #000080;padding:0;width:248.83528px;height:340.829px" />
      </a>
      <a id="a432graphic"></a>
      <a id="bkm432graphic"></a>
    </p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">OpenURI — если элемент под курсором являет собой URI (например, http-адрес), то в контекстное меню по щелчку правой кнопкой мыши добавляются пункты Открыть URI и Редактировать URI очевидного назначения (адрес открывается в браузере, прописанном в настройках Geany): </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_099.png">
        <img alt="Изображение433" class="frameGraphics" id="433graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_099-572x434.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:435.84628px" />
      </a>
      <a id="a433graphic"></a>
      <a id="bkm433graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_099.png"> </a>
    </p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Systray — помещает пиктограмму Geany в системный трей, по щелчку левой кнопкой мыши на которой главное окно Geany сворачивается или распахивается; щелчок правой кнопкой вызывает контекстное меню с пунктами Открыть, Сохранить все, Параметры и Выход: </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_100.png">
        <img alt="Изображение434" class="frameGraphics" id="434graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_100.png" style="border:1.0px solid #000080;padding:0;width:155.85889px;height:137.83055px" />
      </a>
      <a id="a434graphic"></a>
      <a id="bkm434graphic"></a>
    </p>
    <p class="Textbody">Кроме этого, в состав пакета входит ещё несколько аддонов, о чём я скажу чуть позже. А пока — о его установке. Каковая выполняется любым из стандартных способов, например, таким:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install geany-plugin-addons</span> </p>
    <p class="Textbody">Однако установить этот плагин (как и любой другой) мало — его надо ещё и включить. Делается это через меню Инструменты -&gt; Менеджер модулей:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_101.png">
        <img alt="Изображение435" class="frameGraphics" id="435graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_101-572x434.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:435.84628px" />
      </a>
      <a id="a435graphic"></a>
      <a id="bkm435graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_101.png"> </a>
    </p>
    <p class="Textbody">На скриншоте можно видеть кнопку Параметры — она может быть активной не для всех плагинов, но для geany-plugin-addons как раз активна, и вызывает панель его настроек, содержащую полный список аддонов, каковые могут быть включены или выключены очевидным образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_102.png">
        <img alt="Изображение436" class="frameGraphics" id="436graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_102-572x434.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:435.84628px" />
      </a>
      <a id="a436graphic"></a>
      <a id="bkm436graphic"></a>
    </p>
    <p class="Textbody">Останавливаться на них я не буду, предоставив это занятие заинтересованным лицам. Отмечу только, что эта панель — общая для настройки всех плагинов, таковую позволяющих. И может быть вызвана также через меню Правка -&gt; Настройки модулей</p>
    <p class="Textbody">Что же до пакета geany-plugins — это на самом деле метапакет, объединяющий в себе в виде списка остальные 63 «плагинные» пакеты, устанавливаемые при его инсталляции одним махом. Хотя каждый из них может быть установлен и в индивидуальном порядке. Поскольку лично мне нужны далеко не все плагины, на следующей странице в индивидуальном порядке я и рассмотрю некоторые из них. А пока напомню только, что установка полного набора плагинов не приводит к их мгновенной активизации — её нужно проделать вручную только что описанным способом. А некоторые из плагинов — ещё и настроить, о чём будет сказано в каждом конкретном случае.</p>
    <h3 id="toc176"><a id="RefHeading17941713816058"></a><a id="bkmRefHeading17941713816058"></a><a id="toc175"></a><a id="bkmtoc175"></a><a id="RefHeading6161136957987"></a><a id="bkmRefHeading6161136957987"></a><a id="bkmRefHeading6161136957987"></a><a id="bkmbkmRefHeading6161136957987"></a>Geany и его макросы</h3>
    <p class="Textbody">Одно из качеств, которое отличает развитый редактор от примитивного средства набора текста и исправления опечаток, — возможность наращивания его функционала. Ибо, сколь бы мощной не была исходная программа работы с текстом, предусмотреть всё, что может потребоваться впредь, мог только резиновый Полыхаев. Поэтому непременным её атрибутом должно быть наличие подключаемых пользовательских макросов. А поскольку вся эта книга ориентирована на применителей широкого профиля, желательно, чтобы процесс создания макросов не требовал чрезмерных навыков в программировании.</p>
    <p class="Textbody">Geany в полной мере отвечает данным требованиям, позволяя записывать макросы простым протоколированием часто выполняемых действий, привязывать их к комбинациям горячих клавиш и, при необходимости, легко редактировать их либо собственными средствами, либо в текстовом редакторе (в том числе и в нём самом). Правда, делает он это не сам по себе, а с помощью специального плагина. Каковой и следует установить в первую очередь.</p>
    <p class="Textbody">В Mint'е соответствующий плагин собран в виде отдельного пакета, который отыскивается так:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt search geany-plugin | grep macro</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">p   geany-plugin-macro              - macro plugin for Geany</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">p   geany-plugin-macro:i386         - macro plugin for Gean</span> </p>
    <p class="Textbody">После чего его остаётся только установить:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install geany-plugin-macro</span> </p>
    <p class="Textbody">Впрочем, это можно сделать и через mintinstall, о чём было сказано в соответствующем очерке.</p>
    <p class="Textbody">Да, разумеется, надо не забыть активировать плагин через главное меню: Инструменты -&gt; Менеджер модулей, как это было описано в предыдущем миниочерке. А также заглянуть в его настройки через кнопку Параметры. Где, впрочем, ничего делать не надо — обе необходимые опции включены по умолчанию:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_103.png">
        <img alt="Изображение437" class="frameGraphics" id="437graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_103-527x572.png" style="border:1.0px solid #000080;padding:0;width:528.8227px;height:573.83685px" />
      </a>
      <a id="a437graphic"></a>
      <a id="bkm437graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_103.png"> </a>
    </p>
    <p class="Textbody">После этого в меню Инструменты появляются пункты Запись макроса и Редактировать макрос:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_104.png">
        <img alt="Изображение438" class="frameGraphics" id="438graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_104.png" style="border:1.0px solid #000080;padding:0;width:389.84946px;height:534.83215px" />
      </a>
      <a id="a438graphic"></a>
      <a id="bkm438graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_104.png"> </a>
    </p>
    <p class="Textbody">Как нетрудно догадаться, первый служит для протоколирования действий, которые будут претворены в макрос. Для чего требуется задать комбинацию запускающих его клавиш, имя макроса и нажать кнопку запись:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_105.png">
        <img alt="Изображение439" class="frameGraphics" id="439graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_105-572x434.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:435.84628px" />
      </a>
      <a id="a439graphic"></a>
      <a id="bkm439graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_105.png"> </a>
    </p>
    <p class="Textbody">После чего выполнить действия, которые составят содержание макроса. Например, я использую их для ввода html-тегов, причём не всех, а только самых употребимых (мной), о которых легко забыть во время окончательного оформления страницы в CMS (я пользуюсь WodrPress'ом). Поэтому я просто вводу здесь текст открывающего и закрывающего тега (во избежание лишней работы автозакрытиые тегов средствами самой Geany лучше отключить). После чего снова обращаюсь к меню Инструменты, где пункт Запись макроса превращается в Остановить запись макроса</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_106.png">
        <img alt="Изображение440" class="frameGraphics" id="440graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_106.png" style="border:1.0px solid #000080;padding:0;width:389.84946px;height:534.83215px" />
      </a>
      <a id="a440graphic"></a>
      <a id="bkm440graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_106.png"> </a>
    </p>
    <p class="Textbody">Самая сложная задача здесь — это подобрать комбинацию клавиш. Каковая должна быть</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">мнемонически значимой, и </p>
      </li>
      <li>
        <p class="Textbody">не задействованной среди горячих клавиш самой Geany и рабочей среды, в которой она запущена. </p>
      </li>
    </ol>
    <p class="Textbody">Поскольку выполнение второго требования с каждым днём становится всё сложнее, то и с мнемоникой приходится извращаться. Например, для ввода тега для моноширинного шрифта мне пришлось задействовать комбинацию Alt+m — от monospace, и так далее. Впрочем, это та земля, на которой каждый умирает в одиночку — в соответствие со своими потребностями и возможностями. Кроме того, комбинации горячих клавиш, привязанные к макросам, не работают при русской раскладке клавиатуры — хотя все штатные хоткеи Geany от раскладки не зависят. Однако это горе не великое — всё равно переключаться с кириллицы на латиницу и обратно приходится очень часто.</p>
    <p class="Textbody">Прямым протоколированием обычно трудно получить аккуратную макрокманду, не содержащую избыточных нажатий на клавиши. И тут стоит обратиться к пункту Редактировать макрос, которым вызывается список всех записанных макросов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_107.png">
        <img alt="Изображение441" class="frameGraphics" id="441graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_107.png" style="border:1.0px solid #000080;padding:0;width:405.83685px;height:302.84473px" />
      </a>
      <a id="a441graphic"></a>
      <a id="bkm441graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_107.png"> </a>
    </p>
    <p class="Textbody">Как явствует из скриншота, любой из макросов можно перезаписать, удалить или отредактировать. Последняя операция, например, для редактирования гиперссылки выглядит так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_108.png">
        <img alt="Изображение442" class="frameGraphics" id="442graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_108-572x169.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:170.82584px" />
      </a>
      <a id="a442graphic"></a>
      <a id="bkm442graphic"></a>
    </p>
    <p class="Textbody">Порядок действий по редактированию макросов очевиден, поэтому останавливаться на этом вопросе не буду. Замечу только, что это — не единственный способ выполнения данной процедуры. Ибо описание всех макросов содержится в файле /home/alv/.config/geany/plugins/Geany_Macros/settings.conf. Это — обычный текстовый файл, и в соответствующем предыдущему скриншоту виде выглядит так:</p>
    <p class="Textbody"><span style="background-color:#dddddd">[Settings]</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Save_Macros=true</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Question_Macro_Overwrite=true</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">[Macros]</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">A0=code</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">B0=109</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">C0=8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">D0=2170,&lt;code&gt;,2170,&lt;/code&gt;,2304,2304,2304,2304,2304,2304,2304</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">A1=highlighted</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">B1=104</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">C1=8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">D1=2170,&lt;strong&gt;,2170,&lt;/strong&gt;,2304,2304,2304,2304,2304,2304,2304,2304,2304</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">A2=strike</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">B2=115</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">C2=8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">D2=2170,&lt;s&gt;,2170,&lt;/s&gt;,2304,2304,2304,2304</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">A3=italic</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">B3=105</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">C3=8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">D3=2170,&lt;em&gt;,2170,&lt;/em&gt;,2304,2304,2304,2304,2304</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">A4=listing</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">B4=112</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">C4=8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">D4=2170,&lt;pre&gt;,2329,2329,2170,&lt;/pre&gt;,2302</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">A5=link</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">B5=117</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">C5=8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">D5=2170,&lt;a href=\\»\\»&gt;,2170,&lt;/a&gt;,2304,2304,2304,2304</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">A6=remote</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">B6=114</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">C6=8</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">D6=2170,&lt;a href=\\»\\» target=\\»_blank\\» rel=\\»nofollow\\»&gt;,2170,&lt;/a&gt;,2304,2304,2304,2304</span> </p>
    <p class="Textbody">А потому может быть отредактирован непосредственно в текстовом редакторе — например, в самом Geany.</p>
    <h3 id="toc177"><a id="RefHeading17961713816058"></a><a id="bkmRefHeading17961713816058"></a><a id="toc176"></a><a id="bkmtoc176"></a><a id="RefHeading6181136957987"></a><a id="bkmRefHeading6181136957987"></a><a id="bkmRefHeading6181136957987"></a><a id="bkmbkmRefHeading6181136957987"></a>Geany и multiterm</h3>
    <p class="Textbody">Не так давно мы говорили о штатном встроенном терминале Geany — его хватает почти во всех случаях. Однако у него есть и более функциональный аналог — Multiterm, реализованный в виде плагина geany-plugin-multiterm. Его особенностью, как можно догадаться из названия, является поддержка вкладок (Tabs). Плагин этот входит в состав метапакета geany-plugins, но может быть установлен и отдельно, например, так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install geany-plugins</span> </p>
    <p class="Textbody">После чего его надо активировать — никаких настроек для него на первый взгляд не предусмотрено:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_109.png">
        <img alt="Изображение443" class="frameGraphics" id="443graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_109.png" style="border:1.0px solid #000080;padding:0;width:508.82895px;height:481.84317px" />
      </a>
      <a id="a443graphic"></a>
      <a id="bkm443graphic"></a>
    </p>
    <p class="Textbody">После этого в окне сообщений появляется новая вкладка, которая так и называется Multiterm. И по умолчанию имеет весьма бледный вид:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_110.png">
        <img alt="Изображение444" class="frameGraphics" id="444graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_110-572x128.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:129.85576px" />
      </a>
      <a id="a444graphic"></a>
      <a id="bkm444graphic"></a>
    </p>
    <p class="Textbody">В частности, запущенный в этом окне шелл и представляется как /bin/bash. Однако он запущен в режиме эмуляции POSIX shell, то есть не умеет ни автодополнения, ни истории команд... короче, ничего, за что мы так любим современные командные оболочки. Вызванное по аналогии со штатным терминалом контекстное меню позволяет открыть новую вкладку или переместить окно Multiterm в боковую панель (зачем это нужно — не знаю), но не содержит никаких возможностей для настройки:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_111.png">
        <img alt="Изображение445" class="frameGraphics" id="445graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_111.png" style="border:1.0px solid #000080;padding:0;width:173.84946px;height:118.85732px" />
      </a>
      <a id="a445graphic"></a>
      <a id="bkm445graphic"></a>
    </p>
    <p class="Textbody">Кстати, в Mint'е не работает и пункт Open Window — и сейчас станет ясно почему.</p>
    <p class="Textbody">Однако доступ к настройкам возможен прямым редактированием конфига этого плагина — ~.config/geany/plugins/multiterm/multiterm.conf. Он разделяется три секции:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">General Settings — общие свойства; </p>
      </li>
      <li>
        <p class="Textbody">Default Shell — свойства умолчальной оболочки; </p>
      </li>
      <li>
        <p class="Textbody">Other Shells — свойства прочих оболочек. </p>
      </li>
    </ul>
    <p class="Textbody">В первой из них можно, в частности, переопределить значение параметра external_terminal с умолчального xterm на, например, gnome-terminal. После этого волшебным образом заработает пункт Open Window из контекстного меню — он будет открывать терминал GNOME: дело в том, что в Mint'е по умолчанию xterm не устанавливается.</p>
    <p class="Textbody">В секции Default Shell следует в первую очередь заменить этот самый default'ный шелл на что-то более человеческое, отредактировав строку</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">command=sh</span> </p>
    <p class="Textbody">должным образом, например, у меня таким:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">command=/bin/zsh</span> </p>
    <p class="Textbody">Очевидно, что, отредактировав строки</p>
    <p class="Textbody"><span style="background-color:#dddddd">bg_color=#ffffff</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">fg_color=#000000</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">font=Monospace 9</span> </p>
    <p class="Textbody">можно изменить цвет фона, текста и шрифтоначертание с кеглем для него, соответственно. Например, у меня это сделано так:</p>
    <p class="Textbody"><span style="background-color:#dddddd">bg_color=#D6D6D6</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">fg_color=#000000</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">font=Monospace 15</span> </p>
    <p class="Textbody">А сняв комментарий со строки</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">scrollback_lines=1024</span> </p>
    <p class="Textbody">можно установить желаемую величину для прокрутки истории.</p>
    <p class="Textbody">В Multiterm нет опции следования пути текущего файла — смена каталога возможна только прямой командой cd. Поэтому его можно держать включённым в паре со щтатным терминалом, когда требуется одновременный доступ и к каталогу текущего документа, и к некоему фиксированному каталогу. И даже к нескольким — не будем забывать про возможность открытия табов, в каждом из которых запускается свой экземпляр шелла.</p>
    <p class="Textbody">К сожалению, в Multiterm не и кое-чего другого, более важного. В частности, в нём категорически отказываются работать стандартные кейбиндинги типа Control+A, Control+E и им подобные. Поэтому в качестве замены штатному терминалу Geany он никак не годится. Но как его дополнение в некоторых случаях может быть полезен.</p>
    <h3 id="toc178"><a id="RefHeading17981713816058"></a><a id="bkmRefHeading17981713816058"></a><a id="toc177"></a><a id="bkmtoc177"></a><a id="RefHeading6201136957987"></a><a id="bkmRefHeading6201136957987"></a><a id="bkmRefHeading6201136957987"></a><a id="bkmbkmRefHeading6201136957987"></a>Geany и управление файлами</h3>
    <p class="Textbody">Казалось бы, управление файлами не имеет никакого отношения к сочинению и редактированию текстов, тем более нарративных. Однако практика показывает, что это не так — когда доходит до масштабных проектов, типа сочинения книги, оказывается, что средства файлового менеджмента отнюдь не лишни. Ибо они неразрывно связаны со средствами управления проектами, о которых пойдёт речь в следующем миниочерке.</p>
    <p class="Textbody">Прежде чем заводить речь о средствах управления файлами в Geany, надо напомнить сказанное ранее о его боковой панели, посредством которой управление файлами осуществляется. По умолчанию, без подключени каких бы то ни было плагинов, она содержит две вкладки — Символы и Документы.<br />Отображение любой из этих вкладок (и даже обеих сразу) можно отключить через меню — Правка -&gt; Настройка -&gt; Интерфейс -&gt; Интерфейс:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_112.png">
        <img alt="Изображение446" class="frameGraphics" id="446graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_112-572x293.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:294.83212px" />
      </a>
      <a id="a446graphic"></a>
      <a id="bkm446graphic"></a>
    </p>
    <p class="Textbody">Что я и делаю, так как обычно они мне не нужны. А высвободившуюся боковую панель (вывод которой, кстати, тоже можно отключить вообще) использую как раз для управления файлами. Средств для чего в Geany как минимум два (не считая средств CLI, доступных через встроенный терминал). Первое из них — filebrowser, который ныне входит в штатный комплект основного пакета. Однако включается он по прежнему через меню Инструменты -&gt; Менеджер модулей -&gt;Просмотр файлов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_113.png">
        <img alt="Изображение447" class="frameGraphics" id="447graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_113-572x318.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:319.8526px" />
      </a>
      <a id="a447graphic"></a>
      <a id="bkm447graphic"></a>
    </p>
    <p class="Textbody">Впрочем, ничего особенного, кроме просмотра файловой иерархии и простейших средств навигации, оно и не даёт:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_114.png">
        <img alt="Изображение448" class="frameGraphics" id="448graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_114.png" style="border:1.0px solid #000080;padding:0;width:324.84158px;height:220.82898px" />
      </a>
      <a id="a448graphic"></a>
      <a id="bkm448graphic"></a>
    </p>
    <p class="Textbody">Разве что через пункт Параметры из контекстного меню можно включить полезные пункты Следовать пути текущего файла и Использовать каталог проекта.</p>
    <p class="Textbody">Хотя в комбинации со средствами CLI из встроенного терминала даже такой примитив оказывается полезным. Так, самым простым средством создания нового документа оказывается не главное меню Geany Файл -&gt; Создать(или соответствующая кнопка на инструментальной панели), ибо потом надо долго рыскать, куда записать этот самый новосозданный файл, чтобы он нашёл свое место в структуре проекта. А гораздо проще, при включённом следовании, так во встроенном терминальном окне команду</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ touch [файл_имя_рек]</span> </p>
    <p class="Textbody">Затем в боковой панели нажать кнопку Обновить и их неё же открыть новосозданный пустой файл.</p>
    <p class="Textbody">Но в Geany есть и более мощное средство управления файлами — плагин geany-plugin-treebrowser. Который устанавливается стандартным образом, и точно так же включается. После чего из контекстного меню становятся доступными многие функции стандартного файлового менеджера:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_115.png">
        <img alt="Изображение449" class="frameGraphics" id="449graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_115-572x417.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:418.8385px" />
      </a>
      <a id="a449graphic"></a>
      <a id="bkm449graphic"></a>
    </p>
    <p class="Textbody">Да, не все, какие могут потребоваться. Но по крайней мере создавать новый файл в составе существующего проекта становится легко и просто. А с остальным, ребята, и сами разберётесь, если будет нужно...</p>
    <h3 id="toc179"><a id="RefHeading18001713816058"></a><a id="bkmRefHeading18001713816058"></a><a id="toc178"></a><a id="bkmtoc178"></a><a id="RefHeading6221136957987"></a><a id="bkmRefHeading6221136957987"></a><a id="bkmRefHeading6221136957987"></a><a id="bkmbkmRefHeading6221136957987"></a>Geany: управление проектами</h3>
    <p class="Textbody">Всякому профессиональному сочинителю приходится писать не только отдельные статьи или заметки, но и их циклы или серии (а то и, страшно сказать, книги). И при этом часто работа над такими циклами/сериями разной тематики проходит в параллельном режиме, так что требуется быстрое переключение из окружения одного цикла (а это не только сами тексты, но и иллюстрирующие их картинки, а также всякого рода служебные материалы) в среду другого.</p>
    <p class="Textbody">Тут-то на помощь сочинителю приходят встроенные в текстовый редактор средства управления проектами — если, конечно, они в нём есть. Благо, в Geany такие средства имеются, и даже не в единственном экземпляре: одно штатное и два внештатных, обеспечивающихся отдельными плагинами.</p>
    <p class="Textbody">Как нетрудно догадаться, работа с проектами осуществляется через одноимённый пункт главного меню. Столь же очевидно, что начинается эта работа с создания проекта через пункт Новый:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_116.png">
        <img alt="Изображение450" class="frameGraphics" id="450graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_116.png" style="border:1.0px solid #000080;padding:0;width:340.829px;height:179.8589px" />
      </a>
      <a id="a450graphic"></a>
      <a id="bkm450graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_116.png"> </a>
    </p>
    <p class="Textbody">Однако прежде не плохо выполнить некоторые глобальные настройки, общие для всех проектов. Которые выполняются через пункты Правка -&gt; Настройки -&gt; Общее. Сначала по вкладке Запуск указывается общий путь к файлам проекта. Поскольку проект наверняка будет не один (иначе не стоило бы и огород городить), есть смысл задать его в максимально обобщённом виде, а далее дописывать конкретные подкаталоги:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_117.png">
        <img alt="Изображение451" class="frameGraphics" id="451graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_117-572x293.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:294.83212px" />
      </a>
      <a id="a451graphic"></a>
      <a id="bkm451graphic"></a>
    </p>
    <p class="Textbody">Здесь же полезно задать стартовый каталог (для меня удобно, чтобы он совпадал с путём к подкаталогам проектов, но это уж каждый для себя решит сам) и включить загрузку файлов из последней сессии. После чего перейти на вкладку Прочее и там в секции Проекты отметить пункт Использовать файлы сессий для проектов. В сочетании с загрузкой файлов из последней сессии на предыдущей вкладке это приведёт к тому, что при старте Geany будет открываться последний проект в том самом состоянии, в каком работа с ним была прервана:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_118.png">
        <img alt="Изображение452" class="frameGraphics" id="452graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_118-572x293.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:294.83212px" />
      </a>
      <a id="a452graphic"></a>
      <a id="bkm452graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_118.png"> </a>
    </p>
    <p class="Textbody">А вот пункт Хранить файл проекта внутри основного каталога проекта включается по желанию. По умолчанию Geany хранит все файлы описания проектов (вида project_name.geany)в отдельном каталоге, который так и называется — path2/projetcs (или, в русской локализации, path2/проекты). Если же включить означенный пункт, то файл описания проекта будет размещаться непосредственно в его каталоге. Мне это представляется удобным, особенно при сохранении резервных копий, однако применителю следует определить это для себя.</p>
    <p class="Textbody">Теперь можно взяться за создание проекта, для чего в меню Проект выбирается пункт Новый. Если при этом был окрыт какой-либо ранее существовавший проект — последует предложение его закрыть, с чем следует согласиться: два одновременно открытых проекта Geany не поддерживает. После чего возникает вот такая панель — разумеется, пока без имени проекта:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_119.png">
        <img alt="Изображение453" class="frameGraphics" id="453graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_119-572x417.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:418.8385px" />
      </a>
      <a id="a453graphic"></a>
      <a id="bkm453graphic"></a>
    </p>
    <p class="Textbody">Если все настройки были сделаны, как описано выше — то достаточно задать это самое имя проекта (совпадающее с именем каталога с его файлами), и нажать кнопку Создать. И проект, вместе с файлом его описания (в данном случае /home/data/current/alv.me/distros/distros.geany), будет создан.</p>
    <p class="Textbody">Для открытия существующего проекта предназначен пункт меню Проект -&gt; Открыть, после чего в дереве файловой иерархии потребуется отыскать каталог проекта, а в нём — файло описания:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_120.png">
        <img alt="Изображение454" class="frameGraphics" id="454graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_120-572x423.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:424.84787px" />
      </a>
      <a id="a454graphic"></a>
      <a id="bkm454graphic"></a>
    </p>
    <p class="Textbody">Это может быть достаточно скучно. И потому между существующими проектами проще переключаться через Проект -&gt; Последние проекты:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_121.png">
        <img alt="Изображение455" class="frameGraphics" id="455graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_121-572x127.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:128.83528px" />
      </a>
      <a id="a455graphic"></a>
      <a id="bkm455graphic"></a>
    </p>
    <p class="Textbody">Впрочем, и в том, и в другом случае, как я уже говорил, проект будет открыт точно в том состоянии, в котором с ним была прекращена работа — то есть со всеми файлами, открытыми в последней сессии.</p>
    <p class="Textbody">Основные данные о проекте можно посмотреть через Проект -&gt; Свойства. Здесь, в частности, можно поменять имя проекта, его описание и рабочий каталог:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_122.png">
        <img alt="Изображение456" class="frameGraphics" id="456graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_122-572x241.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:242.82585px" />
      </a>
      <a id="a456graphic"></a>
      <a id="bkm456graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_122.png"> </a>
    </p>
    <p class="Textbody">А вот изменить путь к файлу описания проекта здесь не получится. Но это можно сделать через конфигурационный файла Geany — ~/.config/geany/geany.conf. Это простой текстовый файл, в котором отражаются все настройки редактора, выполненные интерактивно. Но который можно и отредактировать непосредственно. В частности, именно здесь, в секции [project], можно изменить путь к файлу описания проекта — например, если его рабочий каталог был перемещён в другое место файловой иерархии.</p>
    <p class="Textbody">Кроме штатной системы управления проектами, для этой цели в Geany существует два плагина — geany-plugin-gproject и geany-plugin-prj. Первый является дополнением штатного средства, предлагая управление проектами Geany на основе шаблонов. Включение его через Инструменты -&gt; Менеджер модулей приводит к появлению в боковой панели вкладки Проект с несколькими пиктограммами. Честно говоря, я так и не придумал, как прикрутить шаблоны к своим проектам — и главное, зачем мне это нужно. И потому отключил этот плагин.</p>
    <p class="Textbody">Плагин же geany-plugin-prj представляет собой полную систему управления проектами, альтернативную штатной. При его включении в боковой панели также появляется вкладка Проект — абсолютно пустая, но с контекстным меню по правой кнопке мыши:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_123.png">
        <img alt="Изображение457" class="frameGraphics" id="457graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_123.png" style="border:1.0px solid #000080;padding:0;width:253.82425px;height:220.82898px" />
      </a>
      <a id="a457graphic"></a>
      <a id="bkm457graphic"></a>
    </p>
    <p class="Textbody">Вследствие своей альтернативности этот плагин игнорирует штатные файлы описания проектов — для него их надо создавать с нуля, как можно видеть на приведённом скриншоте. Выбор пункта Новый проект вызывает такую вот панель:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_124.png">
        <img alt="Изображение458" class="frameGraphics" id="458graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_124.png" style="border:1.0px solid #000080;padding:0;width:542.8447px;height:233.83054px" />
      </a>
      <a id="a458graphic"></a>
      <a id="bkm458graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_124.png"> </a>
    </p>
    <p class="Textbody">В ней указывается имя проекта, определяются расположение файла его описания (это dot-файл geanyprj и рабочий каталог. После нажатия кнопки Создать все файлы рабочего каталога включаются в проект и выводятся в соответствующей вкладке боковой панели, и генерируется файл описания:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_125.png">
        <img alt="Изображение459" class="frameGraphics" id="459graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_125-572x417.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:418.8385px" />
      </a>
      <a id="a459graphic"></a>
      <a id="bkm459graphic"></a>
    </p>
    <p class="Textbody">После создания проекта через контекстное меню на его вкладке в боковой панели становятся доступными, помимо прочих, пункты Найти в проекте и Настройки. Собственно, поиск в проекте — это главная особенность альтернативного управления проектами:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_126.png">
        <img alt="Изображение460" class="frameGraphics" id="460graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_126-572x271.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:272.8353px" />
      </a>
      <a id="a460graphic"></a>
      <a id="bkm460graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_126.png"> </a>
    </p>
    <p class="Textbody">Результаты поиска выводятся в окне сообщений, как это видно на скриншоте, предшествующем последнему.</p>
    <p class="Textbody">Ну а через пункт Настройки, как и в штатном «управителе проектами», можно поменять его имя и базовый каталог (но не положение и имя файла описания проекта):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/05-geany_127.png">
        <img alt="Изображение461" class="frameGraphics" id="461graphic" src="http://alv.me/wp-content/img/im_cin_img/05-geany_127.png" style="border:1.0px solid #000080;padding:0;width:542.8447px;height:227.8589px" />
      </a>
      <a id="a461graphic"></a>
      <a id="bkm461graphic"></a>
    </p>
    <p class="Textbody">Все функции контекстного меню дублируются также в меню главном — Инструменты -&gt; Проект.</p>
    <p class="Textbody">Повозившись с альтернативным «управителем проектов», я пришёл к выводу, что использование его имеет смысл действительно как альтернатива — совместное применение его со штатным средством этого назначения приводит к путанице. А поскольку главным для меня в этом деле — простой способ быстрого переключения между проектами (что в штатном средстве реализовано лучше), я в конце концов отключил «альтернативщика». Но возможно, что кому-то он покажется более удобным.</p>
    <h2 id="toc180"><a id="RefHeading18021713816058"></a><a id="bkmRefHeading18021713816058"></a><a id="toc179"></a><a id="bkmtoc179"></a><a id="RefHeading12901136957987"></a><a id="bkmRefHeading12901136957987"></a><a id="bkmRefHeading12901136957987"></a><a id="bkmbkmRefHeading12901136957987"></a>Текстовый редактор Komodo Edit</h2>
    <p class="Textbody">Текстовый редактор Geany я применял на протяжении многих лет, люблю его и более или менее знаю. А потому и уделил ему столько места. Однако последнее время основным моим инструментом для работы с текстами стал Komodo Edit. И не написать о нём здесь я не мог. Мой стаж Komodo'вания едва составляет полгода, так что особых подробностей не будет — лишь отдельные заприсовки по его применению. Но надеюсь, что кому-нибудь они пригодятся для ориентировки в океане текстовых редакторов.</p>
    <h3 id="toc181"><a id="RefHeading18041713816058"></a><a id="bkmRefHeading18041713816058"></a><a id="toc180"></a><a id="bkmtoc180"></a><a id="RefHeading6241136957987"></a><a id="bkmRefHeading6241136957987"></a><a id="bkmRefHeading6241136957987"></a><a id="bkmbkmRefHeading6241136957987"></a>Обзор</h3>
    <p class="Textbody">Во избежание недоразумений (которым я в своё время поддался) надо для начала сказать, что под именем Komodo выступают две довольно разные программы:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">Komodo IDE, полноценная интегрированная среда разработки, имеющая статус коммерческой, стоимостью под сотню баксов (для осознания того, за что они платятся, доступна трёхнедельная Trial'ная версия), и </p>
      </li>
      <li>
        <p class="Textbody">Komodo Edit (далее KE), представляющий собой развитый текстовый редактор с поддержкой управления проектами, протоколированием макросов и прочими функциями, сопоставимыми с таковыми в Geany; он распространяется на условиях Mozilla Public License, то есть являет собой свободный Open Source в чиcтом виде. </p>
      </li>
    </ol>
    <p class="Textbody">Общее между этими программами то, что они разрабатываются одними и теми же людьми — сотрудниками фирмы <a href="http://alv.me/»http://www.activestate.com/»" target="»_blank»">Active State</a>, Komode IDE полностью, Komode Editor — при участии сообщества.</p>
    <p class="Textbody">Для установки Komodo Editor (далее KE) предлагается скачать его в виде архива бинарников с <a href="http://alv.me/»http://downloads.activestate.com/Komodo/releases/8.5.4/»" target="»_blank»">сайта фирмы</a> (текущая на данный момент версия — 8.5.4), развернуть архив и запустить установочный скрипт. Этот рецепт подходит для произвольного дистрибутива.</p>
    <p class="Textbody">Однако в дистрибутивах из кланов Ubuntu и Mint'а можно поступить проще и правильней: KE имеется на <a href="http://alv.me/»https://launchpad.net/»" target="»_blank»">Launchpad</a>'е в виде <a href="http://alv.me/»https://launchpad.net/%7Emystic-mirage/+archive/ubuntu/komodo-edit»" target="»_blank»">бинарного пакетая</a>. Так что для его установки просто подключаем его репозиторий:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo add-apt-repository ppa:mystic-mirage/komodo-edit</span> </p>
    <p class="Textbody">Выполняем обновление локального кеша:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt update</span> </p>
    <p class="Textbody">Проверяем доступность пакета и его точное имя:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt search komodo</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">i   komodo-edit                     - Komodo Edit is a free, open source editor</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">p   komodo-edit:i386                - Komodo Edit is a free, open source editor</span> </p>
    <p class="Textbody">После чего только и только остаётся этот пакет установить:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$=&gt; sudo apt install komodo-edit</span> </p>
    <p class="Textbody">Теперь запустить редактор можно прямой командой komodo-editиз CLI или минитерминала. Ну и, конечно, из главного меню — Программирование -&gt; KomodoEdit.</p>
    <p class="Textbody">После первого запуска сначала появляется панель быстрого запуска, почти загораживающая всё остальное:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_128.png">
        <img alt="Изображение462" class="frameGraphics" id="462graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_128-572x472.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:473.83063px" />
      </a>
      <a id="a462graphic"></a>
      <a id="bkm462graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_128.png"> </a>
    </p>
    <p class="Textbody">А после её закрытия (её можно удалить со старта раз и навсегда, вызывая по необходимости) KE предстаёт примерно в следующем обличье:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_129.png">
        <img alt="Изображение463" class="frameGraphics" id="463graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_129-572x326.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:327.82742px" />
      </a>
      <a id="a463graphic"></a>
      <a id="bkm463graphic"></a>
    </p>
    <p class="Textbody">Разумеется, в таком виде KE не может внушить ничего, кроме ужаса от мысли, что в этом надо ещё и работать... Однако первоочередные шаги по приведению его в человеческий вид Brego <a href="http://mintmem.com/page/komodo-edit_1#ke3" target="_blank">описаны</a> Валерием Желябовским, и повторять его я не буду. А остановлюсь на тех моментах, которые представляют для меня самый большой интерес.</p>
    <h3 id="toc182"><a id="RefHeading18061713816058"></a><a id="bkmRefHeading18061713816058"></a><a id="toc181"></a><a id="bkmtoc181"></a><a id="RefHeading6261136957987"></a><a id="bkmRefHeading6261136957987"></a><a id="bkmRefHeading6261136957987"></a><a id="bkmbkmRefHeading6261136957987"></a>Русификация</h3>
    <p class="Textbody">Первое — русификация интерфейса KE. Таковая имеет место быть благодаря усилиям <a href="https://www.blogger.com/profile/03694394820347716753" target="_blank">laborpago</a> (за что и ему спасибо большое). И может быть выполнена двумя способами. Первый — скачать авторский пакет с его страницы. Он собран в виде расширения для KE — файла вида localru-*-ko.xpi — нужно только проследить, чтобы версия пакета соответствовала версии KE, ибо они жёстко привязаны друг к другу.</p>
    <p class="Textbody">Установка русификатора в этом случае выполняется через меню KE: Tools -&gt; Add-ons, что вызывает такую панель:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_130.png">
        <img alt="Изображение464" class="frameGraphics" id="464graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_130-572x307.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:308.85416px" />
      </a>
      <a id="a464graphic"></a>
      <a id="bkm464graphic"></a>
    </p>
    <p class="Textbody">Слева от поля для поискового запроса можно видеть кнопку весьма бледного вида, которая вызывает каскадное меню — в нём нужно выбрать пункт Установить дополнение из файла:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_131.png">
        <img alt="Изображение465" class="frameGraphics" id="465graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_131.png" style="border:1.0px solid #000080;padding:0;width:533.8495px;height:158.84473px" />
      </a>
      <a id="a465graphic"></a>
      <a id="bkm465graphic"></a>
    </p>
    <p class="Textbody">А по выборе нужного файла в следующей панели нажимается кнопка Install Now:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_132.png">
        <img alt="Изображение466" class="frameGraphics" id="466graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_132-572x339.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:340.829px" />
      </a>
      <a id="a466graphic"></a>
      <a id="bkm466graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_132.png"> </a>
    </p>
    <p class="Textbody">После чего остаётся только перезагрузить KE. Кстати, этот миниочерк сочинялся в KE после его русификации, и потому на всех скриншотах можно видеть русские буковки в интерфейсе (не раз-русифицировать же KE обратно, как сказал Жорж Милославский).</p>
    <p class="Textbody">Второй способ русификации — ещё проще: в том же репозитории ppa:mystic-mirage/komodo-edit существует и штатный пакет аналогичного назаначения:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ apt search komodo-edit-ru</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">p   komodo-edit-ru      - Komodo Edit is a free, open source editor</span> </p>
    <p class="Textbody">Который, соответственно, можно установить через apt.</p>
    <p class="Textbody">Претензий к работе русификатора, установленного как Add-ons, у меня не было, но полноты раскрытия темы я решил попробовать и этот метод. Для чего отключил расширение localru через меню: Дополнения -&gt; Языки, перезапустил KE, чтобы убедиться в возврате англоязычного интерфейса, и установил пакет из репозитория:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$=&gt; sudo apt install komodo-edit-ru</span> </p>
    <p class="Textbody">Однако после перезапуска KE ни малейших следов русского языка в интерфейсе не обнаружилось. Тогда я удалил localru вообще (через те же пункты меню), и выполнил реинсталляцию пакета:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$=&gt; sudo apt install --reinstall komodo-edit-ru</span> </p>
    <p class="Textbody">После чего интерфейс волшебным образом русифицировался, а среди дополнений в языках обнаружилось всё то же самое LocalRU 1.14:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_133.png">
        <img alt="Изображение467" class="frameGraphics" id="467graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_133-572x307.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:308.85416px" />
      </a>
      <a id="a467graphic"></a>
      <a id="bkm467graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_133.png"> </a>
    </p>
    <p class="Textbody">Иными словами, это просто один и тот же пакет laborpago. Только из авторского дополнения его компоненты устанавливаются в .komodoedit/8.5/XRE/extensions/, а из deb-пакета — в /usr/lib/komodo-edit/mozilla/extensions/. Что во втором случае требует, соответственно, привилегий администратора, но зато русификация распространяется на всех возможных пользователей KE.</p>
    <p class="Textbody">Оба способа русификации — вполне штатные: первый — с точки зрения KE, второй — с позиций deb based дистрибутивов, оба допускают автоматическое обновление, ну и русские слова в результате получаются одними и теми же. Так что каким способом пользоваться — дело вкуса. С точки зрения <a href="http://alv.me/?p=6229">сборки собственных ремиксов</a> для меня оказался предпочтительным второй.</p>
    <p class="Textbody">В KE имеется спеллинг, и весьма развитый, с возможностью подключения и пополнения пользовательского словаря. Но только — для англоязычных текстов, никакого намёка на русский язык поначалу не обнаруживается:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_134.png">
        <img alt="Изображение468" class="frameGraphics" id="468graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_134-572x403.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:404.85416px" />
      </a>
      <a id="a468graphic"></a>
      <a id="bkm468graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_134.png"> </a>
    </p>
    <p class="Textbody">Однако оказалось, что проблема эта решается сама собой, причём не просто, и даже не очень просто, а ещё проще. Из просмотра сайта <a href="http://community.activestate.com/" target="_blank">ActiveState Community</a> выяснилось, что в KE используются те же самые словари, что и в Mozilla, то есть словари для hunspell'а. Однако общесистемные словари, например, вроде установленного у меня hunspell-ru-ie-yo (с поддержкой буквы Ё) он не видит — ему требуется собственные их копии, расположенные в каталоге /usr/lib/komodo-edit/mozilla/dictionaries. По умолчанию там лежат файлы только для словаря американского английского: en-US.aff и en-US.dic. Так что достаточно скопировать в него из /usr/share/hunspell файлы ru_RU.aff ru_RU.dic — и русский язык в панели спеллинга появится незамедлительно:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_135.png">
        <img alt="Изображение469" class="frameGraphics" id="469graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_135.png" style="border:1.0px solid #000080;padding:0;width:537.8558px;height:292.82898px" />
      </a>
      <a id="a469graphic"></a>
      <a id="bkm469graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_136.png">
        <img alt="Изображение470" class="frameGraphics" id="470graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_136.png" style="border:1.0px solid #000080;padding:0;width:201.85574px;height:59.858894px" />
      </a>
      <a id="a470graphic"></a>
      <a id="bkm470graphic"></a>
    </p>
    <p class="Textbody">Выбранный один раз в данном документе, русский язык при проверке орфографии становится умолчальным не только в текущем проекте, но также и во всех открытых в данный момент проектах. Правда, подчёркивания ошибочно написанных слов в KE не предусмотрено. Что, с одной стороны, хорошо — не так рябит в глазах при обилии незнакомых словарю слов и иноязычных вкраплений. Но с другой — плохо, потому что... ну вы сами понимаете, почему.</p>
    <h3 id="toc183"><a id="RefHeading18081713816058"></a><a id="bkmRefHeading18081713816058"></a><a id="toc182"></a><a id="bkmtoc182"></a><a id="RefHeading6281136957987"></a><a id="bkmRefHeading6281136957987"></a><a id="bkmRefHeading6281136957987"></a><a id="bkmbkmRefHeading6281136957987"></a>Управление проектами</h3>
    <p class="Textbody">Следующий вопрос, живо меня интересующий — управление проектами. И здесь всё оказалось очень здорово. Во-первых, управление проектами в KE есть. Во-вторых, проект создаётся не просто, а очень просто (то есть проще даже, чем в Geany). Например, это можно сделать через меню Проект -&gt; Новый проект, задав имя проекта и рабочий каталог для него:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_137.png">
        <img alt="Изображение471" class="frameGraphics" id="471graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_137-572x423.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:424.84787px" />
      </a>
      <a id="a471graphic"></a>
      <a id="bkm471graphic"></a>
    </p>
    <p class="Textbody">Столь же легко создаются и все последующие проекты, сколько их потребуется. При этом задаётся вопрос, закрывать ли файлы текущего проекта? И, в отличие от Geany, вопрос этот не риторический, на него вполне можно ответить отрицательно, и новый проект будет создан при сохранении предыдущего в открытом состоянии:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_138.png">
        <img alt="Изображение472" class="frameGraphics" id="472graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_138-572x118.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:119.840004px" />
      </a>
      <a id="a472graphic"></a>
      <a id="bkm472graphic"></a>
    </p>
    <p class="Textbody">В левой боковой панели легко выводится файловая иерархия внутри каталога текущего проекта (по умолчанию — до 10 уровней вложенности, при необходимости можно увеличить). Здесь же не менее легко открывается подпанель со списком созданных проектов, через которую легко переключаться между ними. При этом, как и при создании нового проекта, файлы предыдущего проекта можно сохранить в открытом состоянии, параллельно с файлами проекта следующего. И переключаться между ними через вкладки главного окна, предназначенного для редактирования текста.</p>
    <p class="Textbody">Возможность параллельной работы с файлами из разных проектов — та самая функция, которой мне так не хватало в Geany, ибо я постоянно работаю с несколькими самостоятельными, но тесно связанными проектами, между которыми необходим обмен данными. И KE мне такую возможность предоставил.</p>
    <h3 id="toc184"><a id="RefHeading18101713816058"></a><a id="bkmRefHeading18101713816058"></a><a id="toc183"></a><a id="bkmtoc183"></a><a id="RefHeading6301136957987"></a><a id="bkmRefHeading6301136957987"></a><a id="bkmRefHeading6301136957987"></a><a id="bkmbkmRefHeading6301136957987"></a>Макросы</h3>
    <p class="Textbody">Второй очень важный для меня момент связан с макросами. Для применителя-текстовика, работающегов разных жанрах, очень важно иметь возможность расширить базовую функциональность редактора в соответствие со своими задачами, причём сделать это простым и понятным способом. В Geany имеется удобный режим протоколирования макросов с возможностью их последующего редактирования. А если ли что-нибудь подобное в KE?</p>
    <p class="Textbody">Оказалось, что в KE прибегать к сочинению собственных макросов поводов не много. Ибо он штатно снабжён их набором, вполне достаточным, например, для простой разметки html-документов, как в существующем виде, так и после минимального редактирования. Впрочем, и режим протоколирования действий для помещёния их в макросы также имеется, как и возможность последующего редактирования.</p>
    <p class="Textbody">Почти нет ограничений для привязки к макросам горячих клавиш — при нахождении в окне KE им перехватывается большинство общесистмных клавиатурных комбинаций. Так что не надо, как в Geany, напрягать свою фантазию для изобретения хоткеев, с одной стороны, мнемонически прозрачных, с другой — не задействованных для нужд текущего десктопа или оконного менеджера.</p>
    <p class="Textbody">Штатно в KE не обнаруживается статистики документов. Однако среди макросов нашёлся один, подсчитывающий количество слов с помощью утилиты wc. Правкой буквально одного символа можно заставить его считать число символов в документе или объём его файла в байтах.</p>
    <p class="Textbody">Примеры простых макросов в KE можно умножать до бесконечности. Результаты своих упражнений я всёл в шпаргалку по этой теме. Она предназначена для внутреннего употребления, и главное в ней — это мнемоника для хоткеев, потому как они придумывались для разных редакторов в разное время, чисто ассоциативно на тот момент. То есть носят сугубо личный характер. Но возможно, что эта шпаргалка пригодится как напоминание о том, что каждый может сделать такую же для себя — со своей мнемоникой и своими ассоциациями.</p>
    <p class="Textbody">Теги для выделения текста:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Code — ввод моноширинного текста, хоткей Alt+m (от Monospace); </p>
      </li>
      <li>
        <p class="Textbody">Emphasis — ввод курсивного шрифтоначертания, хоткей Alt+i (от Italic); </p>
      </li>
      <li>
        <p class="Textbody">Strong — ввод полужирного шрифтоначертания, хоткей Alt+b (от Bold); </p>
      </li>
      <li>
        <p class="Textbody">Strike — ввод зачёркнутого выделения, хоткей Alt+s (от Strike). </p>
      </li>
    </ul>
    <p class="Textbody">Теги для текстовых блоков:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Pre — командные конструкции, скрипты etc., хоткей Alt+p (от Pre); </p>
      </li>
      <li>
        <p class="Textbody">Quote — цитаты, хоткей Alt+c (от Citata); </p>
      </li>
      <li>
        <p class="Textbody">List Or — нумерованный список, хоткей Alt+o (от Ordered); </p>
      </li>
      <li>
        <p class="Textbody">List Un — маркированный список, хоткей Alt+l (от List). </p>
      </li>
    </ul>
    <p class="Textbody">Теги для ссылок:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">URI Link — ссылка внутри сайта, хоткей Alt+u (от URL); </p>
      </li>
      <li>
        <p class="Textbody">URI Remote — ссылка вне сайта, хоткей Alt+r (от Remote); </p>
      </li>
      <li>
        <p class="Textbody">Name Anch — анчор внутри страницы, хоткей Alt+n (от Name); </p>
      </li>
      <li>
        <p class="Textbody">Name URI — ссылка на внутренний анчор, хоткей Alt+a (от Anchor). </p>
      </li>
    </ul>
    <p class="Textbody">Разные прочие теги:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">Doctype — вставка Doctype, "lang=ru-RU", "content=text/html; charset=UTF-8", хоткей Alt+d (от Doctype); </p>
      </li>
      <li>
        <p class="Textbody">Count — подсчёт в выделении количества строк, слов, байт и символов командой wc -lwmc, хоткей Alt+w (от Wc). </p>
      </li>
    </ul>
    <p class="Textbody">А также всё, что потребуется впредь.</p>
    <p class="Textbody">В заключение хотел бы напомнить, что Alt-последовательности для ввода макросов работают только при латинской раскладке клавиатуры. Однако постоянного переключения с кириллицы на латиницу можно избежать, определив одну из «удержальных» клавиш, например, Right Control.</p>
    <h3 id="toc185"><a id="RefHeading18121713816058"></a><a id="bkmRefHeading18121713816058"></a><a id="toc184"></a><a id="bkmtoc184"></a><a id="RefHeading6321136957987"></a><a id="bkmRefHeading6321136957987"></a><a id="bkmRefHeading6321136957987"></a><a id="bkmbkmRefHeading6321136957987"></a>Настройки</h3>
    <p class="Textbody">В KE меются разные режимы выделения текста — всего, последовательными фрагментами, блоками, между парными скобками. И режим множественного выделения, когда выделяются не последовательные фрагменты, а куски из произвольных мест документа. Которые потом можно скопировать и вставить в другой документ — возможность, незаменимая для тех, кому часто приходится составлять компиляцию из разных материалов. И возможность эта если и не уникальна, то встречается не часто. Мне так, например, раньше не встречалась никогда и нигде.</p>
    <p class="Textbody">Функции поиска и замены работают как для отдельных файлов и их выделенных фрагментов, так и для каталогов, а также целых проектов. Кроме того, имеется последовательный наращиваемый поиск, как в браузерах. Результаты поиска, в том числе и последовательного, по умолчанию подсвечиваются в течении заданного в настройках времени, которое может быть изменено в любую сторону. Не запрещается и вообще отключить режим подсветки при поиске.</p>
    <p class="Textbody">В отношении настройки клавиатурных комбинаций для штатных действий KE (не макросов) фантазия применителя ограничивается только объёмом памяти — не компьютерной, а собственной, сколько хоткеев она в состоянии запомнить: как известно, слишком хорошо — это тоже не хорошо. Но одной из возможностей этого круга я воспользовался немедленно.</p>
    <p class="Textbody">Наверное, я далеко не единственный, у кого при быстром лабании по клавишам (а лабать медленно я не умею) часты перестановки соседних символов. В Kate для исправления этого (то есть для транспонирования соседних буковок) существует штатная комбинация — Control+T. Это была та фича, по которой я проливал горючие слёзы, работая в Geany — там возможности траспонирования не имеется. А вот в KE она обнаружилась — и я немедленно присвоил ей ту же последовательность, что и в Kate.</p>
    <p class="Textbody">Особо следует сказать о настройке инструментальной панели. При первом запуске в KE в ней можно видеть пиктограммы для выполнения некоего набора действий, которые разработчики отнесли к числу наиболее частых. Однако мнение применителя на этот счёт может быть более иным. Учитывая это, разработчики предоставили достаточно возможностей для настраивания инструментальной панели. Чтобы ими воспользоваться, достаточно правого клика на панели и выбора пункта Настройка из появившегося контекстного меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_139.png">
        <img alt="Изображение473" class="frameGraphics" id="473graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_139.png" style="border:1.0px solid #000080;padding:0;width:294.83212px;height:364.82898px" />
      </a>
      <a id="a473graphic"></a>
      <a id="bkm473graphic"></a>
    </p>
    <p class="Textbody">Панель настроки инструментов выглядит так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_140.png">
        <img alt="Изображение474" class="frameGraphics" id="474graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_140-381x572.png" style="border:1.0px solid #000080;padding:0;width:382.85733px;height:573.83685px" />
      </a>
      <a id="a474graphic"></a>
      <a id="bkm474graphic"></a>
    </p>
    <p class="Textbody">И говорить зедсь особо нечего — проще показать на скриншотах, как настроил инструменты я. Опять таки не как призыв к обезьяньичанию, просто как пример возможных вариантов. Как нетрудно догадаться, чёрные «галки» — это включённые опции, белые «вороны» — отключённые. Так что поехали по порядку — начиная со Стандартной панели инструментов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_141.png">
        <img alt="Изображение475" class="frameGraphics" id="475graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_141-381x572.png" style="border:1.0px solid #000080;padding:0;width:382.85733px;height:573.83685px" />
      </a>
      <a id="a475graphic"></a>
      <a id="bkm475graphic"></a>
    </p>
    <p class="Textbody">Далее я расправился с остальными панелями:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_142.png">
        <img alt="Изображение476" class="frameGraphics" id="476graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_142-381x572.png" style="border:1.0px solid #000080;padding:0;width:382.85733px;height:573.83685px" />
      </a>
      <a id="a476graphic"></a>
      <a id="bkm476graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_142.png"> </a>
    </p>
    <p class="Textbody">Объяснять, почему я сделал так, а не иначе, полагаю излишним — всё равно каждый применитель перекроит наборы пиктограмм на всех панелях по своему. После чего не лишне будет вернуться к контекстному меню инструментальной панели и включить панель открытия файла</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_143.png">
        <img alt="Изображение477" class="frameGraphics" id="477graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_143.png" style="border:1.0px solid #000080;padding:0;width:294.83212px;height:364.82898px" />
      </a>
      <a id="a477graphic"></a>
      <a id="bkm477graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_143.png"> </a>
    </p>
    <p class="Textbody">Если одноимённая пиктограмма Стандартной панели вызывается стандартное же окно c файловым древом, то здесь появляется выпадающее меню со списком подкаталогов домашнего каталога пользователя, определённого стандартом freedesktop.org: Desktop, Documents, Download и так далее:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_144.png">
        <img alt="Изображение478" class="frameGraphics" id="478graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_144.png" style="border:1.0px solid #000080;padding:0;width:291.8463px;height:217.84314px" />
      </a>
      <a id="a478graphic"></a>
      <a id="bkm478graphic"></a>
    </p>
    <p class="Textbody">После выбора и нажатия на Enter соответствующая ветка появится в левой боковой панели главного окна KE. Впрочем, поскольку в моём домашнем каталоге никаких данных не хранится, для меня это оказалось излишеством.</p>
    <p class="Textbody">После всех показанных манипуляций моя панель инструментов приобрела такой вид:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_145.png">
        <img alt="Изображение479" class="frameGraphics" id="479graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_145-572x58.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:59.858894px" />
      </a>
      <a id="a479graphic"></a>
      <a id="bkm479graphic"></a>
    </p>
    <p class="Textbody">При желании можно включить и подписи к иконкам, однако я полагаю это не нужным: в результате на панели может просто не хватить места:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_146.png">
        <img alt="Изображение480" class="frameGraphics" id="480graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_146-572x71.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:72.82268px" />
      </a>
      <a id="a480graphic"></a>
      <a id="bkm480graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_146.png"> </a>
    </p>
    <p class="Textbody">Тем более что всплывающих при наведении на пиктограмму подсказок даже по первости достаточно, а потом приходит автоматизм.</p>
    <p class="Textbody">В общем, выполнив некоторые настройки (далеко не все возможные), я привёл KE вот к такому виду:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_147.png">
        <img alt="Изображение481" class="frameGraphics" id="481graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_147-572x365.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:366.83212px" />
      </a>
      <a id="a481graphic"></a>
      <a id="bkm481graphic"></a>
    </p>
    <p class="Textbody">В окне редактирования текста в данный момент сочиняется данный очерк. Параллельно с ней открыто несколько файлов из другого проекта. В левом сайдбаре — содержание каталога текущего проекта, ниже — подпанель проектов со списком открытых (текущий выделен полужирным начертанием).</p>
    <p class="Textbody">В правом сайдбаре — список макросов, как шедших в комплекте (секция Samples), так и начало моей коллекции (секция My Macros). Сайдбар этот выведен, потому что я иногда сочиняю или редактирую макросы в ходе работы, по мере того, как ощущаю в них потребность.</p>
    <p class="Textbody">Внизу — окно сообщений, в настоящий момент в нём выведен результат подсчёта символов в текущем документе. Оно приведено тут чисто для демонстрации, в обычном рабочем режиме это окно у меня закрыто. Правый сайдбар я тоже уберу с глаз долой, как только закончу коллекционирование макросов.</p>
    <h3 id="toc186"><a id="RefHeading18141713816058"></a><a id="bkmRefHeading18141713816058"></a><a id="toc185"></a><a id="bkmtoc185"></a><a id="RefHeading6341136957987"></a><a id="bkmRefHeading6341136957987"></a><a id="bkmRefHeading6341136957987"></a><a id="bkmbkmRefHeading6341136957987"></a>Вывод графики</h3>
    <p class="Textbody">И ещё одна особенность обнаруживается у KE — он умеет показывать картинки: достаточно в панели управления файлами щёлкнуть на имени файла изображения — и оно немедленно появится в его главном окне:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_148.png">
        <img alt="Изображение482" class="frameGraphics" id="482graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_148-572x365.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:366.83212px" />
      </a>
      <a id="a482graphic"></a>
      <a id="bkm482graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_148.png"> </a>
    </p>
    <p class="Textbody">А ещё можно потом отправиться в пункт Вид главного меню, и выбрать там Разделённый вид:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_149.png">
        <img alt="Изображение483" class="frameGraphics" id="483graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_149-316x572.png" style="border:1.0px solid #000080;padding:0;width:317.84943px;height:573.83685px" />
      </a>
      <a id="a483graphic"></a>
      <a id="bkm483graphic"></a>
    </p>
    <p class="Textbody">После чего в одной половине окна можно сочинять текст, а в другой — просматривать иллюстрирующие его картинки:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_150.png">
        <img alt="Изображение484" class="frameGraphics" id="484graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_150-572x365.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:366.83212px" />
      </a>
      <a id="a484graphic"></a>
      <a id="bkm484graphic"></a>
    </p>
    <p class="Textbody">Причём картинок можно открыть сколько угодно — каждая будет в отдельной вкладке. И переключаться между ними мне показалось удобней, чем во внешнем графическом браузере типа gThumb'а, да и возможность масштабирования вида имеется — правда, только две градации:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/06-komodo_151.png">
        <img alt="Изображение485" class="frameGraphics" id="485graphic" src="http://alv.me/wp-content/img/im_cin_img/06-komodo_151-572x365.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:366.83212px" />
      </a>
      <a id="a485graphic"></a>
      <a id="bkm485graphic"></a>
    </p>
    <p class="Textbody">В общем, мечта сочинителя повествовательных текстов, особенно линуксописателя, которому постоянно приходится просматривать скриншоты. Не хватает возможности вызова внешнего графического редактора на предмет ресазинга и кадрирования картинок, без этого можно прожить. Да и надо поглядеть, нет ли этой функции среди расширений.</p>
    <h3 id="toc187"><a id="RefHeading18161713816058"></a><a id="bkmRefHeading18161713816058"></a><a id="toc186"></a><a id="bkmtoc186"></a><a id="RefHeading6361136957987"></a><a id="bkmRefHeading6361136957987"></a><a id="bkmRefHeading6361136957987"></a><a id="bkmbkmRefHeading6361136957987"></a>И последнее о Komodo Edit</h3>
    <p class="Textbody">Наговорив столько о достоинствах KE, было бы несправедливо не отметить и недостатки. По большому счёту таковых для меня обнаружилось полтора. Первый — отсутствие встроенного терминала, к которому я привык и в Kate, и в Geany. Впрочем, поскольку я всегда устанавливаю терминал выпадающий, оказалось, что с этим вполне можно примириться, вызывая последний горячей клавишей (по умолчанию F12). Ну а полнедостка — отсутствие подсветки слов с ошибками: как было сказано ранее, считать это однозначно недостатком не очень правильно (с моей точки зрения, разумеется).</p>
    <p class="Textbody">Да, ещё, как говорят, KE показывает себя довольно тормознутым на слабых машинах. В силу того, что у меня слабых машин не водится, я этого не заметил. Но учитывать это наблюдение следует.</p>
    <h2 id="toc188"><a id="RefHeading18181713816058"></a><a id="bkmRefHeading18181713816058"></a><a id="toc187"></a><a id="bkmtoc187"></a><a id="RefHeading12921136957987"></a><a id="bkmRefHeading12921136957987"></a><a id="bkmRefHeading12921136957987"></a><a id="bkmbkmRefHeading12921136957987"></a>Заключение по редакторам</h2>
    <p class="Textbody">Пора подвести итог по текстовым редакторам. Если возможностей Gedit'а для работы с текстами не хватает — и Geany, и Komodo Edit будут более чем достойными ему альтернативами. Какая из них лучше? Однозначного мнения у меня не сложилось. В пользу первой альтернативы — лучшая поддержка спеллинга, более высокое быстродействие на слабых машинах и, главное, наличие встроенного терминала. За KE — более развитые средства управления файлами (в том числе и не только текстовыми) и проектами, в частности — возможность держать параллельно несколько открытых проектов. Ну и практически неограниченные возможности настройки и расширения функционала за счёт собственных макросов нельзя сбрасывать со счёта.</p>
    <p class="Textbody">В результате достоинства KE лично для меня перевесили его недостатки, и в назначил его своим основным инструментом для работы с текстами. Сохранив, однако, тёплые чувства к Geany, много лет прослужившим мне верой и правдой. Почему выше этот редактор и был описан столь подробно — к аналогичному описанию KE я ещё морально не готов.</p>
    <h2 id="toc189"><a id="RefHeading18201713816058"></a><a id="bkmRefHeading18201713816058"></a><a id="toc188"></a><a id="bkmtoc188"></a><a id="RefHeading12941136957987"></a><a id="bkmRefHeading12941136957987"></a><a id="bkmRefHeading12941136957987"></a><a id="bkmbkmRefHeading12941136957987"></a>Графика</h2>
    <p class="Textbody">Сочиняемые тексты нередко принято иллюстрировать. А потому программы для работы с графикой почти так же необходимы, как и текстовый редактор. И программы эти разделяются на три части: средства получения изображений, средства их просмотра и инстументы для редактирования.</p>
    <p class="Textbody">Для большинства из нас, не являющихся художниками и даже рисовальщиками, источниками изображений служат фотографии, сканограммы и скриншоты (если исключить потибренное из Интернета, разумеется). Полученные изображения нуждаются в просмотре, иногда — обработке, а при большом количестве — и в каталогизации.И в Cinnamon-редакции Mint есть штатные средства для всех этих операций, а в репозиториях — и альтернативы им.</p>
    <p class="Textbody">Всё изобилие доступных в Mint графических программ я рассматривать не буду. Так, снимаю я мало и плохо, так что о программах, связанных с фотографией, говорить не буду. Файлов изображений у меня довольно много, однако подавляющее их большинство иллюстрируют тексты, являются частями соответствующих проектов, и потому в средствах каталогизации не нуждаюсь. Ну а про штатно устанавливаемый при стандартной инсталляции GIMP можно говорить или хорошо (то есть много), или ничего. По причине не актуальности для меня этой программы останавливаюсь на втором варианте.</p>
    <p class="Textbody">Так что далее речь пойдёт о средствах сканирования, создания скриншотов, просмотра изображений и инструментах для элементарного редактирования.</p>
    <h3 id="toc190"><a id="RefHeading18221713816058"></a><a id="bkmRefHeading18221713816058"></a><a id="toc189"></a><a id="bkmtoc189"></a><a id="RefHeading6381136957987"></a><a id="bkmRefHeading6381136957987"></a><a id="bkmRefHeading6381136957987"></a><a id="bkmbkmRefHeading6381136957987"></a>Средства сканирования: Simple Scan</h3>
    <p class="Textbody">Когда заходит разговор о сканировании под Linux, в первую очередь вспоминается программа sane и её графический фронт-энд xsane. Однако в Mint ни та, ни другая не устанавливаются по умолчанию, хотя и доступны в репозитории. Вместо этого в секции Графика можно обнаружить пункт Простое сканирование, под которым скрывается программа Simple Scan.</p>
    <p class="Textbody">Simple Scan — самостоятельная программа, а не «морда» для sane, хотя и основана на той же библиотеке libsane, что и последняя. И она действительно оправдывает своё имя — более простой инструмент для сканирования трудно себе представить. При первом запуске она выводит такое вот окно:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_152.png">
        <img alt="Изображение486" class="frameGraphics" id="486graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_152-572x381.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:382.85733px" />
      </a>
      <a id="a486graphic"></a>
      <a id="bkm486graphic"></a>
    </p>
    <p class="Textbody">А также предлагает настроить сканер. Для сканеров и МФУ производства Hewlett-Packard это не доставляет никаких проблем — при установленной системе HPLIP (HP Linux Imaging and Printing), которая в Mint имеется по умолчанию: нужно просто соглашаться со всем, что она предложит. После чего в панели настроек (вызываемой через меню Документ -&gt; Параметры) обнаруживается соответствующее устройство. Вмоём случае это МФУ HP Deskjet 2050:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_153.png">
        <img alt="Изображение487" class="frameGraphics" id="487graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_153.png" style="border:1.0px solid #000080;padding:0;width:522.8511px;height:444.84158px" />
      </a>
      <a id="a487graphic"></a>
      <a id="bkm487graphic"></a>
    </p>
    <p class="Textbody">В этой же панели можно поменять и некоторые другие параметры, например, разрешение сканирования текста и фоток — у меня от 75 dpi до 1200 (физических) и 2400 (интерполированных):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_154.png">
        <img alt="Изображение488" class="frameGraphics" id="488graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_154.png" style="border:1.0px solid #000080;padding:0;width:522.8511px;height:444.84158px" />
      </a>
      <a id="a488graphic"></a>
      <a id="bkm488graphic"></a>
    </p>
    <p class="Textbody">Впрочем, я оставил все параметры по умолчанию.</p>
    <p class="Textbody">Правда, повторяю, всё это относится к устройствам от HP — как обстоит дело со сканерами и МФУ более иных производителей, просто не знаю.</p>
    <p class="Textbody">Теперь можно начинать сканирование, для чего достаточно нажать кнопку с соответствующей надписью. Процесс сканирования отображается на экране:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_155.png">
        <img alt="Изображение489" class="frameGraphics" id="489graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_155-572x381.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:382.85733px" />
      </a>
      <a id="a489graphic"></a>
      <a id="bkm489graphic"></a>
    </p>
    <p class="Textbody">По завершении сканирования результат выводится в виде полной страницы. Разумеется, это дело надо сохранить. Но прежде изображение можно подкорректировать — в приведённом примере повернуть по часокй стрелке на 180°, а также обрезать лишнее через меню Страница -&gt; Обрезать -&gt; Другое:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_156.png">
        <img alt="Изображение490" class="frameGraphics" id="490graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_156.png" style="border:1.0px solid #000080;padding:0;width:507.8463px;height:38.844723px" />
      </a>
      <a id="a490graphic"></a>
      <a id="bkm490graphic"></a>
    </p>
    <p class="Textbody">Что делается просто подгонкой рамки:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_157.png">
        <img alt="Изображение491" class="frameGraphics" id="491graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_157-572x381.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:382.85733px" />
      </a>
      <a id="a491graphic"></a>
      <a id="bkm491graphic"></a>
    </p>
    <p class="Textbody">Теперь после сохранения картинка приобретёт следующий вид:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_158.png">
        <img alt="Изображение492" class="frameGraphics" id="492graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_158-376x572.png" style="border:1.0px solid #000080;padding:0;width:377.83057px;height:38.844723px" />
      </a>
      <a id="a492graphic"></a>
      <a id="bkm492graphic"></a>
    </p>
    <p class="Textbody">Если теперь остканировать другие изображения — они получат то же имя, но с добавлением порядкового номера.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_159.png">
        <img alt="Изображение493" class="frameGraphics" id="493graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_159-572x381.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:382.85733px" />
      </a>
      <a id="a493graphic"></a>
      <a id="bkm493graphic"></a>
    </p>
    <p class="Textbody">Вот и всё. К сказанному остаётся добавить, что программа Simple Scan была написана специально для Ubuntu Робертом Анселлом (Robert Ancell), а список переводчиков интерйса на русский язык насчитывает немало имён:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_160.png">
        <img alt="Изображение494" class="frameGraphics" id="494graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_160.png" style="border:1.0px solid #000080;padding:0;width:541.8243px;height:359.84px" />
      </a>
      <a id="a494graphic"></a>
      <a id="bkm494graphic"></a>
    </p>
    <p class="Textbody">И в настоящее время программа эта включается в штатный состав большинства популярных дистрибутивов.</p>
    <h3 id="toc191"><a id="RefHeading18241713816058"></a><a id="bkmRefHeading18241713816058"></a><a id="toc190"></a><a id="bkmtoc190"></a><a id="RefHeading6401136957987"></a><a id="bkmRefHeading6401136957987"></a><a id="bkmRefHeading6401136957987"></a><a id="bkmbkmRefHeading6401136957987"></a>Создание экранных снимков</h3>
    <p class="Textbody">Поскольку каждому практикующему линуксописателя делать экранные снимки подчас приходится в массовых количествах (десятками, а иногда и сотнями), то к скриншоттеру предъявляются довольно жёсткие требования не только в плане функциональности, но и в отношении удобства.</p>
    <h4 id="toc192"><a id="RefHeading18261713816058"></a><a id="bkmRefHeading18261713816058"></a><a id="toc191"></a><a id="bkmtoc191"></a><a id="RefHeading6421136957987"></a><a id="bkmRefHeading6421136957987"></a><a id="bkmRefHeading6421136957987"></a><a id="bkmbkmRefHeading6421136957987"></a>Вступление</h4>
    <p class="Textbody">С функциональностью всё понятно: скриншоттер должен позволять делать снимки «фиксированных» элементов — всего экрана, отдельного окна, произвольной области экрана или окна. Причём как мгновенно, так и с задержкой, и время её должно поддаваться изменению. Почему? Да потому, что часто важно «снять» элементы динамические — всплывающие подсказки, выпадающие и контекстные меню, или отдельные их фрагменты. Так что надо иметь запас времени, дабы докопаться до нужного элемента многоуровневого меню, и время это в разных случаях разное. Очень существенно также иметь возможность назначить «снимаемый» элемент по умолчанию — и в большинстве случаев это бывает активное окно.</p>
    <p class="Textbody">Что же касается удобства — то это в первую очередь условия сохранения получаемых файлов изображений. То есть должна быть лёгкая возможность изменения целевого каталога для файлов экранных снимков, например path2/article_name/. И, безусловно, возможность логичного автоматического именования скриншотов, типа: article_name01_001.png и так далее. Не худо иметь и возможность хотя бы простенького управления созданными файлами — как минимум, переименования и удаления.</p>
    <p class="Textbody">Функции удобного просмотра изображений и их простого редактирования (кадрирование, изменение размера, конвертации в другие форматы) также не лишние, но не обязательны. Кстати, из форматов файлов, как мне кажется, актуально полтора: упомянутый png и, изредка, jpeg. Форматы типа bmp полагаю атавизмом, а необходимость в tiff'е отпала с тех пор, как «бумажные» редакции стали спокойно принимать png.</p>
    <p class="Textbody">Так вот, исходя из сформулированных требований (моих, разумеется, все от них отличные — не правильны), на протяжении многих лет лучным скриншоттером я считал штатный Ksnapshot из KDE. И, если говорить именно о программах, входящих в комплект таких десктопов, как GNOME и Xfce, то мнения своего я не изменил: ни gnome-screensot, ни xfce-screenshot до него не дотягивают по всем параметрам.</p>
    <p class="Textbody">Однако в Cinnamon-редакции Mint ни малейшего Ksnapshot'а штатно, разумеется, нет, а доустанавливать его не имеет смысла — тогда уж проще переходить на KDE-редакцию. Так что и тут нужно искать альтернативу — не делать же скриншоты, с помощью GIMP'а. С другой стороны, предлагаемые от безрыбья консольные инструменты типа scrot или fbshot — это уже другая крайность.</p>
    <h4 id="toc193"><a id="RefHeading18281713816058"></a><a id="bkmRefHeading18281713816058"></a><a id="toc192"></a><a id="bkmtoc192"></a><a id="RefHeading6441136957987"></a><a id="bkmRefHeading6441136957987"></a><a id="bkmRefHeading6441136957987"></a><a id="bkmbkmRefHeading6441136957987"></a>GNOME Screenshot</h4>
    <p class="Textbody">Однако, прежде чем заниматься поисками внештатных альтернатив, кратко рассмотрим возможности штатного GNOME Screenshot'а — ведь на первых порах приходится прибегать к его помощи. Ибо, как известно, на первоначальном бесптичье и место пониже спины — соловей.</p>
    <p class="Textbody">Запустить gnome-screensot можно из секции меню Стандартные — он называется там Снимок экрана. Хотя можно обойтись и без меню: по умолчанию gnome-screensot запускается горячими клавишами — PrintScreen (снимок всего экрана), Alt+PrintScreen (снимок активного окна) или Shift+PrintScreen (снимок выделенной области).</p>
    <p class="Textbody">Однако это не очень удобно: во всех трёх случаях по умолчанию скриншоты норовят записаться в каталог $HOME/Pictures, а если изменить путь к целевому каталогу вручную, то при следующем запуске скриншоттера горячими клавишами всё равно восстановится умолчальный путь.</p>
    <p class="Textbody">Кроме того, при запуске через пиктограмму на панели задач, кроме снимка всего экрана, активного окна и выделенной области можно просто запустить программу в, так сказать, «общем виде»:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_161.png">
        <img alt="Изображение495" class="frameGraphics" id="495graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_161.png" style="border:1.0px solid #000080;padding:0;width:479.84px;height:279.82742px" />
      </a>
      <a id="a495graphic"></a>
      <a id="bkm495graphic"></a>
    </p>
    <p class="Textbody">Обратите внимание на последний скриншот: на нём по умолчанию отмечена опция Захватить весь экран. И если для текущего снимка изменить её на любую из двух других — при следующей запуске она вернётся в качестве отмеченной по умолчанию. Эта мелочь страшно раздражает: ведь обычно нужно снимать не экран, а одно из окон, реже — выделенную область, но сделать любую из этих опций умолчальной не получится. Второй раздражающий фактор — неудобство изменения целевого каталога. Ну а уж про именование файлов по типу Снимок экрана от 2013-07-23 22:57:04.png и говорить нечего. Оказалось, что практически в моих целях gnome-screensot можно использовать только в паре с какой-либо утилитой массового переименования. Благо в Mint я такую откопал в лице gprename, но это тема другого очерка.</p>
    <p class="Textbody">В общем, поразвлекавшись с gnome-screensot некоторое время и изрядно оживив в памяти свой запас тюркской обсценной лексики, я решил поискать что-нибудь более приличное среди приложений, оставшихся за кадром штатной инсталляции Ubuntu. И, разумеется, как всякий ищущий да обрёл таковое — программу Shutter, о которой речь пойдёт в следующем миниочерке.</p>
    <h3 id="toc194"><a id="RefHeading18301713816058"></a><a id="bkmRefHeading18301713816058"></a><a id="toc193"></a><a id="bkmtoc193"></a><a id="RefHeading6461136957987"></a><a id="bkmRefHeading6461136957987"></a><a id="bkmRefHeading6461136957987"></a><a id="bkmbkmRefHeading6461136957987"></a>Shutter</h3>
    <p class="Textbody">Программа Shutter имеется в официальном репозитории Mint (точнее, конечно же, Ubuntu), так что доступна для установки любым стандарным методом — от</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install shutter</span> </p>
    <p class="Textbody">до Synaptic'а и Менеджера программ.</p>
    <p class="Textbody">Описание Shutter'а, выдаваемое командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt show shutter</span> </p>
    <p class="Textbody">смотрится весьма впечатляюще:</p>
    <p class="Textbody">Многофункциональная программа, позволяющая делать ... скриншоты окна, части эрана, всего экрана, или даже веб-сайта, потом добавлять к нему различные эффекты, рисовать на нём, и в конце загрузить его на интернет-хостинг изображений. И всё это...</p>
    <p class="Textbody">... конечно, очень благородно, но как в нём на счёт <span style="text-decoration:line-through">баб</span> соответствия сформулированным ранее требованиям линуксописателя? То есть критериям функциональности и удобства. Начнём с функциональности.</p>
    <p class="Textbody">После первого запуска (из секции Стандартные главного меню) появляется примерно такое окно — снимок текущего рабочего стола при этом по умолчанию делается автоматически:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_162.png">
        <img alt="Изображение496" class="frameGraphics" id="496graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_162-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a496graphic"></a>
      <a id="bkm496graphic"></a>
    </p>
    <p class="Textbody">Доступ к основным функциям программы можно получить через строку пиктограмм в верхней части окна:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_163.png">
        <img alt="Изображение497" class="frameGraphics" id="497graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_163-572x46.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:47.84px" />
      </a>
      <a id="a497graphic"></a>
      <a id="bkm497graphic"></a>
    </p>
    <p class="Textbody">Или же сделать это через главное меню — через пункты Файл -&gt; Создать -&gt; [нужный объект]:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_164.png">
        <img alt="Изображение498" class="frameGraphics" id="498graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_164-572x312.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:313.84314px" />
      </a>
      <a id="a498graphic"></a>
      <a id="bkm498graphic"></a>
    </p>
    <p class="Textbody">Пиктограммы панели Shutter'а следующие (слева направо):</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">повторение последнего снимка — понятно без комментариев; </p>
      </li>
      <li>
        <p class="Textbody">выделение мышью прямоугольной области экрана для снимка; щёлкнув на стрелке рядом, можно выбрать инструмент выбора — простой или усоврешенствованный (по умолчанию); отличие второго в том, что он позволяет масштабировать выбеленный участок перед созданием скриншота; </p>
      </li>
      <li>
        <p class="Textbody">рабочий стол — с её помощью можно снять не только текущий, но и любой другой из наличных виртуальных десктопов, и даже все сразу в виде одного скриншота; </p>
      </li>
      <li>
        <p class="Textbody">окно — снимается активное или любое из открытых, по выбору (в том числе и из свёрнутых); </p>
      </li>
      <li>
        <p class="Textbody">снимок отдельного элемента окна, к сожалению (у меня?) не работает, выдавая или сообщение об ошибке, или снимая выбранное окно целиком; </p>
      </li>
      <li>
        <p class="Textbody">зато выбор меню в приложении работает превосходно, позволяя сделать снимок выпадающего или контекстного меню любой степени вложенности; </p>
      </li>
      <li>
        <p class="Textbody">столь же неизменно превосходный результат даёт и захват всплывающих подсказок; при этом (как и при снимках меню) даётся время для выбора — по умолчанию 10 секунд. </p>
      </li>
    </ul>
    <p class="Textbody">Подчеркну одно из главных (с моей точки зрения) достоинств программы: с помощью её можно делать снимки любых меню и подсказок без всяких дополнительных ухищрений, типа расчёта времени на щёлканье мышью, съёмки всего экрана и последующего выпиливания из него нужных элементов.</p>
    <p class="Textbody">Таинственная кнопка, требующая установки gnome-web-photo, у меня не активизирована (за отсутствием последнего). А пиктограммы Правка и Экспорт предоставляют те самые супер-функции Shutter'а, о которых упоминалось в описании — встроенный редактор изображений и средства помещёния их на соответствующие серверы. Правда, доступ к встроенному редактору требует установки пакета libgoo-canvas-perl, который в стандартной инсталляции Mint отсуствует. Что, однако легко поправимо:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install libgoo-canvas-perl</span> </p>
    <p class="Textbody">Основные функции, доступные через меню — практически те же самые. Добавлю только, что у Shutter'а есть ещё и функция вьювера изображений, доступная через меню: Переход -&gt; Вперёд/Назад/В начало/В конец. А если в меню Вид включить пункт Показать панель навигации, то перемещаться между изображениями можно с помощью стрелок, которые появятся в нижней части окна программы.</p>
    <p class="Textbody">Таким образом, даже беглое рассмотрение возможностей Shutter'а свидетельствует, что его характеристика в описании ничуть не преувеличена: эта программа действительно может «заскриншотить» практически всё. Остаётся посмотреть только, насколько удобно с этим «заскриншоченым» хозяйством управляться.</p>
    <p class="Textbody">Чтобы оценить меру удобства Shutter'а при его практическом использовании, надо обратиться к настройкам этой программы. Каковые, как это в обычае для Gtk-приложений, находятся в главном меню через пункты Правка -&gt; Параметры и выглядт следующим образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_165.png">
        <img alt="Изображение499" class="frameGraphics" id="499graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_165-572x503.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:504.8227px" />
      </a>
      <a id="a499graphic"></a>
      <a id="bkm499graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_165.png"> </a>
    </p>
    <p class="Textbody">Можно видеть, что окно настроек включает ряд вкладок, из которых я в рамках сегодняшней темы остановлюсь лишь на некоторых. Начав, естественно, с Главной.</p>
    <p class="Textbody">Говорить о степени сжатия или поддерживаемых форматах особо нечего — это и так все знают. Замечу только, что, кроме умолчального png, в принципе скриншоты можно снимать в иногда нужном для размещёния в web'е jpeg'е и даже в реликтовом bmp — для совместимости с допотопными редакторами.</p>
    <p class="Textbody">А вот настройки условий сохранения очень важны для линуксописателя (да и вообще для писателя, иллюстрирующего свои тексты картинками). По умолчанию включено автоматическое сохранение скриншотов в каталоге $HOME/Pictures, а имена их файлов генерируются по схеме name_номер. Где в качестве переменной name фигурирует заголовок окна (если делается снимок окна), слова меню, рабочий стол и так далее (при выборе соответствующих объектов съёмки).</p>
    <p class="Textbody">Всё это при практическом сочинительстве очень неудобно. Поэтому имеет смысл включить опцию Каждый раз спрашивать, куда сохранять, а целевой каталог по умолчанию и систему именования файлов установить в соответствие со своими свычаями и обычаями — у всех практикующих линуксописателей они разные, да и зависят от обстоятельств.</p>
    <p class="Textbody">Автоматическое копирование снимка или имени его файла включаются по желанию и потребностям, как и захват курсора (последнее в некоторых случаях нужно, но обычно мешает). Задержка перед съёмкой относится к «скриншотированию» окон и рабочих столов, и в данном случае обычно не нужна. А когда нужна — об этом на следующей вкладке, каковая называется Дополнительной и выглядит так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_166.png">
        <img alt="Изображение500" class="frameGraphics" id="500graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_166-572x503.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:504.8227px" />
      </a>
      <a id="a500graphic"></a>
      <a id="bkm500graphic"></a>
    </p>
    <p class="Textbody">Где как раз и выставляет время задержки перед съёмкой меню и всплывающих подсказок, в зависимости от количества подготовительных действий и быстроты реакции. Прочие же опции здесь определяются вкусом и ситуацией. Что, впрочем, относится и к остальным вкладкам.</p>
    <p class="Textbody">Теперь бросим взгляд на встроенный графический редактор Shutter' — для запуска его на предмет редактирования текущего файла надо нажать кнопку Правка — напомню, что она активизируется только после установки пакета libgoo-canvas-perl.</p>
    <p class="Textbody">В качестве примера откроем его во встроенном редакторе один из ранее приведённых скриншотов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_168.png">
        <img alt="Изображение501" class="frameGraphics" id="501graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_168-572x327.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:328.84787px" />
      </a>
      <a id="a501graphic"></a>
      <a id="bkm501graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_168.png"> </a>
    </p>
    <p class="Textbody">Изображение можно откадрировать, убрать надпись и так далее — в результате образуется нечто вроде этого:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_169.png">
        <img alt="Изображение502" class="frameGraphics" id="502graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_169-572x327.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:328.84787px" />
      </a>
      <a id="a502graphic"></a>
      <a id="bkm502graphic"></a>
    </p>
    <p class="Textbody">Очень полезным оказывается встроенный редактор Shutter'а для добавления на скриншоты акцентирующих элементов и подписей, например, вот так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_170.png">
        <img alt="Изображение503" class="frameGraphics" id="503graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_170-572x165.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:166.85733px" />
      </a>
      <a id="a503graphic"></a>
      <a id="bkm503graphic"></a>
    </p>
    <p class="Textbody">По завершении редактирования файл можно сохранить под тем же именем. Прямого сохранения с переименованием (то есть Save as...) не предусмотрено. Однако это можно заменить экспортом в тот же формат под другим именем:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_171.png">
        <img alt="Изображение504" class="frameGraphics" id="504graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_171-572x321.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:322.8384px" />
      </a>
      <a id="a504graphic"></a>
      <a id="bkm504graphic"></a>
    </p>
    <p class="Textbody">С остальными функциями встроенного редактора предоставляю разбираться читателям.</p>
    <h3 id="toc195"><a id="RefHeading18321713816058"></a><a id="bkmRefHeading18321713816058"></a><a id="toc194"></a><a id="bkmtoc194"></a><a id="RefHeading6481136957987"></a><a id="bkmRefHeading6481136957987"></a><a id="bkmRefHeading6481136957987"></a><a id="bkmbkmRefHeading6481136957987"></a>Вьюверы изображений</h3>
    <p class="Textbody">Изображения, полученные любым из перечисленных способов, необходимо просматривать, а иногда и подвергать некоторому редактированию. С первой задачей прекрасно справляется штатный вьюевер изображений, известный как Eye of GNOME (или, сокращённо, eog) — в секции Графика главного меню Cinnamon он скрывается под псевдонимом просмотр изображений.</p>
    <p class="Textbody">Однако обычно Eog вызывается из файлового менеджера щелчком на имени графического файла известного ему формата — а ему известны практически все растровые форматы. После чего он предстаёт примерно в таком виде:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_172.png">
        <img alt="Изображение505" class="frameGraphics" id="505graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_172-572x480.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:481.84317px" />
      </a>
      <a id="a505graphic"></a>
      <a id="bkm505graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_172.png"> </a>
    </p>
    <p class="Textbody">Если в текущем каталоге имеется более одного графического файла — их можно просматривать, щёлкая по пиктограммам со стрелками Далее и Назад.</p>
    <p class="Textbody">Через меню Вид можно включить Галерею изображений и Боковую панель.</p>
    <p class="Textbody">В первой — миниатюры картинок, находящихся в текущем каталоге, во второй — подробная информация о выведенном в данный момент файле:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_174.png">
        <img alt="Изображение506" class="frameGraphics" id="506graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_174-572x413.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:414.83212px" />
      </a>
      <a id="a507graphic"></a>
      <a id="bkm507graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_174.png"> </a>
    </p>
    <p class="Textbody">Над просматриваемыми файлами можно произвести некоторые действия, типа вращения и отражения:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_175.png">
        <img alt="Изображение507" class="frameGraphics" id="507graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_175.png" style="border:1.0px solid #000080;padding:0;width:442.83844px;height:361.84317px" />
      </a>
      <a id="a508graphic"></a>
      <a id="bkm508graphic"></a>
    </p>
    <p class="Textbody">Более сложные манипуляции с файлами можно выполнить в программе gThumb, которая также входит в стандартную инсталляцию Cinnamon-редакции дистрибутива Mint. Это также по преимуществу вьювер изображений, наделённый, однако, функциями лёгкого растрового редактора. Он вызывается следующими способами:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">из главного меню — где он под собственным именем обнаруживается в секции Графика; </p>
      </li>
      <li>
        <p class="Textbody">из контекстного меню Nemo через пункт Open with; </p>
      </li>
      <li>
        <p class="Textbody">из контекстного меню Shutter'а и Eog'а — через пункты Открыть в и Открыть с помощью, соответственно. </p>
      </li>
    </ul>
    <p class="Textbody">Про банальный вызов этой программы из командной строки терминала или минитерминала я уж и не говорю.</p>
    <p class="Textbody">В любом случае после запуска gThumb будет выглядеть примерно так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_176.png">
        <img alt="Изображение508" class="frameGraphics" id="508graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_176-572x420.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:421.82425px" />
      </a>
      <a id="a509graphic"></a>
      <a id="bkm509graphic"></a>
    </p>
    <p class="Textbody">На скриншоте можно видеть боковую панель, именуемую Свойства, и Панель миниатюр — и ту, и другую можно отключить через меню Вид.</p>
    <p class="Textbody">Думаю, вопроса, как с помощь gThumb просматривать изображения, ни у кого не возникнет. Однако главная сила этой программы в другом. Если щёлкнуть по изображению палитры в право верхнем углу, в боковой панели вместо информации об изображении появятся инструменты для его редактирования:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_178.png">
        <img alt="Изображение509" class="frameGraphics" id="509graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_178-572x420.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:421.82425px" />
      </a>
      <a id="a511graphic"></a>
      <a id="bkm511graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_178.png"> </a>
    </p>
    <p class="Textbody">Как этими инструментами пользоваться — понятно без комментариев. Так что просто проиллюстрирую две наиболее востребованные (по крайней мере, мной) операции — Изменение размера</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_179.png">
        <img alt="Изображение510" class="frameGraphics" id="510graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_179-572x435.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:436.829px" />
      </a>
      <a id="a512graphic"></a>
      <a id="bkm512graphic"></a>
    </p>
    <p class="Textbody">и Кадрирование:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_180.png">
        <img alt="Изображение511" class="frameGraphics" id="511graphic" src="http://alv.me/wp-content/img/im_cin_img/07-graphic_180-572x435.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:436.829px" />
      </a>
      <a id="a513graphic"></a>
      <a id="bkm513graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/07-graphic_180.png"> </a>
    </p>
    <p class="Textbody">К этим скриншотам можно только добавить, что, если численно задать размеры изображения и положение его левого верхнего угла, они сохранятся в течении всего сеанса (если их не поменять снова). То есть gThumb способен к обработке большого количества однотипных файлов почти в пакетном режиме.</p>
    <h2 id="toc196"><a id="RefHeading18341713816058"></a><a id="bkmRefHeading18341713816058"></a><a id="toc195"></a><a id="bkmtoc195"></a><a id="RefHeading12961136957987"></a><a id="bkmRefHeading12961136957987"></a><a id="bkmRefHeading12961136957987"></a><a id="bkmbkmRefHeading12961136957987"></a>Офисные приложения</h2>
    <p class="Textbody">Когда речь заходит об открытых и свободных офисных пакетах, вспоминают, как правило, LibreOffice и Apache OpenOffice.org, реже — вечный долгострой проекта KDE, KOffice, ныне перевоплотившийся в Calligra. И мало кто упомянет в этой связи компоненты так называемого GNOME Office — текстовый процессор Abiword и табличный процессор Gnumeric.</p>
    <h3 id="toc197"><a id="RefHeading18361713816058"></a><a id="bkmRefHeading18361713816058"></a><a id="toc196"></a><a id="bkmtoc196"></a><a id="RefHeading6501136957987"></a><a id="bkmRefHeading6501136957987"></a><a id="bkmRefHeading6501136957987"></a><a id="bkmbkmRefHeading6501136957987"></a>Вступление</h3>
    <p class="Textbody">Во всех редакциях дистрибутива Mint (как, впрочем, и в подавляющем большинстве «больших» дистрибутивов) в роли офисного пакета выступает LibreOffice в полной комплектации. Однако многим применителям, включая автора этих строк, из всего офисного богачества требуются только текстовый процессор (точнее, word processor, ибо text processor — это неинтерактивные программы типа groff) и процессор табличный (он же — электронная таблица).</p>
    <p class="Textbody">Можно, конечно, поудалять лишние компоненты полного LibreOffice. А можно сразу обратиться к офису «незнаменитому» — Abiword и Gnumeric, которые подчас вполне искусственно объединяются в пакет GNOME Office. Искусственно — потому что обе эти программы вполне самостоятельны, и к среде GNOME относятся постольку, поскольку используются и в ней тоже.</p>
    <p class="Textbody">Самостоятельность Abiword и Gnumeric нисколько не умаляет их достоинств. Каковыми считаются лёгкость, быстродействие, простота освоения и применения. Но при этом забывают о функциональности — а ведь каждая из этих программ обладает своими уникальными особенностями.</p>
    <p class="Textbody">Для Abiword'а это средства коллективной работы. Во-первых, он поддерживает мультиверсионные документы — в том числе и те, что были сделаны таковыми в MS Word. Во-вторых и главных, Abiword располагает инструментами удалённого редактирования, по собственному протоколу AbiCollab.net, прямому подключению TCP и, наконец, по протоколу XMPP — то есть через самый обычный Jabber-клиент.</p>
    <p class="Textbody">Ну а «фирменные фичи» Gnumeric'а — это изобилие статистических и инженерных функций (более ста из которых уникальны) и широчайшие возможности для построения технических диаграмм и графиков.</p>
    <p class="Textbody">И Abiword, и Gnumeric включены в официальный репозиторий Mint. Там же можно найти и плагины к ним — для первой программы это abiword-plugin-grammar и abiword-plugin-mathview, для второй gnumeric-plugins-extra. И всё это вместе установить любым из стандартных способов, проще всего — комнадой apt с указанием всех перечисленных пакетов. После чего можно приступать к их использованию.</p>
    <h3 id="toc198"><a id="RefHeading18381713816058"></a><a id="bkmRefHeading18381713816058"></a><a id="toc197"></a><a id="bkmtoc197"></a><a id="RefHeading6521136957987"></a><a id="bkmRefHeading6521136957987"></a><a id="bkmRefHeading6521136957987"></a><a id="bkmbkmRefHeading6521136957987"></a>Abiword</h3>
    <p class="Textbody">Рискну предположить, что очень многие применители Linux используют текстовые процессоры с одной-единственной целью — обмениваться документами с пользователями Windows, часто не подозревающими о существовании иных форматов, кроме MS Word. Ну и, возможно, для эпизодического составления документов собственных — тех, которые требуют того или иного стандартного форматирования (например, докладных записок). Такие пользователи, как правило, не нуждаются ни в красивых презентациях, ни в финансовых или инженерных функциях, ни в связи с базами данных, предлагаемых им соответствующими компонентами интегрированных офисных пакетов. Более того, не нужно им и все изобилие функций собственно текстовых процессоров из тех же пакетов. И вот им-то самое время вспомнить о существовании AbiWord.</p>
    <p class="Textbody">Название этой программы происходит от испанского слова «Abierto» (открытый) и вездесущего компонента Word. Она начала разрабатываться в 1998 году вполне коммерческой компанией SourceGear как часть AbiSuite — кросс-платформенного офисного пакета, в который предполагалось включить только открытые компоненты. В дальнейшем интересы компании сместились в другие сферы, и разработка AbiSuite была заброшена. Но дело развития AbiWord взяла в свои руки группа добровольцев, которые продолжают его и поныне. На рубеже тысячелетий проект GNOME включил эту программу как текстовый процессор своего GNOME Office, но сам по себе AbiWord возник и развивается независимо от последнего, как кросс-платформенное приложение (помимо сборок для всех полнофункциональных дистрибутивов Linux и портов для BSD-систем, существует также Windows-сборка пакета, доступная в качестве самораспаковывающегося архива, не требующего никаких дополнительных компонентов).</p>
    <p class="Textbody">Собственно, AbiWord объединяет с GNOME Office только одно — использование Gtk в качестве базовой библиотеки. Правда, как правило, AbiWord собирается майнтайнерами дистрибутивов с поддержкой библиотек GNOME, и дистрибутив Mint тут не составляет исключения, но в принципе это отнюдь не обязательно. Степень интеграции Aboword в виртуальный пакет GNOME Office практически нулевая, и от его пользователя не потребуют принудительной установки остальных компонентов последнего. Хотя Gnumeric, электронная таблица из этого офисного пакета, также является штатным компонентом стандартной редакции дистрибутива Mint.</p>
    <p class="Textbody">Традиционно Abiword представляется разработчиками и обозревателями как быстрый и легкий, но при этом полнофункциональный текстовый процессор WYSIWYG-типа, а некоторые добавляют к этому ещё и определение «элегантный». И почти со всеми этими эпитетами можно согласиться. Предметом спора может быть, разве что, определение полнофункциональности — тут у каждого пользователя свои представления, ничуть не более объективные, нежели понятия об элегантности.</p>
    <p class="Textbody">Во-первых, AbiWord действительно быстр и лёгок — запускается в «голом» виде он практически мгновенно, запуск вместе с открытием небольших файлов в формате что в собственном формате doc и odt тоже происходит очень быстро, хотя с большими документами он работает несколько медленнее. А его исполняемый файл имеет объём шесть с половиной мегабайт, занимая в памяти на порядок меньше места, чем OpenWriter.</p>
    <p class="Textbody">В-вторых, AbiWord, при всей своей легкости обладает большинством атрибутов развитого текстового процессора: поддержкой шаблонов, стилей, настраиваемых пользователем, таблиц, проверки орфографии, вывода статистики, возможностью вставки специальных символов и так далее. Не так давно он приобрел способность корректно работать с мультиверсионными документами, причём не только собственными или соответствующими стандарту ODT, но и созданными в формате MS Word. А в последней версии AbiWord'а появилась интеграция с системами онлайнового перевода, поисковой машиной Google и даже Википедией, . Дополнительные функции реализованы в виде подключаемых внешних модулей, работающих через web-интерфейс браузера, умолчального для данной системы, и потому не утяжеляют саму программу.</p>
    <p class="Textbody">В-третьих, несмотря на функциональность программы, интерфейс её сохраняет простоту и не выглядит тяжеловесным и перегруженным. Количество инструментальных панелей ограничено разумным числом (их четыре, по умолчанию выводится только две — стандартная и форматирования), никаких дополнительных, принудительно всплывающих панелей не наблюдается. Наборы инструментов на панелях по умолчанию не редактируемы, но все не охваченными ими действия возможны через пункты главного меню. Контекстное меню, традиционно вызываемое щелчком правой клавиши мыши, также содержит лишь пункты для базовых действий плюс вызов внешних модулей (перевода, словарей, поиска).</p>
    <p class="Textbody">Всё это вместе действительно создаёт впечатление элегантности, возникающее при первом же запуске программы. Давать подробное описание её возможностей и приёмов использования в рамках настоящего очерка я не буду. А вместо этого остановлюсь на некоторых его особенностях и ограничениях программы, после чего изложу личные впечатления от её практического использования. Думается, что этого будет достаточно пользователям для того, чтобы решить, подходит ли Abiword именно им.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/08-office_181.png">
        <img alt="Изображение512" class="frameGraphics" id="512graphic" src="http://alv.me/wp-content/img/im_cin_img/08-office_181-572x445.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:446.84473px" />
      </a>
      <a id="a514graphic"></a>
      <a id="bkm514graphic"></a>
    </p>
    <p class="Textbody">Итак, одно из главных требований к текстовому процессору для Linux — это совместимость (в первую очередь — сами знаете с кем). До недавнего времени поддержка документов MS Word в AbiWord'е была реализована... скажем так, не лучшим образом: при считывании doc-файлов подчас терялось сложное форматирование, пропадало стилевое оформление, категорически не воспринималась мультиверсионность — словом, происходили разного рода неприятности. Они стали исчезать уже в прошлой версии, а ныне их можно считать окончательно изжитыми. Следует ещё раз подчеркнуть упомянутую выше корректность работы с мультиверсионными документами.</p>
    <p class="Textbody">Не менее важным с точки зрения совместимости является обращение текстового процессора с документами HTML-формата. И тут Abiword'у есть чем похвастаться перед более «толстыми» собратьями: долгое время он был единственным текстовым процессором, корректно считывающим русскоязычные html-документы без определения DOCTYPE и метатега charset. То есть тех фрагментов между открывающим и закрывающим тэгами body, которые создаются при использовании различных CMS и прочих автоматизированных web-редакторов.</p>
    <p class="Textbody">Отличается Abiword и по части экспорта документов в html-формат. Всякий, видевший результаты этого процесса для LibreOffice Writer и OpenWriter, не мог не повторить известную сентенцию: «Если это html, то дайте мне, пожалуйста, plain text». Abiword же при записи в данный формат на выходе даёт вполне чистый html-код с минимальной отсебятиной.</p>
    <p class="Textbody">Раз уж речь зашла об экспорте, надо остановиться на таком моменте. При экспорте через пункты меню <span style="font-weight:bold">Файл</span> -&gt; <span style="font-weight:bold">Сохранить как...</span> по умолчанию задаётся экспортируемый формат Abiword (*.abw, *.zabw, *.abw.gz), никем, кажется, более не понимаемый. И, чтобы указать нужный, приходится долго пролистывать длинный выпадающий список доступных форматов, в том числе весьма экзотических, что несколько раздражает.</p>
    <p class="Textbody">Очень важная функция любого текстового процессора — встроенная проверка орфографии, в том числе «на лету»: для многих пользователей подчеркивание неправильно написанных слов является главным стимулом к использованию текстового процессора для составления оригинальных документов. Ранее Abiword в отношении проверки русского правописания наблюдалась напряжёнка — но текущем состоянии он проверка орфографии работает безукоризненно как в автоматическом, так и ручном режимах.</p>
    <p class="Textbody">Теперь об ограничениях программы. Главное из них — весьма скудные возможности её настройки. Они выполняются в пункте меню Правка -&gt; Параметры… и сводятся к включению возможности переопределения наборов пиктограмм на инструментальных панелях (как я уже говорил, по умолчанию она отключена), выбору единиц измерения, направления текста (Abiword — программа интернациональная, и её разработчики подумали и о пишущих справа налево) и параметров проверки правописания. Умолчальные параметры нового документа, такие, как шрифт, кегль, абзацный отступ и так далее, можно задать через переопределение базового стиля Normal (через меню Сервис -&gt; Стилист). Иных возможностей настройки вроде бы не просматривается. Впрочем, и перечисленных обычно более чем достаточно.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/08-office_182.png">
        <img alt="Изображение513" class="frameGraphics" id="513graphic" src="http://alv.me/wp-content/img/im_cin_img/08-office_182.png" style="border:1.0px solid #000080;padding:0;width:523.83374px;height:512.8353px" />
      </a>
      <a id="a515graphic"></a>
      <a id="bkm515graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/08-office_183.png">
        <img alt="Изображение514" class="frameGraphics" id="514graphic" src="http://alv.me/wp-content/img/im_cin_img/08-office_183.png" style="border:1.0px solid #000080;padding:0;width:523.83374px;height:512.8353px" />
      </a>
      <a id="a516graphic"></a>
      <a id="bkm516graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/08-office_183.png"> </a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/08-office_184.png">
        <img alt="Изображение515" class="frameGraphics" id="515graphic" src="http://alv.me/wp-content/img/im_cin_img/08-office_184.png" style="border:1.0px solid #000080;padding:0;width:523.83374px;height:512.8353px" />
      </a>
      <a id="a517graphic"></a>
      <a id="bkm517graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/08-office_184.png"> </a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/08-office_185.png">
        <img alt="Изображение516" class="frameGraphics" id="516graphic" src="http://alv.me/wp-content/img/im_cin_img/08-office_185.png" style="border:1.0px solid #000080;padding:0;width:523.83374px;height:512.8353px" />
      </a>
      <a id="a518graphic"></a>
      <a id="bkm518graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/08-office_185.png"> </a>
    </p>
    <p class="Textbody">Из недостающих функций бросается в глаза отсутствие копирования формата выделенного фрагмента — в ряде случаев весьма полезная штука. Правда, это частично компенсируется иной функцией — копированием без форматирования (в меню Правка). Не вполне удачно (точнее, вполне, на наш взгляд, неудачно) реализована вставка специальных символов. Ну и попытка вставить гиперссылку неизменно приводила у нас к выпадению программы в осадок. Впрочем, и это, скорее всего, дефект конктерной сборки.</p>
    <p class="Textbody">Теперь о личных впечатлениях. Автор этих строк следит за развитием Aboword'а на протяжении уже более десяти лет. Его потребности в текстовом процессоре ограничиваются двумя задачами: чтением и редактированием doc-файлов, присланных корреспондентами, в том числе сотрудниками редакций, с которыми он работает, и конвертацией тех же документов Word'а в чистый html, не оскорбляющий эстетического чувства поклонников пуристического кода.</p>
    <p class="Textbody">Обе эти задачи решаются с помощью Aboword'а, позволяя избавиться, таким образом, сразу от любого из офисных монстров со всем их сопутствующим инвентарём. Не о таком ли текстовом процессоре мечталось пятнадцать лет назад, во времена существования программы Ted, создания Витусом Вагнером проекта Пингвин при галстуке и первых сочинений Владимира Игнатова (к слову сказать, автора термина «подоконник») о легких текстовых процессорах и русификации LyX'а? И похоже, что мечта эта нашла свое воплощение.</p>
    <p class="Textbody">Правда, закончить этот очерк придётся всё-таки на минорной ноте: расхожее мнение о сверхъестественном быстродействии Abiword (особенно часто повторяемое в сравнении с LibreOffice и Openoffice.org) основано на преданьях старины глубокой. Однако и в этом отношении всё не так суицидально, и по настоящему «тормознутость» Abiword'а сказывается только при работе с очень большими документами. На документах же маленьких, для которых он, собственно, и предназначен, заметить её невооруженным глазом невозможно.</p>
    <h3 id="toc199"><a id="RefHeading18401713816058"></a><a id="bkmRefHeading18401713816058"></a><a id="toc198"></a><a id="bkmtoc198"></a><a id="RefHeading6541136957987"></a><a id="bkmRefHeading6541136957987"></a><a id="bkmRefHeading6541136957987"></a><a id="bkmbkmRefHeading6541136957987"></a>Gnumeric</h3>
    <p class="Textbody">Электронные таблицы вообще — это весьма специфические компоненты офисных пакетов, причисляемые к ним по недоразумению: столь же обоснованно было бы отнести их к пакетам инженерным или научным. По крайней мере, в старое время лучшие представители этого семейства, такие как Lotus 123 или Quattro Pro. И Gnumeric продолжает эту традицию.</p>
    <p class="Textbody">Gnumeric — это электронная таблица, входящая в состав GNOME Office, использующая библиотеки Gtk и gnomelibs. Если характеризовать Gnumeric несколькими словами, к нему можно применить те же эпитеты, что и к --; легкий и быстрый, не перегруженный излишней функциональностью, простой и элегантный:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/08-office_186.png">
        <img alt="Изображение517" class="frameGraphics" id="517graphic" src="http://alv.me/wp-content/img/im_cin_img/08-office_186-572x565.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:566.8447px" />
      </a>
      <a id="a519graphic"></a>
      <a id="bkm519graphic"></a>
    </p>
    <p class="Textbody">Как и AbiWord, Gnumeric использует свой формат файлов электронных таблиц, который так и называется — *.gnumeric. Однако список понимаемых им «чужих» форматов также обширен. Проверить его целиком возможности не было, но с файлами в формате *.ods и *.xls Gnumeric справляется вполне успешно:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/08-office_187.png">
        <img alt="Изображение518" class="frameGraphics" id="518graphic" src="http://alv.me/wp-content/img/im_cin_img/08-office_187-572x419.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:420.84158px" />
      </a>
      <a id="a520graphic"></a>
      <a id="bkm520graphic"></a>
    </p>
    <p class="Textbody">Как уже говорилось во вступлении, главная сила Gnumeric'а — в изобилии его статистических и прочих технических функций, а также в построении разнообразных диаграмм, что можно просто проиллюстрировать скриншотом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/08-office_188.png">
        <img alt="Изображение519" class="frameGraphics" id="519graphic" src="http://alv.me/wp-content/img/im_cin_img/08-office_188-572x565.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:566.8447px" />
      </a>
      <a id="a521graphic"></a>
      <a id="bkm521graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/08-office_188.png"> </a>
    </p>
    <p class="Textbody">Ну а строятся диаграммы в Gnumeric'е очень просто. Для начала выделяется блок данных для будущего графика:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/08-office_189.png">
        <img alt="Изображение520" class="frameGraphics" id="520graphic" src="http://alv.me/wp-content/img/im_cin_img/08-office_189-572x565.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:566.8447px" />
      </a>
      <a id="a522graphic"></a>
      <a id="bkm522graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/08-office_189.png"> </a>
    </p>
    <p class="Textbody">Затем — переход в меню: Вставка -&gt; Диаграмма:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/08-office_190.png">
        <img alt="Изображение521" class="frameGraphics" id="521graphic" src="http://alv.me/wp-content/img/im_cin_img/08-office_190.png" style="border:1.0px solid #000080;padding:0;width:372.8416px;height:414.83212px" />
      </a>
      <a id="a523graphic"></a>
      <a id="bkm523graphic"></a>
    </p>
    <p class="Textbody">Далее — выбор типа диаграммы из предлагаемых вариантов, например, вот такой:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/08-office_191.png">
        <img alt="Изображение522" class="frameGraphics" id="522graphic" src="http://alv.me/wp-content/img/im_cin_img/08-office_191-572x496.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:497.83054px" />
      </a>
      <a id="a524graphic"></a>
      <a id="bkm524graphic"></a>
    </p>
    <p class="Textbody">И — мышеклик в том месте рабочего листа, где эту диаграмму хотелось бы видеть:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/08-office_192.png">
        <img alt="Изображение523" class="frameGraphics" id="523graphic" src="http://alv.me/wp-content/img/im_cin_img/08-office_192-572x565.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:566.8447px" />
      </a>
      <a id="a525graphic"></a>
      <a id="bkm525graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/08-office_192.png"> </a>
    </p>
    <p class="Textbody">Нынешняя моя сфера деятельности не даёт простора для практического применения всего функционала Gnumeric'а, поэтому я ограничился чисто умозрительными примерами. Но эта программа заставила меня вспомнить фразу, вычитанную на заре всесоюзной компьютеризации в каком-то буржуазном компьютерном журнале (цитирую по памяти):</p>
    <p class="Textbody">Если задача не решается с помощью табличного процессора — скорее всего, она не решается вообще.</p>
    <p class="Textbody">Конечно, это шутка — но доля шутки тут очень небольшая. Особенно применительно к Gnumeric'у.</p>
    <h2 id="toc200"><a id="RefHeading18421713816058"></a><a id="bkmRefHeading18421713816058"></a><a id="toc199"></a><a id="bkmtoc199"></a><a id="RefHeading12981136957987"></a><a id="bkmRefHeading12981136957987"></a><a id="bkmRefHeading12981136957987"></a><a id="bkmbkmRefHeading12981136957987"></a>Мультимедиа</h2>
    <p class="Quotations">Но недавно случилась история —<br />Я купил радиолу «Эстония»,<br />И в свободный часок, на полчасика,<br />Я прилёг позабавиться классикой.<br /><span style="font-style:italic">Александр Галич, </span><span style="font-style:italic;font-weight:bold">Баллада о прибавочной стоимости</span></p>
    <p class="Textbody">Применителю любого дистрибутива Linux, дабы позабавиться классикой, нет необходимости тратиться на радиолу «Эстония» — он вполне может делать это, не отходя от своего рабочего инструмента. Не рискуя, к тому же, услышать своё фамилиё в неподходящем контексте.</p>
    <h3 id="toc201"><a id="RefHeading18441713816058"></a><a id="bkmRefHeading18441713816058"></a><a id="toc200"></a><a id="bkmtoc200"></a><a id="RefHeading6561136957987"></a><a id="bkmRefHeading6561136957987"></a><a id="bkmRefHeading6561136957987"></a><a id="bkmbkmRefHeading6561136957987"></a>Медиа-потребительство</h3>
    <p class="Textbody">И дистрибутив Mint тут не исключение: в стандартной установке его Cinnamon-редакции имеются:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">аудиоплейер Banshee; </p>
      </li>
      <li>
        <p class="Textbody">Totem — видеоплейер, который прекрасно проигрывает также и аудиофайлы; </p>
      </li>
      <li>
        <p class="Textbody">потоковый медиаплейер VLC. </p>
      </li>
    </ul>
    <p class="Textbody">Всё это — прекрасные средства для воспроизведения разного рода медиа-контента, сопровожающиеся всеми необходимыми библиотеками и кодеками для безукоризенной работы с медиа-форматами, которые некоторые отсалые личности полагают проприетарными, то есть частнособственническими (причём искренне считают их своей собственностью). Да вот только я всем этим богачеством не пользуюсь, и ничего не могу про него рассказать. Потому что с давних пор привык в качестве универсального аудио- и видеопроигрывателя применять mplayer — обычно в консольном исполнении, но не брезгую и графическими к нему «мордами» (последнее время в качестве таковой применяю GNOME MPlayer).</p>
    <p class="Textbody">Программа mplayer — проигрыватель аудио- и видеофайлов. Её отличительная особенность в том, что как её зависимости идут кодеки для воспроизведения практически всех необходимых медиафайлов — по крайней мере, все необходимые мне. И всё это хозяйство, включая графические фронт-энды, имеется в официальном репозитории Mint. Так что если набрать в командной строке</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install gnome-mplayer</span> </p>
    <p class="Textbody">то всё оно будет установлено как зависимости данного пакета. Поскольку в последнее время развитие mplayer'а несколько застопорилось, образовался его форк — mplayer2, обладающий некоторыми дополнительными функциями (хотя для нетребовательного потребителя мультимедийного контента, вроде автора этих строк, различий между ними не заметно). И именно он будет инсталлирован как бэк-энд графической «морды». Хотя в каталоге /usr/bin его исполняемый файл будет всё равно фигурировать как просто mplayer.</p>
    <p class="Textbody">Про кодеки я уже сказал — их состав можно просмотреть в секции Зависимости вывода команды</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt show mplayer2</span> </p>
    <p class="Textbody">Сам по себе mplayer работает из командной строки — командой вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mplayer path2/*.mp3</span> </p>
    <p class="Textbody">можно запустить прослушивание всей музыки из указанного каталога. Тем же образом можно и смотреть видео:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/media_000.png">
        <img alt="Изображение524" class="frameGraphics" id="524graphic" src="http://alv.me/wp-content/img/im_cin_img/media_000-572x436.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:437.84946px" />
      </a>
      <a id="a526graphic"></a>
      <a id="bkm526graphic"></a>
    </p>
    <p class="Textbody">В обоих случаях никакого отвлекающего интерфейса нет. А минимально необходимые управляющие действия — пауза/продолжение и прокрутка вперёд/назад — выполняются с клавиатуры. В связи с чем даю небольшую шпаргалку по хоткеям этой программы:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">* и / — увеличение и уменьшение громкости; </p>
      </li>
      <li>
        <p class="Textbody">p и SpaceBar, а также правый клик мышью — пауза, повторное нажатие — продолжение; </p>
      </li>
      <li>
        <p class="Textbody">&lt; и &gt; — переход назад и вперёд по плейлисту; </p>
      </li>
      <li>
        <p class="Textbody">&lt;- и -&gt; — переход назад и вперёд на 10 секунд; </p>
      </li>
      <li>
        <p class="Textbody">Down и Up — переход назад и вперёд на 1 минуту; </p>
      </li>
      <li>
        <p class="Textbody">PgDn и PgUp — переход назад и вперёд на 10 минут; </p>
      </li>
      <li>
        <p class="Textbody">Enter — после паузы вперёд по плейлисту, по завершении его — окончание воспроизведения без выхода; </p>
      </li>
      <li>
        <p class="Textbody">U — окончание воспроизведения без выхода; </p>
      </li>
      <li>
        <p class="Textbody">q и ESC — остановки и выход из Mplayer'а. </p>
      </li>
    </ul>
    <p class="Textbody">Ну а использование программы GNOME MPlayer настолько тривиально, что можно ограничиться скриншотом окна программы при воспроизведении видео:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/media_001.png">
        <img alt="Изображение525" class="frameGraphics" id="525graphic" src="http://alv.me/wp-content/img/im_cin_img/media_001-572x274.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:275.85892px" />
      </a>
      <a id="a527graphic"></a>
      <a id="bkm527graphic"></a>
    </p>
    <p class="Textbody">А при прогирывании аудиозаписей окно это выглядит ещё проще:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/media_002.png">
        <img alt="Изображение526" class="frameGraphics" id="526graphic" src="http://alv.me/wp-content/img/im_cin_img/media_002.png" style="border:1.0px solid #000080;padding:0;width:399.82742px;height:148.82896px" />
      </a>
      <a id="a528graphic"></a>
      <a id="bkm528graphic"></a>
    </p>
    <p class="Textbody">Тем не менее, не смотря на непритязательность интерфейса графической «морды» и его полное отсутствие в консольном варианте, свои потребительские функции mplayer выполняет вполне справно.</p>
    <h3 id="toc202"><a id="RefHeading18461713816058"></a><a id="bkmRefHeading18461713816058"></a><a id="toc201"></a><a id="bkmtoc201"></a><a id="RefHeading6581136957987"></a><a id="bkmRefHeading6581136957987"></a><a id="bkmRefHeading6581136957987"></a><a id="bkmbkmRefHeading6581136957987"></a>Оцифровка аудио-компактов</h3>
    <p class="Textbody">Некоторое время назад мне казалось, что задача оцифровки аудио-компактов утратила актуальность — всё, что могло (и должно) быть оцифровано, было оцифровано. Однако в связи с отмиранием<br />устройств чтения оптических носителей вопрос этот опять стал злободневным, почему я и уделю посвящу ему данный мини-очерк.</p>
    <p class="Textbody">С давних пор для оцифровки всяческой музыки я использую программу Asunder — не потому, что считаю её лучше других, ибо сравнивать мне не с чем. Просто некогда она подвернулась мне под руку, показалась годной, и более добра от добра я не искал.</p>
    <p class="Textbody">Asunder — программа для захвата треков с аудио-компактов, результаты которого можно сохранить в различных форматах: в виде чистых wav-файлов, в mp3, ogg и flac. В принципе, возможно и подключение дополнительных форматов, но оно потребует доустановки соответствующих кодеков.</p>
    <p class="Textbody">Как работает Asunder — проще всего рассмотреть на конкретном примере. Тем более что давеча у меня был повод обратиться к ней: в закромах Родины обнаружился комплект из четырёх дисков под названием Золотая классика, который, безусловно, представлял собой непреходящую ценность.<br />Вот лицевая сторона бокса:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/gold_classic-1.png">
        <img alt="Изображение527" class="frameGraphics" id="527graphic" src="http://alv.me/wp-content/img/im_cin_img/gold_classic-1-572x569.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:570.851px" />
      </a>
      <a id="a529graphic"></a>
      <a id="bkm529graphic"></a>
    </p>
    <p class="Textbody">А вот — оборотная, на которой приведено содержание всех дисков набора, их четыре штуки:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/gold_classic-2.png">
        <img alt="Изображение528" class="frameGraphics" id="528graphic" src="http://alv.me/wp-content/img/im_cin_img/gold_classic-2-572x482.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:483.8463px" />
      </a>
      <a id="a530graphic"></a>
      <a id="bkm530graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/02/gold_classic-2.png"> </a>
    </p>
    <p class="Textbody">В стандартной инсталляции Cinnamon-редакции дистрибутива Mint программы Asunder нет, но она имеется в официальном репозитории, и потому её легко установить:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install asunder</span> </p>
    <p class="Textbody">Кроме того, неплохо также установить такие пакеты:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install lame flac</span> </p>
    <p class="Textbody">Они потребуются для сохранения звуковых дорожек в форматах mp3 и flac, соответственно.</p>
    <p class="Textbody">После этого Asunder запускается из меню Аудио и видео и предстаёт в следующем виде:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/asunder_01.png">
        <img alt="Изображение529" class="frameGraphics" id="529graphic" src="http://alv.me/wp-content/img/im_cin_img/asunder_01-572x401.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:402.85104px" />
      </a>
      <a id="a531graphic"></a>
      <a id="bkm531graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/02/asunder_01.png"> </a>
    </p>
    <p class="Textbody">Прежде чем начинать с ним работу, желательно выполнить некоторые настройки. Как легко догадаться, они вызываются через пункт Параметры меню программу. Я приведу те настройки, которые сделал, занимаясь той самой Золотой классикой.</p>
    <p class="Textbody">Для начала во вкладке Общие определяется каталог для будущих аудиофайлов и устройство чтения компакт-дисков. Последним по умолчанию является /dev/cdrom — символическая ссылка на файл реального устройства (обычно это /dev/sr0). Но у меня внутренний привод дышит на ладан, поэтому для оцифровки я подключит внешний, USB'шный, который получил имя /dev/sr0. Прочие опции указываются по желанию:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/asunder_02.png">
        <img alt="Изображение530" class="frameGraphics" id="530graphic" src="http://alv.me/wp-content/img/im_cin_img/asunder_02.png" style="border:1.0px solid #000080;padding:0;width:561.8558px;height:344.8353px" />
      </a>
      <a id="a532graphic"></a>
      <a id="bkm532graphic"></a>
    </p>
    <p class="Textbody">Во вкладке Имена файлов определяется система именования файлов, полученных в результате оцифровки. Я оставил умолчания программы без изменений — они понятны без комментариев:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/asunder_03.png">
        <img alt="Изображение531" class="frameGraphics" id="531graphic" src="http://alv.me/wp-content/img/im_cin_img/asunder_03.png" style="border:1.0px solid #000080;padding:0;width:561.8558px;height:344.8353px" />
      </a>
      <a id="a533graphic"></a>
      <a id="bkm533graphic"></a>
    </p>
    <p class="Textbody">Далее, во вкладке Кодирование, указываются форматы выходных файлов — мне было достаточно сжатого с потерями MP3 и сжатого lossless, FLAC:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/asunder_04.png">
        <img alt="Изображение532" class="frameGraphics" id="532graphic" src="http://alv.me/wp-content/img/im_cin_img/asunder_04.png" style="border:1.0px solid #000080;padding:0;width:561.8558px;height:524.8542px" />
      </a>
      <a id="a534graphic"></a>
      <a id="bkm534graphic"></a>
    </p>
    <p class="Textbody">При желании можно указать ещё несколько форматов, в том числе и с использованием проприетарного кодека Nero — правда, все они потребуют доустановки соответствующих пакетов:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/asunder_04a.png">
        <img alt="Изображение533" class="frameGraphics" id="533graphic" src="http://alv.me/wp-content/img/im_cin_img/asunder_04a.png" style="border:1.0px solid #000080;padding:0;width:561.8558px;height:570.851px" />
      </a>
      <a id="a535graphic"></a>
      <a id="bkm535graphic"></a>
    </p>
    <p class="Textbody">Во вкладке Расширенные я оставил умолчания без изменений, включив только на всякий случай запись log-файла:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/asunder_05.png">
        <img alt="Изображение534" class="frameGraphics" id="534graphic" src="http://alv.me/wp-content/img/im_cin_img/asunder_05.png" style="border:1.0px solid #000080;padding:0;width:561.8558px;height:524.8542px" />
      </a>
      <a id="a536graphic"></a>
      <a id="bkm536graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/02/asunder_05.png"> </a>
    </p>
    <p class="Textbody">Теперь можно было вставлять первый диск набора, после чего перед глазами появляется следующее безобразие, вызванное несовпадением системной кодировки и кодировки компакта:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/asunder_06.png">
        <img alt="Изображение535" class="frameGraphics" id="535graphic" src="http://alv.me/wp-content/img/im_cin_img/asunder_06-572x401.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:402.85104px" />
      </a>
      <a id="a537graphic"></a>
      <a id="bkm537graphic"></a>
    </p>
    <p class="Textbody">Название альбома я поправил, а переименовывать сами файлы мне было лениво:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/asunder_06a.png">
        <img alt="Изображение536" class="frameGraphics" id="536graphic" src="http://alv.me/wp-content/img/im_cin_img/asunder_06a-572x401.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:402.85104px" />
      </a>
      <a id="a538graphic"></a>
      <a id="bkm538graphic"></a>
    </p>
    <p class="Textbody">Впрочем, один из дисков набора прочитался почему-то по человечески:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/asunder_06b.png">
        <img alt="Изображение537" class="frameGraphics" id="537graphic" src="http://alv.me/wp-content/img/im_cin_img/asunder_06b-572x401.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:402.85104px" />
      </a>
      <a id="a539graphic"></a>
      <a id="bkm539graphic"></a>
    </p>
    <p class="Textbody">Теперь оставалось только нажать кнопку Извлечь — и наблюдать за ходом процесса, который может занять немалое время, не смотря на то, что считывание трака и его кодирование осуществляются параллельно:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/asunder_07.png">
        <img alt="Изображение538" class="frameGraphics" id="538graphic" src="http://alv.me/wp-content/img/im_cin_img/asunder_07.png" style="border:1.0px solid #000080;padding:0;width:310.85733px;height:126.83212px" />
      </a>
      <a id="a540graphic"></a>
      <a id="bkm540graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/02/asunder_07.png"> </a>
    </p>
    <p class="Textbody">Однако рано или поздно процесс заканчивается, что знаменуется соответствующим сообщением:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/02/asunder_08.png">
        <img alt="Изображение539" class="frameGraphics" id="539graphic" src="http://alv.me/wp-content/img/im_cin_img/asunder_08.png" style="border:1.0px solid #000080;padding:0;width:325.82425px;height:130.83842px" />
      </a>
      <a id="a541graphic"></a>
      <a id="bkm541graphic"></a>
    </p>
    <p class="Textbody">По идее, тут лоток с диском должен бы выдвинуться, если, как у меня, отмечена соответствующая опция. Но с моим внешним приводом это не сработало, так что пришлось нажимать кнопку извлечения на самом агрегате.</p>
    <p class="Textbody">Вот, собственно, и всё. Далее можно сепарировать файлы различных форматов (к сожалению, такой опции в настройках не предусмотрено), придать им осмысленные имена (автоматического перекодирования также нет), ну и, разумеется, слушать то, что получилось...</p>
    <h2 id="toc203"><a id="RefHeading18481713816058"></a><a id="bkmRefHeading18481713816058"></a><a id="toc202"></a><a id="bkmtoc202"></a><a id="RefHeading13001136957987"></a><a id="bkmRefHeading13001136957987"></a><a id="bkmRefHeading13001136957987"></a><a id="bkmbkmRefHeading13001136957987"></a>softRAID, LVM, ZFS</h2>
    <p class="Textbody">Следующие три очерка посвящаются рассмотрению довольно специальных вопросов — применению в Mint программного RAID, технологии LVM и системы размещёния данных ZFS. Тех, кого эти темы не интересуют, могут смело пропустить соответствующие страницы.</p>
    <h2 id="toc204"><a id="RefHeading18501713816058"></a><a id="bkmRefHeading18501713816058"></a><a id="toc203"></a><a id="bkmtoc203"></a><a id="RefHeading13021136957987"></a><a id="bkmRefHeading13021136957987"></a><a id="bkmRefHeading13021136957987"></a><a id="bkmbkmRefHeading13021136957987"></a>Общее введение</h2>
    <p class="Textbody">При наличии в машине двух или более накопителей возникает вопрос, как организовать работу с ними оптимальным образом. Очевидно, что разместить на одном устройстве корневую файловую систему, а остальные просто примонтировать к ней — не самое удачное решение, и к нему прибегают обычно не от хорошей жизни. И здесь для применительского десктопа напрашивается три варианта объединения накопителей, каждый из которых предоставляет ещё и некоторые дополнительные возможности:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">программный RAID, позволяющий повысить быстродействие дисковой подсистемы (softRAID Level 0); </p>
      </li>
      <li>
        <p class="Textbody">технология LVM, дающая возможность простого подключения дополнительных носителей и, при соблюдении некоторых условий, изменения размера файловых систем; </p>
      </li>
      <li>
        <p class="Textbody">система размещёния данных ZFS, объединяющая в себе функции управления логическими томами и файловой системы. </p>
      </li>
    </ol>
    <p class="Textbody">Возможны и другие варианты, например, softRAID Level 1, обеспечивающий, опять же при некоторых условиях, надёжность хранения данных, или файловая система BTRFS, функцйионально сходная с ZFS. Однако первое решение для настольной машины (а в данных очерках рассматривается только этот случай, о серверах тут речи не будет) имеет не много смысла. Ибо эта самая надёжность гарантируется только тогда, когда есть возможность замены вышедшего из сторя диска аналогичным по объёму и, желательно, характеристикам — согласитесь, не частое явление для индивидуала-надомника.</p>
    <p class="Textbody">Что же до BTRFS — что бы ни говорили о готовности этой системы к промышленному использованию (а настольная машина применителя для него самое что ни на есть промышленное использование), на сей счёт в народе (в том числе и у автора этих строк) существуют небезосновательные сомнения. Характерно, что в openSUSE, кажется, первой взявшей BTRFS на вооружение как умолчальной, она задействуется под корневую файловую систему, тогда как бесценные пользовательские данные по умолчанию предлагается размещать на XFS.</p>
    <p class="Textbody">В силу вышесказанного в настоящей книге рассмотрены только три перечисленных варианта. Каждый из них имеет свои преимущества и недостатки. И поэтому ни один из них не может быть однозначно рекомендован во всех случаях жизни. Надеюсь, что следующие очерки дадут читателю некоторую информацию для того, чтобы выбрать вариант, подходящий именно для него. Своё же мнение по сравнению их я выскажу в общем заключении.</p>
    <p class="Textbody">И ещё одна необходимая оговорка: все три варианта я рассматриваю исключительно в контексте хранения пользовательских данных, то есть, фигурально говоря, ветви /home файловой иерархии. Предполагается, что корень последней размещён на обычном дисковом разделе с традиционной файловой системой, которая, как говаривал Генри Форд Старший, может быть любой. При условии, что это будет Ext4, ибо все остальные нынче не дадут применителю ничего, кроме возможных проблем, в причины возникновения которых здесь вдаваться неуместно. А вот сказать пару слов об инструментах дисковой разметки — необходимо.</p>
    <h2 id="toc205"><a id="RefHeading18521713816058"></a><a id="bkmRefHeading18521713816058"></a><a id="toc204"></a><a id="bkmtoc204"></a><a id="RefHeading13041136957987"></a><a id="bkmRefHeading13041136957987"></a><a id="bkmRefHeading13041136957987"></a><a id="bkmbkmRefHeading13041136957987"></a>Инструменты дисковой разметки и форматирования</h2>
    <p class="Textbody">Как было сказано во вступительном очерке, далее речь пойдёт о прикручивании специальных систем размещёния данных к уже установленной системе. И любой из этих процессов в этом случае начинается с разметки разделов под них, а заканчивается созданием файловых систем (каковое далее для краткости буду называть форматированием, хотя в общем случае это не тождественные понятия). И потому начать разговор следует с обзора инструментария, для этих целей предназначенного.</p>
    <h3 id="toc206"><a id="RefHeading18541713816058"></a><a id="bkmRefHeading18541713816058"></a><a id="toc205"></a><a id="bkmtoc205"></a><a id="RefHeading6601136957987"></a><a id="bkmRefHeading6601136957987"></a><a id="bkmRefHeading6601136957987"></a><a id="bkmbkmRefHeading6601136957987"></a>Виды дисковой разметки</h3>
    <p class="Textbody">Некогда тема дисковых разделов подробно рассматривалась в любом руководстве по Linux и соплеменным системам, а также во множестве специальных документов, как в Сети, так и на бумаге. С этой процедуры начинало знакомство с Linux не одно поколение грядущих его применителей. А устрашающие к ней комментарии были непременным атрибутом «курса молодого линуксоида».</p>
    <p class="Textbody">«Потом пришли другие времена» — и необходимость в столь подробных описаниях отпала. Да и число актуальных схем дисковой разметки резко поуменьшилось, сведясь к двум с половиной вариантам:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">разметка в стиле msdos; </p>
      </li>
      <li>
        <p class="Textbody">разметка в стиле gpt; </p>
      </li>
      <li>
        <p class="Textbody">полварианта для любителей и ценителей — разметка в стиле bsd. </p>
      </li>
    </ol>
    <p class="Textbody">На полуварианте останавливаться не буду — те, кто держит на своей машине Linux параллельно с какой-либо BSD-системой, знают о нём не меньше меня. Тем более, что это, как и msdos, частный случай MBR-разметки, о которой сказать необходимо.</p>
    <p class="Textbody">Разметка в стиле msdos возникла вместе с первыми IBM PC и их BIOS, предусматривающим Главную Загрузочную Запись (MBR — Master Boot Record). Она целиком умещается в так называемый нулевой сектор носителя, объёмом 512 байт. И в его части, отведённой под таблицу разделов, предусмотрено место для четырёх записей — то есть Primary Partitions. Большее количество разделов можно создать по «матрёшечному» принципу, путём объявления одного из первичных разделов Extended Partition.</p>
    <p class="Textbody">Расширенный раздел выступает в качестве контейнера, в который последовательно, как в матрёшку, вкладываются один логический раздел и ещё один расширенный раздел. Последний, в свою очередь, выступает контейнером второго уровня, и может включать ещё один логический раздел и следующий по очереди расширенный, — и так до бесконечности. Правда, аналогия с матрёшкой - не совсем строгая, потому что для пользователя все эти вложенные разделы видятся как равноправные части «головного» Extended-раздела. Да и на счёт бесконечности — тоже несколько преувеличено: на самом деле существует практический лимит для восприятия логических разделов, определяемый числом 63.</p>
    <p class="Textbody">Разметка в стиле GPT (GUID Partition Table) — это новый формат таблицы разделов на носителях информации (традиционных винчестерах, SSD-накопителях, флэшках, SD-картах). Как явствует из названия, он основан на Globally Unique Identifier (GUID) — статистически уникальных 128-битных идентификаторах всего на свете, в том числе и носителей.</p>
    <p class="Textbody">Таблица разделов GUID (далее для краткости я буду называть её просто GPT) существенно больше, нежели MBR.. Она занимает первые 34 блока (с нулевого по 33-й). Из них нулевой блок занимает всё тот же MBR — точнее, его защищённая (или защищающая? — protected) копия, предназначенная для программ, не понимающих GPT. Благодаря ему, скажем, утилита fdisk опознаёт винчестер с GPT как единый раздел неизвестного типа, но на самом деле работать с ним не может.</p>
    <p class="Textbody">Следующий блок — это оглавление таблицы разделов, в котором предусмотрено место для 128 записей. Это, соответственно, максимальное число разделов при разметке в GPT-стиле. Наконец, остальные 32 блока предназначены для записи данных о разделах.</p>
    <p class="Textbody">Таблица разделов GUID существует в двух экземплярах: основной находится в первых 34 блоках носителя, а дублирующий (полная копия основного, за исключением MBR) — в последних. При повреждении основной GPT (фиксируемом несовпадением контрольной суммы, хранящейся в оглавлении) она автоматически восстанавливается из таблицы дублирующей.</p>
    <p class="Textbody">В Linux традиционно использовалась MBR-разметка в стиле msdos, и для последней предназначались соответствующие утилиты.</p>
    <p class="Textbody">Несколько лет назад казалось, что железный конь GPT уверенно идёт на смену крестьянской лошади MBR: инсталляторы ряда популярных дистрибутивов, на которые не будем указывать пальцем, стали предлагать разметку в GPT-стиле как альтернативу, а некоторые — даже и по умолчанию. Однако довольно быстро оказалось, что это не даёт применителю ничего полезного, а вот некоторые проблемы с загрузчиком и особенно его восстановлением при сбоях создаёт. И даже самые прогрессисты от дистроения откатились обратно, сохранив поддержку GPT лишь в качестве опции.</p>
    <p class="Textbody">Надо сказать, что Ubuntu и её последователи не поддавались модному влиянию, и в инсталляторах всего этого клана GPT-разметка не поддерживалась никогда, и не поддерживается по сию пору. Хотя с дисками, размеченными в GPT-стиле внешними программами все Ubuntu'иды работают вполне справно. Однако далее я буду говорить только про MBR-разметку — интересующимся прогрессом ради прогресса могу предложить почитать <a href="http://fossbook.info/partitions/1449»%20target=">вот это</a>.</p>
    <h3 id="toc207"><a id="RefHeading18561713816058"></a><a id="bkmRefHeading18561713816058"></a><a id="toc206"></a><a id="bkmtoc206"></a><a id="RefHeading6621136957987"></a><a id="bkmRefHeading6621136957987"></a><a id="bkmRefHeading6621136957987"></a><a id="bkmbkmRefHeading6621136957987"></a>CLI: инструменты разметки</h3>
    <p class="Textbody">В Linux для разметки диска в MBR-стиле из командной строки можно использовать:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">низкоуровневую утилиту командной строки sfdisk — инструмент очень гибкий, но сложный в обращении и требующий очень большой аккуратности — все изменения дисковой разметки совершаются там в реальном времени; </p>
      </li>
      <li>
        <p class="Textbody">интерактивную диалоговую программу fdisk — почти столь же гибкую, как и sfdisk, но более простую и, главное, более безопасную в обращении — изменения дисковой разметки происходят тут только после соответствующего подтверждения пользователем правильности своих действий; </p>
      </li>
      <li>
        <p class="Textbody">интерактивную меню-ориентированную программу cfdisk, которая считается ещё более простой в использовании, чем fdisk (для которого она служит фронт-эндом) и столь же безопасна с точки зрения сохранности данных; </p>
      </li>
    </ul>
    <p class="Textbody">Кроме этого, существует универсальная утилита parted, которая позволяет создавать не только дисковые разделы, но и файловые системы на них. В числе её функций также модифицирование существующих разделов — изменение размера, копирование и перемещёние. Однако платой за её универсализм является сложность использования без постоянной практики. А поскольку разметка диска — не то занятие, которому тпичный применитель Linux'а предаётся по три раза на дню, говорить о ней я не буду.</p>
    <h4 id="toc208"><a id="RefHeading18581713816058"></a><a id="bkmRefHeading18581713816058"></a><a id="toc207"></a><a id="bkmtoc207"></a><a id="RefHeading6641136957987"></a><a id="bkmRefHeading6641136957987"></a><a id="bkmRefHeading6641136957987"></a><a id="bkmbkmRefHeading6641136957987"></a>Утилита fdisk</h4>
    <p class="Textbody">Начнем с fdisk: именно им больше всего пугали в старые времена начинающих пользователей Linux, предлагая дружественные альтернативы типа Disk Druid. Однако при ближайшем рассмотрении выясняется, что ничего устрашающего в ней нет.</p>
    <p class="Textbody">Происхождение fdisk теряется во мраке веков, уходя во времена первых UNIX для PC-архитектуры — насколько я понимаю, раньше необходимости в ней не было, а главными инструментами дисковой разметки были утилиты типа disklabel или bsdlabel. Мне не удалось также выяснить, когда эта утилита появилась в Linux. Могу только предполагать, что на самых ранних стадиях создания утилит обрамления для его ядра — т.н. linux-utils.</p>
    <p class="Textbody">Для начала следует запомнить, что запуск команды fdisk в любом качестве, даже просто для получения информации о диске, возможно только с правами суперпользователя, каковые и надо обеспечить себе обычным для Mint образом, то есть через sudo.</p>
    <p class="Textbody">Если команду fdisk дать без опций и аргументов, она выведет краткую справку об её использовании:</p>
    <p class="Textbody"><span style="background-color:#dddddd">$ sudo fdisk</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Usage: fdisk (-l) (-b SSZ) (-u) device</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">E.g.: fdisk /dev/hda  (for the first IDE disk)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  or: fdisk /dev/sdc  (for the third SCSI disk)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  or: fdisk /dev/eda  (for the first PS/2 ESDI drive)</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">  or: fdisk /dev/rd/c0d0  or: fdisk /dev/ida/c0d0  (for RAID devices)</span> </p>
    <p class="Textbody">В качестве аргумента команды фигурирует имя файла устройства — физического диска целиком. Поскольку в современных версиях ядра Linux все диски, вне зависимости от их интерфейсов (PATA, SATA, SCSI, SAS, USB) определяются единой подсистемой ATA-SCSI, на самом деле имена эти будут иметь вид /dev/sda, /dev/sdb и так далее.</p>
    <p class="Textbody">Смысл опций команды fdisk следующий:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">l не предписывает выполнения каких-либо действий, а лишь выводит информацию о диске и его разделах, если таковые имеются; </p>
      </li>
      <li>
        <p class="Textbody">b задаёт размер блока — единицы измерения дискового пространства; по умолчанию, без указание этой опции, он равен физическому блоку (512 байт), прочие возможные значения кратны его размеру — 1024, 2048 или 4096 байт; </p>
      </li>
      <li>
        <p class="Textbody">u запускает fdisk, являясь опцией по умолчанию. </p>
      </li>
    </ul>
    <p class="Textbody">Перво-наперво посмотрим на информационную функцию fdisk, для чего запустим её следующим образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo  fdisk -l /dev/sdd</span> </p>
    <p class="Textbody">Ответом будет вывод примерно такого вида:</p>
    <p class="Textbody"><span style="background-color:#dddddd">Диск /dev/sdd: 500.1 Гб, 500107862016 байт</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">255 головок, 63 секторов/треков, 60801 цилиндров, всего 976773168 секторов</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Units = секторы of 1 * 512 = 512 bytes</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Размер сектора (логического/физического): 512 байт / 512 байт</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">I/O size (minimum/optimal): 512 bytes / 512 bytes</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Идентификатор диска: 0x000b24d0</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Устр-во Загр     Начало       Конец       Блоки   Id  Система</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/dev/sdd1            2048   629147647   314572800    5  Расширенный</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/dev/sdd2       629149696   746337195    58593750   83  Linux</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/dev/sdd3       746337196   863525803    58594304   83  Linux</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">/dev/sdd4       863525804   976773167    56623682   83  Linux</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">/dev/sdd5            2111    62504095    31250992+  82  Linux своп / Solaris</span> </p>
    <p class="Textbody">Если опустить аргумент команды, то аналогичные сведения будут выведены для всех физических дисков данной машины: сначала — общая информация о диске, включающая его размер, число головок, секторов и цилиндров, а затем для каждого существующего на диске раздела указываются его первый и последний цилиндры (символом + маркируются разделы, не занимающие последний цилиндр полностью), размер в блоках (физических или заданных опцией b), идентификатор типа файловой системы и его название.</p>
    <p class="Textbody">Для каких-либо манипуляций с дисковыми разделами команду fdisk следует запустить в интерактивном режиме:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># fdisk /dev/sdd</span> </p>
    <p class="Textbody">Что можно сделать без всяких опций, но вот указание аргумента тут будет обязательным.</p>
    <p class="Textbody">После этого мы получаем в свое распоряжение некий интерфейс, требующий ввода определенной команды, исполнение которой сводится к ответу на несколько вопросов. С полным списком доступных команд можно ознакомиться благодаря прекрасной системе помощи, вызываемой командой m.</p>
    <p class="Textbody">Так, команда p выведет текущий список дисковых разделов с указанием их типа и размера. Далее, разделы можно создавать (командой n) или удалять (командой d), однако до команды записи изменений (w) никаких необратимых действий, могущих разрушить ранее существовавшую разметку (и, соответственно, файловые системы и данные, к ней привязанные), не последует: неудачно созданные разделы можно удалить и на их месте создать новые. И в любой момент командой q можно без всяких последствий выйти из программы.</p>
    <p class="Textbody">При создании раздела средствами fdisk сначала определяется, будет он первичным (primary) или расширенным (extended). Рассмотрим сначала первый случай. При нем далее просто указывается номер раздела (от 1 до 4). В этих пределах номер может быть любым — можно сначала создать раздел 2, а потом 1, или даже весь диск отвести под раздел 4. Номер раздела останется на века: именно он будет идентифицировать файл устройства, соответствующий созданному разделу (например, /dev/sda2, или /dev/sdb1).</p>
    <p class="Textbody">Далее задается начальный цилиндр создаваемого раздела (по умолчанию - первый свободный, для пустого диска — просто первый). Однако никто не мешает указать любой другой цилиндр в качестве стартового (на неразбитом пространстве, разумеется). А потом — конечный цилиндр (по умолчанию — последний физический на неразбитом дисковом пространстве), или просто размер раздела в каких-либо общепринятых единицах измерения информации, например, +300M; и +, и M (или что-либо аналогичное) — обязательны, иначе объём диска окажется равных ровно трёхстам цилиндрам.</p>
    <p class="Textbody">В современных версиях  fdisk возможно указание объёма в двух системах единиц (не считая цилиндров). Во-первых, он может задаваться в том, что мы испокон веков привыкли называть мегабайтами и гигабайтами, то есть степенях двойки. Однако ныне авторитетные товарищи утверждают, что такие единицы измерения должны величаться мебибайтами, гибибайтами и так далее. Их следует указывать так: +1000MB, +10GB и так далее.</p>
    <p class="Textbody">А можно определять объём раздела и в «настоящих», с точки зрения пуристов от метрологии, мегабайтах и гигабайтах, представляющих собой  собой степени десятки — тех, в которых производители жёстких дисков издревле указывают размеры своей продукции. И тогда он определяется таким образом: +1000M, +10G etc.</p>
    <p class="Textbody">При задании размера в единицах, отличных от цилиндров, он всегда будет округляться (по обычным правилам округления) до ближайшего числа, кратного целому количеству последних. Так что не следует удивляться, если вместо искомого раздела в 20 Мбайт возникнет 16-мегабайтный, а вместо 22-мегабайтного — раздел в 24 Мбайт.</p>
    <p class="Textbody">При создании расширенного раздела сначала все происходит точно также — задание номера (очевидно, что в том же диапазоне 1--4), указание начального цилиндра и конечного (или — объёма в мегабайтах). Однако это ещё полдела, нужно поделить расширенный раздел на разделы логические. И потому при следующей команде на создание раздела нам будет предложен уже выбор между первичным (если число последних ещё не исчерпано) и логическим (ведь второй extended-раздел средствами fdisk создать нельзя):</p>
    <p class="Textbody"><span style="background-color:#dddddd">Command (m for help): n</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Command action</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">   l   logical (5 or over)</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">   p   primary partition (1-4)</span> </p>
    <p class="Textbody">Дальше же логический раздел создается аналогично первичному.</p>
    <p class="Textbody">Для каждого вновь создаваемого средствами fdisk раздела (первичного или логического) по умолчанию устанавливается идентификатор типа файловой системы Linux native (83 в шестнадцатеричном исчислении). Расширенный же раздел также автоматически получает правильный идентификатор своего типа — 5. Однако типы эти не есть нечто неизменное. Более того, по крайней мере в одном случае, при создании раздела подкачки, изменение типа раздела — необходимость. Это потребуется также и для использования таких технологий, как Software RAID или LVM, о которых будет говориться позднее.</p>
    <p class="Textbody">Делается это командой t, после чего запрашивается номер раздела, тип которого должен быть изменен, а затем — идентификатор желаемого типа. Полный список поддерживаемых типов файловых систем (и их идентификаторов) можно вывести командой l. Напомню, что идентификатор типа файловой системы раздела — отнюдь не файловая система, которая на нем размещается. И на разделе Linux native, как это подчеркивает название, можно создать любую файловую систему из числа тех, которые поддерживаются Linux в качестве родных (ext2/ext3, ext4, XFS, ReiserFS, JFS, btrfs, NILFS2).</p>
    <p class="Textbody">Теоретически fdisk позволяет присвоить созданному разделу идентификатор типа почти любой из мыслимых файловых систем — от FAT12 до Free-, Open- и NetBSD. Однако сами по себе файловые системы средствами fdisk не создаются, и потому для разделов любого типа в дальнейшем потребуется их форматирование специальными командами типа mkfs, о которых будет говориться в соответствующей рубрике.</p>
    <p class="Textbody">Сказанного, надеюсь, достаточно, чтобы осознать великое достоинство fdisk — исключительную гибкость: можно определить раздел строго определенного размера и точно позиционировать его на диске. Или зарезервировать в любом месте накопителя неразбитое пространство, с двух сторон окруженное созданными разделами.</p>
    <p class="Textbody">Сложность же применения fdisk — кажущаяся: благодаря системе подсказки дисковые разделы создаются легко и непринуждённо. Тем не менее, если таки она удручает своей недостаточной наглядностью, можно воспользоваться утилитой cfdisk с меню-ориентированным интерфейсом.</p>
    <h4 id="toc209"><a id="RefHeading18601713816058"></a><a id="bkmRefHeading18601713816058"></a><a id="toc208"></a><a id="bkmtoc208"></a><a id="RefHeading6661136957987"></a><a id="bkmRefHeading6661136957987"></a><a id="bkmRefHeading6661136957987"></a><a id="bkmbkmRefHeading6661136957987"></a>Утилита cfdisk</h4>
    <p class="Textbody">Как уже говорилось, утилита fdisk часто оказывает устрашающее действие на начинающих пользователей. И потому, идя навстречу их невысказанным пожеланиям, Кевин Мартин (Kevin E. Martin) написал к ней консольный фронт-энд с меню-ориентированным интерфейсом, получивший имя cfdisk.</p>
    <p class="Textbody">Утилита cfdisk описывается в литературе гораздо реже, хотя традиционно она считается более удобной, чем fdisk — впрочем, это субъективно и зависит от привычки.</p>
    <p class="Textbody">Запустить cfdisk можно одноименной командой, с указанием имени дискового устройства в качестве аргумента:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># cfdisk /dev/sdb</span> </p>
    <p class="Textbody">Если аргумент в командной строке опущен — по умолчанию команда будет исполнена для первого физического диска машины.</p>
    <p class="Textbody">Разумеется, для использования утилиты требуются права администратора. Если попытаться запустить её от лица обычного пользователя — программа стартует с сообщением. А после запуска программы (в консоли или окне терминала) мы видим следующую картину:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_193.png">
        <img alt="Изображение540" class="frameGraphics" id="540graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_193-572x376.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:377.83057px" />
      </a>
      <a id="a542graphic"></a>
      <a id="bkm542graphic"></a>
    </p>
    <p class="Textbody">На ней выводится информация о диске, первом физическом или том, что был указан в качестве аргумента (имя файла устройства, размер, число головок, секторов, цилиндров), таблица существующих разделов (если, кончено, они действительно существуют) и меню из следующих пунктов: Bootable, Delete, Help, Maximize, Print, Quit, Type, Units, Write. Это — для диска с существующими разделами. Если же диск не разбит (или в таблице разделов курсор зафиксирован на неразбитом пространстве), меню ограничивается пунктами Help, New, Print, Quit, Units, Write.</p>
    <p class="Textbody">Смысл пунктов, думаю, понятен из их названий, как и возможности программы вообще. Замечу лишь, что здесь, как и в fdisk, до выбора пункта Write (в котором будет запрошено подтверждение действия) никаких необратимых изменений не происходит: через Quit всегда можно покинуть программу без боязни за существующие разделы и данные на них.</p>
    <p class="Textbody">И ещё: по умолчанию размеры разделов в таблице указаны в тех мегабайтах, к которым мы привыкли — 220 байт, которые, как нынче считается, положено называть мебибайтами. Однако через пункт Units (сиречь единицы измерения) можно переключиться на показ его в секторах или цилиндрах. Для создания раздела выбирается пункт New, выводящий подменю: Primary, Logical, Cancel.</p>
    <p class="Textbody">После выбора типа раздела просто задается желаемый его размер (в мегабайтах) и запрашивается, приписать ли раздел к началу диска или его концу. А потом остается только сохранить разбиение в таблице разделов выбором пункта Write (повторяю, с запросом подтверждения, и не просто как y, а вводом полного слова yes — дабы дать дополнительные мгновения на раздумье).</p>
    <p class="Textbody">Таким образом, все происходит почти также, как в fdisk. Это и не удивительно: cfdisk по сути лишь интерфейсная для fdisk оболочка. Хотя cfdisk несколько менее гибок: например, раздел в середине неразбитого дискового пространства создать нельзя.</p>
    <h4 id="toc210"><a id="RefHeading18621713816058"></a><a id="bkmRefHeading18621713816058"></a><a id="toc209"></a><a id="bkmtoc209"></a><a id="RefHeading6681136957987"></a><a id="bkmRefHeading6681136957987"></a><a id="bkmRefHeading6681136957987"></a><a id="bkmbkmRefHeading6681136957987"></a>Утилиты форматирования</h4>
    <p class="Textbody">Утилит для форматирования в Linux существует столько же, сколько и поддерживаемых её ядром файловых систем: чтобы убедиться в этом, достаточно набрать в командной строке mkfs и нажать Enter, что даст примерно такую картину:</p>
    <p class="Textbody"><span style="background-color:#dddddd">mkfs           mkfs.ext2      mkfs.ext4dev   mkfs.minix     mkfs.reiserfs</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">mkfs.bfs       mkfs.ext3      mkfs.fat       mkfs.msdos     mkfs.vfat</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">mkfs.cramfs    mkfs.ext4      mkfs.jfs       mkfs.ntfs      mkfs.xfs</span> </p>
    <p class="Textbody">И это — оглашение не всего списка: его легко поплнить установкой пакетов поддержки таких файловых систем, как nilfs, f2fs и других, о которых я и не слыхал.</p>
    <p class="Textbody">Зато из данного списка становится очевидным, как выполнять форматирование: достаточно дать команду на создание желаемой файловой системы и имя файла устройства (то есть дискового раздела) в качестве её аргумента, например:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo mkfs.ext4 /dev/sdg1</span> </p>
    <p class="Textbody">Как легко догадаться, конечно же, команда даётся от имени root'а. А результатом её работы будет создание на указанном разделе файловой системы ext4fs.</p>
    <p class="Textbody">Можно ограничиться и универсальной командой mkfs — но в этом случае, кроме аргумента, потребуется ещё и опция -t с явным указанием файловой системы. Прочие опции всего семейства команд mkfs специфичны для отдельных файловых систем, и говорить о них тут не будем. Как воздержимся и от обсуждения вопроса, какая из файловых систем — самая рассмая и гарантирующая своему применителю счастие немыслимое.</p>
    <h3 id="toc211"><a id="RefHeading18641713816058"></a><a id="bkmRefHeading18641713816058"></a><a id="toc210"></a><a id="bkmtoc210"></a><a id="RefHeading6701136957987"></a><a id="bkmRefHeading6701136957987"></a><a id="bkmRefHeading6701136957987"></a><a id="bkmbkmRefHeading6701136957987"></a>Про графические морды и особенно про GNOME Disks</h3>
    <p class="Textbody">Как уже говорилось, средств для управления носителями и разделами для них в Linux'ах немало. И если большинство применителей «со стажем» используют в этих целях набор специализированных утилит командной строки, то применители начинающие отдают предпочтение графическим фронт-эндам, интегрирующим функционал всех перечисленных инструментов. Впрочем, последними не брезгуют и те из опытных применителей, кто не одержим фанатизмом и уже переболел детской болезнью крутизны. Среди таких фронт-эндов наибольшую известность и распространение получила программа GParted. Она же применятся обычно во всякого рода Live-дистрибутивах ремонтно-спасательной ориентации, вроде Parted Magic и GParted Live.</p>
    <p class="Textbody">Автор этих строк тоже не пренебрегал программой GParted, когда ему требовалось разметить какой-либо носитель на скорую руку (или когда просто лениво было обращаться к инструментам CLI). Однажды, уже в бытность применителем Mint, такая потребность возникла у него в очередной раз. И потому он собрался обратиться к <span style="text-decoration:line-through">знакомым пистолетам</span> знакомому и привычному фронт-энду. Однако следствие показало, что в Mint 17 таковой в штатном комплекте отсутствует. А вместо него предлагается некий gnome-disks, фигурирующий в разделе Стандартные главного меню Cinnamon'а под простым именем — Диски. Хотя доустановить GParted из репозитория труда бы не составило, я решил опробовать этот инструмент. Ибо до сих пор только слыхал о нём — и не лучшие отзывы. В частности, что в последних его версиях отказались от поддержки softRAID, мотивируя обычным для GNOMEделателей аргументом: Народу это не нужно.</p>
    <p class="Textbody">Забегая вперёд, скажу, что опасения по части softRAID оказались не напрасными: в том варианте, в котором gnome-disks присутствует в Mint'е, он позволяет создавать разделы с данным идентификатором — и ничего более. Для дальнейших действий приходится всё равно обращаться к утилите mdadm, но это будет следующим номером нашей программы.</p>
    <p class="Textbody">Однако начну по порядку. Запустить gnome-disks можно или через CLI, одноимённой командой, или из меню. Обращаю внимание — в отличие от GParted, пароль пользователя в момент запуска не запрашивается: его спросят только перед выполнением действий, которые на самом деле требуют привилегий администратора.</p>
    <p class="Textbody">Будучи запущенным на моём десктопе, gnome-disks показывает следующую картину:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_194.png">
        <img alt="Изображение541" class="frameGraphics" id="541graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_194-572x433.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:434.82584px" />
      </a>
      <a id="a543graphic"></a>
      <a id="bkm543graphic"></a>
    </p>
    <p class="Textbody">Что соответствует реалиям моей дисковой подсистемы, в детали описания которой я сейчас вдаваться не буду — задача, как уже было сказано, передо мной стояла очень частная. Отмечу только, что, вопреки опасениям, мой программный RAID был распознан, и для него были доступны некоторые манипуляции, типа добавления или удаления разделов. Чего я, по понятным причинам, не делал. Но пару слов о возможностях программы вообще скажу.</p>
    <p class="Textbody">Шестерёнка в правом верхнем углу — вызов главного меню gnome-disks, которое выглядит так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_195.png">
        <img alt="Изображение542" class="frameGraphics" id="542graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_195.png" style="border:1.0px solid #000080;padding:0;width:481.84317px;height:274.8384px" />
      </a>
      <a id="a544graphic"></a>
      <a id="bkm544graphic"></a>
    </p>
    <p class="Textbody">Пара сцепленных шестерёнок ниже графика распределения диска по разделам вызывает очень похожее, хотя и не идентичное, меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_196.png">
        <img alt="Изображение543" class="frameGraphics" id="543graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_196.png" style="border:1.0px solid #000080;padding:0;width:425.83057px;height:301.82425px" />
      </a>
      <a id="a545graphic"></a>
      <a id="bkm545graphic"></a>
    </p>
    <p class="Textbody">Смысл всех пунктов обоих меню интуитивно понятен. Следует только учесть, что пункты «верхнего» меню соответствуют манипуляциям над дисками в целом, «нижнего» — над его разделами. Этим и объясняются некоторые различия в этих меню: очевидно, что SMART не имеет смысла для раздела, а изменение параметров монтирования — для диска в целом. Кроме того, пункты, именованные в обоих меню одинаково, выполняют разные действия. Так, Форматирование из «верхнего» меню — ни что иное, как создание таблицы разметки диска (варианты — в стиле MSDOS или GPT):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_197.png">
        <img alt="Изображение544" class="frameGraphics" id="544graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_197-572x167.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:168.8227px" />
      </a>
      <a id="a546graphic"></a>
      <a id="bkm546graphic"></a>
    </p>
    <p class="Textbody">А одноимённый пункт из меню «нижнего» — это действительно создание файловой системы на разделе:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_198.png">
        <img alt="Изображение545" class="frameGraphics" id="545graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_198-572x261.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:262.85733px" />
      </a>
      <a id="a547graphic"></a>
      <a id="bkm547graphic"></a>
    </p>
    <p class="Textbody">Причём через меню предусмотрен выбор только между FAT, NTFS и Ext4 (в том числе с шифрованием):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_199.png">
        <img alt="Изображение546" class="frameGraphics" id="546graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_199-572x261.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:262.85733px" />
      </a>
      <a id="a548graphic"></a>
      <a id="bkm548graphic"></a>
    </p>
    <p class="Textbody">Названия прочих файловых систем следует, выбрав строку <span style="font-weight:bold">Другой</span>, ввести вручную (например, btrfs). Список поддерживаемых файловых систем зависит от установленного в системе инструментария для работы с ними. Например, чтобы отформатировать раздел в JFS, необходимо иметь в установленном виде пакет jfsutils.</p>
    <p class="Textbody">Кстати, поле с именем Название — ни что иное, как метка диска.</p>
    <p class="Textbody">Думаю, понятно, что оба «форматирования» возможны только на отмонтированных носителях и требуют прав администратора. Причём пароль на доступ к оным запрашивается в самый последний момент, после всех подтверждений серьёзности своих намерений.</p>
    <p class="Textbody">Перед этим неплохо бы рассмотреть параметры приводов. В зависимости от типа накопителей, они оказались разными. Так, для SSD информационная панель включала две вкладки — управления питанием</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_200.png">
        <img alt="Изображение547" class="frameGraphics" id="547graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_200-572x274.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:275.85892px" />
      </a>
      <a id="a549graphic"></a>
      <a id="bkm549graphic"></a>
    </p>
    <p class="Textbody">и включения кеша записи:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_201.png">
        <img alt="Изображение548" class="frameGraphics" id="548graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_201-572x274.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:275.85892px" />
      </a>
      <a id="a550graphic"></a>
      <a id="bkm550graphic"></a>
    </p>
    <p class="Textbody">Обе функции по умолчанию отключены. Оно и понятно — для десктопа управление питанием не требуется. А с включением кеширования я решил пока не экспериментировать — ведь речь шла не о тестировании нового накопителя, а о практической работе на реальной машине.</p>
    <p class="Textbody">Для традиционного винчестера на 500 ГБ параметры выглядели так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_202.png">
        <img alt="Изображение549" class="frameGraphics" id="549graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_202-572x294.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:295.85257px" />
      </a>
      <a id="a551graphic"></a>
      <a id="bkm551graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_203.png">
        <img alt="Изображение550" class="frameGraphics" id="550graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_203-572x294.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:295.85257px" />
      </a>
      <a id="a552graphic"></a>
      <a id="bkm552graphic"></a>
    </p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_204.png">
        <img alt="Изображение551" class="frameGraphics" id="551graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_204-572x294.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:295.85257px" />
      </a>
      <a id="a553graphic"></a>
      <a id="bkm553graphic"></a>
    </p>
    <p class="Textbody">Вволю поигравшись с функциями gnome-disks и сделав зарубки на счёт того, какие из них мне могут понадобиться в дальнейшем, я приступил к выполнению поставленной боевой задачи — переразметке экспериментального диска /dev/sdc. Каковой выглядел следующим образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_205.png">
        <img alt="Изображение552" class="frameGraphics" id="552graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_205-572x520.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:521.83057px" />
      </a>
      <a id="a554graphic"></a>
      <a id="bkm554graphic"></a>
    </p>
    <p class="Textbody">Так что первой задачей было удаление некоего «отсебятного» раздела. Для чего, как подсказала мне солдатская смекалка, требовалось нажать кнопку с минусом рядом с кнопкой вызова «нижнего» меню. Что, как и ожидалось, привело к следующему результату:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_206.png">
        <img alt="Изображение553" class="frameGraphics" id="553graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_206-572x520.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:521.83057px" />
      </a>
      <a id="a555graphic"></a>
      <a id="bkm555graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_206.png"> </a>
    </p>
    <p class="Textbody">Та же солдатская смекалка говорила, что нажатие кнопки с плюсиком приведёт к созданию на пространстве, ставшем неразмеченным, нового раздела, который оставалось только определить как расширенный:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_207.png">
        <img alt="Изображение554" class="frameGraphics" id="554graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_207-572x315.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:316.82898px" />
      </a>
      <a id="a556graphic"></a>
      <a id="bkm556graphic"></a>
    </p>
    <p class="Textbody">В результате чего разметка устройства /dev/sdc приобрела такой вид:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_208.png">
        <img alt="Изображение555" class="frameGraphics" id="555graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_208-572x520.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:521.83057px" />
      </a>
      <a id="a557graphic"></a>
      <a id="bkm557graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_208.png"> </a>
    </p>
    <p class="Textbody">Наличные примерно 300 ГБ расширенного раздела я планировал разметить на 5 примерно равных по объёму разделов логических. Что, с помощью той же самой кнопки Плюс, и проделал для первого, предназначенного в будущем для openSUSE Factory, задав ему для определённости соответствующую метку:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_209.png">
        <img alt="Изображение556" class="frameGraphics" id="556graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_209-572x315.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:316.82898px" />
      </a>
      <a id="a558graphic"></a>
      <a id="bkm558graphic"></a>
    </p>
    <p class="Textbody">Далее оставалось проделать ту же процедуру для остальных четырёх логических томов, после чего получилась следующая картина:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_210.png">
        <img alt="Изображение557" class="frameGraphics" id="557graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_210-572x520.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:521.83057px" />
      </a>
      <a id="a559graphic"></a>
      <a id="bkm559graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_210.png"> </a>
    </p>
    <p class="Textbody">Выбором файловых систем я не заморачивался — он будет сделан при инсталляции целевого дистрибутива. А метки для разделов я присвоил или в соответствие с названиями предполагаемых на них систем, либо просто по именам устройств. Для уже созданных (но не смонтированных) разделов (точнее — файловых систем, ибо label — это её аттрибут) метку можно задать через пункт Изменить файловую систему «нижнего» меню:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_211.png">
        <img alt="Изображение558" class="frameGraphics" id="558graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_211.png" style="border:1.0px solid #000080;padding:0;width:274.8384px;height:149.84946px" />
      </a>
      <a id="a560graphic"></a>
      <a id="bkm560graphic"></a>
    </p>
    <p class="Textbody">К слову сказать, через предыдущий пункт того же меню, Изменить раздел, можно задать индентификатор его типа:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_212.png">
        <img alt="Изображение559" class="frameGraphics" id="559graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_212.png" style="border:1.0px solid #000080;padding:0;width:361.84317px;height:183.82741px" />
      </a>
      <a id="a561graphic"></a>
      <a id="bkm561graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_212.png"> </a>
    </p>
    <p class="Textbody">Каковых имеется более чем вдоволь:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_213.png">
        <img alt="Изображение560" class="frameGraphics" id="560graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_213-159x572.png" style="border:1.0px solid #000080;padding:0;width:160.84789px;height:573.83685px" />
      </a>
      <a id="a562graphic"></a>
      <a id="bkm562graphic"></a>
    </p>
    <p class="Textbody">Впрочем, из этого изобилия практически значимы лишь менее полудюжины. Да и делать это для разделов, несущих файловые системы, тем более с данными, не очень рекомендуется. Конечно, изменение идентификатора типа к разрушению файловой системы и потере данных не приведёт, проверено на опыте. Но как будут восприниматься идентификаторы, отличные от Linux'ового 0x83 всякими программами работы с дисками — ведомо только Ахурамазде. А самое главное — это нафиг не нужное занятие.</p>
    <p class="Textbody">Подведу итоги. Сравнивать GParted напрямую с gnome-disks не возьмусь. Но одно преимущество последней утилиты лежит на поверхности: если GParted запрашивает пароль на доступ к административным правам сразу при запуске, то gnome-disks — только непосредственно перед выполнением операций, для которых они на самом деле требуются. Так, просто поглядеть на схему разметки, параметры носителя и его состояние можно в режиме обычного пользователя. Конечно, это не гарантирует от ошибок, которые в деле разметки дисков могут быть критическими, но несколько снижает их вероятность.</p>
    <p class="Textbody">А в целом функционал gnome-disks показался мне вполне достаточным для выполнения всех повседневных практических задач в области работы с дисками, разделами и файловыми системами. И в большинстве обыденных случаев он вполне может заменить комплекс утилит CLI, включая и команду dd для создания образов дисков (кстати, GParted, кажется, делать этого не умеет).  Если, конечно, не требуются какие-то специфические параметры разметки или монтирования — тут специализированные утилиты командной строки вне конкуренции.</p>
    <h2 id="toc212"><a id="RefHeading18661713816058"></a><a id="bkmRefHeading18661713816058"></a><a id="toc211"></a><a id="bkmtoc211"></a><a id="RefHeading13061136957987"></a><a id="bkmRefHeading13061136957987"></a><a id="bkmRefHeading13061136957987"></a><a id="bkmbkmRefHeading13061136957987"></a>Mint и softRAID</h2>
    <p class="Textbody">Теоретически softRAID Level 0 — самый простой способ объединения двух носителей информации, конкретно дисковых разделов. Однако как раз в Mint оказывается, что задействовать его «искаропки», то есть на стадии инсталляции, не получится. Причина проста до банальности: на установочном носителе любой редакции этого дистрибутива отсутствует пакет mdadm, отвечающий ныне за управление программным RAID. Что, однако, не препятствует подключению его в любой момент времени после установки.</p>
    <p class="Textbody">Зачем? Вопрос, нужен ли RAID народу, и если нужен — то какой, да и какие ветви файловой иерархии на нём размещать, я здесь обсуждать не буду, ибо неоднократно высказывался по этому поводу ранее. А потому буду исходить из следующих постулатов:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">народу (в лице одного из его лучших представителей) RAID нужен позарез; </p>
      </li>
      <li>
        <p class="Textbody">он необходим ему в форме softRAID Level 0; </p>
      </li>
      <li>
        <p class="Textbody">размещаться на нём должна ветка /home файлового древа. </p>
      </li>
    </ul>
    <p class="Textbody">Для чего, как нетрудно догадаться, требуется установка пакета mdadm, в ходе которого автоматически выполняется сканирование на предмет наличия softRAID'а. И после рестарта машины нужные модули (raid# и всё, что с ними связано) загружаются автоматически, появляется устройство /dev/md0.</p>
    <p class="Textbody">Теперь остаётся определить устройство /dev/md0 на его законное место — я уже несколько лет держу свои рабочие данные на отдельном носителе (разделе, на пуле ZFS или, как в примере, на программном RAID'е), который монтируется в каталог /home/data. Каковой был немедленно создан, и командой chown ему были присвоены атрибуты принадлежности alv:alv (точнее, 1000:1000 — UID и GID моего главного рабочего пользователя, вне зависимости от того, как его зовут и какова его основная группа). Затем командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo blkid</span> </p>
    <p class="Textbody">для устройства /dev/md0 был определён его UUID, под которым он был вписан в /etc/fstab строкой вида</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">UUID=очень-длинное-бла-бла-бла /home/data ext4 defaults,noatime 0 0</span> </p>
    <p class="Textbody">Разумеется, можно было обойтись и без UUID, занеся RAID под его так называемым именем верхнего уровня, то есть /dev/md0. Но уж раз в Ubuntu и её потомках принято именование устройств по UUID'у — будем придерживаться фирменного стиля.</p>
    <p class="Textbody">Сказанное выше относилось к подключению уже существующего softRAID Level 0. Однако создание последнего «с нуля» ничуть не сложнее. Для начала с помощью одной из утилит, fdisk или cfdisk на каждом из носителей, предназначенных для включения в массив, создаются по разделу. Для обоих следовало устанавливается идентификатор типа файловой системы fd — Linux raid autodetect.</p>
    <p class="Textbody">Эти действия можно проделать с помощью графической утилиты gnome-disks, задав при создании разделов идентификатор их типа вручную, как 0xfd:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_213a.png">
        <img alt="Изображение561" class="frameGraphics" id="561graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_213a-572x220.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:221.84946px" />
      </a>
      <a id="a563graphic"></a>
      <a id="bkm563graphic"></a>
    </p>
    <p class="Textbody">Или, если не обременять память этим сложным шестнадцатеричным числом, выбрать его из списка, выводимого через пункт Изменить раздел, вызываемый «нижней шестерёнкой»:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_213b.png">
        <img alt="Изображение562" class="frameGraphics" id="562graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_213b-441x572.png" style="border:1.0px solid #000080;padding:0;width:442.83844px;height:573.83685px" />
      </a>
      <a id="a564graphic"></a>
      <a id="bkm564graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_213b.png"> </a>
    </p>
    <p class="Textbody">Дальнейшая работа выполняется с помощью утилиты mdadm, которая в моём случае была запущена в такой форме:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo mdadm --create /dev/md0 --auto=yes --level=0 --raid-devices=2 /dev/sd(a,b)2</span> </p>
    <p class="Textbody">Здесь --create (или -C) — субкоманда создания массива, в качестве аргумента которой указывается имя его файла устройства (к этому вопросу я ещё вернусь), --level — определение его уровня (а я уже говорил, что именно нужно народу), --raid-devices — число входящих в массив устройств с указанием их имён (/dev/sda2 и /dev/sdb2). Опция же --auto=yes, как было установлено эмпирическим путём, препятсвует переопределению имени файла RAID-устройства.</p>
    <p class="Textbody">ТПосле создания RAID'а результат своих действий можно проверить таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo mdadm --detail /dev/md0</span> </p>
    <p class="Textbody">Что должно дать примерно такой вывод:</p>
    <p class="Textbody"><span style="background-color:#dddddd">/dev/md0:</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        Version : 1.2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Creation Time : Tue Apr 15 00:06:59 2014</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">     Raid Level : raid0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">     Array Size : 195371008 (186.32 GiB 200.06 GB)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">   Raid Devices : 2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Total Devices : 2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">    Persistence : Superblock is persistent</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">    Update Time : Tue Apr 15 00:06:59 2014</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">          State : clean</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> Active Devices : 2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">Working Devices : 2</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd"> Failed Devices : 0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">  Spare Devices : 0</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">     Chunk Size : 512K</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">           Name : salix:0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">           UUID : a32dc435:25c68870:18fa63ca:010d8910</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">         Events : 0</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">    Number   Major   Minor   RaidDevice State</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">       0       8        2        0      active sync   /dev/sda2</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">       1       8       18        1      active sync   /dev/sdb2</span> </p>
    <p class="Textbody">Вместо субкоманды --detail можно использовать её сокращённую форму -D. И заметка на будущее: все утилиты субкоманды mdadm, даже не выполняющие никаких действий, а только выводящие информацию, требуют прав суперпользователя. Исключение — запрос помощи</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mdadm --help</span> </p>
    <p class="Textbody">и детализирующие его просьбы типа</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ mdadm --create --help</span> </p>
    <p class="Textbody">К слову, в выводе последнего запроса (или из man mdadm) можно узнать о дополнительных опциях, с помощью которых определяются, например, такие параметры, как величина блока «распараллеливания» (Chunk Size), которая теоретически должна влиять на быстродействие (чем больше, тем лучше), Однако сведений, насколько это чувствительно в десктопной обстановке, я не нашёл, и потому положился на умолчание mdadm; как можно видеть из вывода субкоманды -D, оно составляет 512 Кбайт (в старых версиях — 64 Кбайт).</p>
    <p class="Textbody">Завершив создание RAID'а, на нём следует создать файловую систему, например, так:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo mkfs.ext4 /dev/md0</span> </p>
    <p class="Textbody">И обеспечить её монтирование при старте машины, внеся в файл /etc/fstab строку такого вида:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">UUID=очень-длинное-бла-бла-бла /home/data ext4 defaults,noatime 0 0</span> </p>
    <p class="Textbody">Где очень-длинное-бла-бла-бла, как и раньше, определяется командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo blkid</span> </p>
    <p class="Textbody">которая выведет значения UUID для всех наличных накопителей.</p>
    <h2 id="toc213"><a id="RefHeading18681713816058"></a><a id="bkmRefHeading18681713816058"></a><a id="toc212"></a><a id="bkmtoc212"></a><a id="RefHeading13081136957987"></a><a id="bkmRefHeading13081136957987"></a><a id="bkmRefHeading13081136957987"></a><a id="bkmbkmRefHeading13081136957987"></a>Mint и LVM</h2>
    <p class="Textbody">Тема этого очерка образовалась в значительной мере как результат случайности. Которая началась с того, что я стал счастливым обладателем SSD-накопителя производства Crucial MX100 объёмом 512 ГБ, и в результате дисковая подсистема, упакованная внутри моего десктопа, стала выглядеть так:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">вышеупомянутый полутерабайтный Crucial — на первом SATA-разъёме; </p>
      </li>
      <li>
        <p class="Textbody">SanDisk Extreme SSD, 120 Гбайт — на втором; </p>
      </li>
      <li>
        <p class="Textbody">он же, то есть точно такой же — на третьем; </p>
      </li>
      <li>
        <p class="Textbody">традиционный винчестер Seagate ST3500410AS о 500-х гигабайтах — на четвёртом. </p>
      </li>
    </ul>
    <p class="Textbody">Первый SSD в ходе установки Mint 17.1 Rebecca был разбит на три раздела:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">/dev/sda1 объёмом 20 ГБ с файловой системой ext4 под корень файловой иерархии; </p>
      </li>
      <li>
        <p class="Textbody">/dev/sda2 объёмом 10 ГБ, также с ext4 — под каталог будущего пользователя, то есть меня — /home/alv (в домашнем каталоге я храню только dot-файлы и некоторые служебные данные, на что указанного объёма хватало с лихвой); </p>
      </li>
      <li>
        <p class="Textbody">/dev/sda3 на всё оставшееся пространство — без файловой системы и, сооветственно, без точки монтирования. </p>
      </li>
    </ul>
    <p class="Textbody">На обоих SanDisk'ах было создано по разделу, занимающему их целиком (/dev/sdb1 и /dev/sdc1, соответственно), также без файловой системы. Вместе с /dev/sda3 они предназначались для объединения в хренилище моих рабочих данных — организация оного и является предметом данных очерков.</p>
    <p class="Textbody">Винчестер у меня служит для экспериментальных целей, и потому разметка его постоянно меняется, да и к нашей теме не относится. За исключением того, что первые 32 ГБ диска выделены в раздел/dev/sdd1, служащий swap'ом для всех моих систем.</p>
    <p class="Textbody">Очевидно, что организация хранилища из трёх устройств требовала их объединения тем или иным способом. И поначалу напрашивался выбор ZFS: эту систему хранения данных я люблю, более-менее знаю, и включал её поддержку в сборки своих вариантов Mint 17. Однако тут модули ZFS у меня неожиданно с первого раза не собрались. Правда, проблема решилась (благодаря помощи Станислава Шрамко aka stanis, о чём пойдёт речь в следующем очерке), однако, как говорится, осадок остался. Ибо случай этот послужил напоминанием не только о бренности бытия, но и птичьих правах, на которых существует ZFS on Linux.</p>
    <p class="Textbody">В своё время, более десяти лет назад, я очень увлекался технологией LVM, тогда ещё 1-й версии. Потом я это дело забросил по двум причинам. Во-первых, во времена винчестеров с PATA-интерфейсом было очень сложно сконфигурировать многодисковую систему LVM без деградации производительности. Во-вторых, инструментарий CLI для создания такой системы и последующего управления ею показался мне при использовании в «домашних» условиях неоправданно сложным — особенно в сравнении с появившейся вскоре ZFS.</p>
    <p class="Textbody">Ныне, в эпозу безраздельного господства SATA-накопителей, первое препятствие к применению LVM отпало полностью. Что касается второго, то оно во многом сглаживается наличием графических оболочек, изолирующих применителя от низкоуровневых команд. Одну из которых system-config-lvm, я и использовал нынче.</p>
    <p class="Textbody">С тех пор, как я имел дело с LVM, появилась LVM2, предоставляющая ряд дополнительных возможностей, таких, как расширение логического тома на вновь подключённые физические тома. Однако суть технологии, терминология, утилиты CLI для работы с LVM почти не изменились. Да и в сети можно найти много не менее подробных, но более свежих материалов по теме. Так что на этих вопросах останавливаться не буду, ограничившись маленьким терминологическим конспектом.</p>
    <p class="Textbody">Сама по себе система LVM — уровень абстракции между физическими носителями (дисками, их разделами и массивами) и обычными файловыми системами. Она позволяет объединять в логические тома разделы с разных дисков, изменять их размер в сторону увеличения (за счёт присоединения новых накопителей) и, с некоторыми оговорками, уменьшения. В основе её лежит понятие физического тома (PV — Physical volume). Это — обычный дисковый раздел, для которого устанавливается идентификатор типа (ID) 8e. Вопреки написанному в некоторых сетевых материалах, целый диск как raw-устройство типа /dev/sd? в качестве физического тома выступать не может. Другое дело, что созданный на нём раздел с ID 8e может занимать и весь диск и даже RAID, программный или аппаратный.</p>
    <p class="Textbody">Физический том делится на «куски», именуемые физическими экстентами (Physical Extent, PE — по традиции оставлю этот термин без перевода, так как предлагаемый русскоязычной Википедией диапазон может ввести в заблуждение). Это — нечто вроде аналогов физических блоков (секторов) обычного винчестера, их размер по умолчанию 4 МБ, но может быть изменён в обе стороны.</p>
    <p class="Textbody">Физические тома объединяются в группу томов (VG — Volume group), которая выступает как единое целое и может рассматриваться как логическиий аналог raw-накопителя. И, подобно последнему, делится на разделы — поскольку над физикой мы уже поднялись, они назваются логическими томами (LV — Logical volume). А уж те — опять-таки на «куски», которые, как нетрудно догадаться, носят имя логических экстентов (LE — Logical extent). По размеру логический экстент равен экстенту физическому, которому он ставится в соответствие — однозначно, но одним из двух методов:</p>
    <ol style="margin-top:0;margin-bottom:0;list-style-type:decimal;clear:left">
      <li>
        <p class="Textbody">линейным (linear mapping), когда логические экстенты последовательно привязываются к физическим сначала первого физического тома, потом второго, и так далее, подобно линейному режиму RAID; </p>
      </li>
      <li>
        <p class="Textbody">«черезполосным» (striped mapping), при котором «куски» логических экстентов (так называемые блоки чередования, по умолчанию равные 4 КБ) распределяются по физическим экстентам чередующихся физических томов. </p>
      </li>
    </ol>
    <p class="Textbody">Последний метод, сходен с расщеплением данных в RAID Level 0 и, подобно последнему, теоретически способствует быстродействию дисковых операций. При этом очевидно (и важно в контексте дальнейшего развития сюжета), что размер логического тома с чередованием не может быть больше наименьшего из входящих в него томов физических.</p>
    <p class="Textbody">В ходе создания собственного хренилища LVM, оказалось, что существует ещё и метод зеркалирования. Надо полагать, что это некое подобие RAID Level 1. Но, поскольку для меня это не актуально, выяснением деталей не занимался.</p>
    <p class="Textbody">Вне зависимости от метода соответствия логических и физических экстентов, логические тома предназначены для того, чтобы нести на себе файловые системы, подобно обычным дисковым разделам, причём точно те же самые — любые нативные для Linux'а: ext2/ext3/ext4, XFS, ReiserFS, JFS.</p>
    <p class="Textbody">На этом терминологическое введение можно считать законченным — перехожу к описанию действий по организации хранилища данных.</p>
    <p class="Textbody">Пакет LVM2, предоставляющий утилиты CLI для работы с логическими томами, устанавливается в Mint по умолчанию. Однако, как говорилось выше, LVM — не тюрьма народов, и не заставляет применителя её зубрить полсотни команд этого пакета (я почти не преувеличиваю — их там 48). Потому что в репозиториях доступна графическая оболочка, интегрирующая все их функции — system-config-lvm. В скобках замечу, что это не просто самая распространённая «морда» к утилитам lvm2, но и единственная активно развиваемая в настоящее время. Так что перво-наперво её следует установить, что я и проделал:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ apt install system-config-lvm</span> </p>
    <p class="Textbody">После установки программа под именем Управление логическими томами обнаружилась в секции Администрирование главного меню Cinnamon, откуда и была запущена после ввода пароля, демонстрируя в моём случае такую картину:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_214.png">
        <img alt="Изображение563" class="frameGraphics" id="563graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_214-572x325.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:326.84476px" />
      </a>
      <a id="a565graphic"></a>
      <a id="bkm565graphic"></a>
    </p>
    <p class="Textbody">Правда, здесь надо учесть, что перед её запуском я через fdisk установил ID разделов, предназначенных на растерзание LVM, равным 8e. Что в принципе не обязательно — это можно сделать и в графической оболочке, нажав кнопку Инициализировать раздел:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_215.png">
        <img alt="Изображение564" class="frameGraphics" id="564graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_215-572x325.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:326.84476px" />
      </a>
      <a id="a566graphic"></a>
      <a id="bkm566graphic"></a>
    </p>
    <p class="Textbody">Однако сам раздел должен быть создан заблаговременно — зафиксировав курсор на неразмеченном пространстве, можно видеть, что кнопка инциализации просто не активна:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_216.png">
        <img alt="Изображение565" class="frameGraphics" id="565graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_216-572x325.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:326.84476px" />
      </a>
      <a id="a567graphic"></a>
      <a id="bkm567graphic"></a>
    </p>
    <p class="Textbody">Вне зависимости от того, каким способом были инциализированы разделы, первым шагом после этого будет создание группы томов посредством фиксации одного из инициализированных разделов (я сделал это для самого «жирного») и нажатия кнопки Создать новую:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_217.png">
        <img alt="Изображение566" class="frameGraphics" id="566graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_217-572x325.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:326.84476px" />
      </a>
      <a id="a568graphic"></a>
      <a id="bkm568graphic"></a>
    </p>
    <p class="Textbody">В вызываемой её панели достаточно задать какое-либо имя для группы томов, желательно осмысленное, например:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_218.png">
        <img alt="Изображение567" class="frameGraphics" id="567graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_218.png" style="border:1.0px solid #000080;padding:0;width:436.829px;height:237.83685px" />
      </a>
      <a id="a569graphic"></a>
      <a id="bkm569graphic"></a>
    </p>
    <p class="Textbody">Впрочем, можно и изменить размер физического экстента в диапазоне от 2 до 1024 МБ — если, конечно, точно знаете, что это нужно (я — так не уверен, поэтому все остальные параметры оставил умолчальными):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_219.png">
        <img alt="Изображение568" class="frameGraphics" id="568graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_219.png" style="border:1.0px solid #000080;padding:0;width:478.85733px;height:364.82898px" />
      </a>
      <a id="a570graphic"></a>
      <a id="bkm570graphic"></a>
    </p>
    <p class="Textbody">После этого я полюбовался на физический и логический вид группы томов (состоящей пока из одного физического тома, раздела /dev/sda3):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_220.png">
        <img alt="Изображение569" class="frameGraphics" id="569graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_220-572x336.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:337.84314px" />
      </a>
      <a id="a571graphic"></a>
      <a id="bkm571graphic"></a>
    </p>
    <p class="Textbody">После чего занялся добавлением в группу физических томов — то есть в моём случае разделов /dev/sdb1 и /dev/sdc1. Для чего просто указывается группа, в которую надо добавить соотвтетсвующее устройство — поскольку группа у меня одна, то и ломать тут голову не над чем:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_221.png">
        <img alt="Изображение570" class="frameGraphics" id="570graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_221.png" style="border:1.0px solid #000080;padding:0;width:412.82895px;height:225.85576px" />
      </a>
      <a id="a572graphic"></a>
      <a id="bkm572graphic"></a>
    </p>
    <p class="Textbody">По завершении компоновки группы томов она стала выглядеть таким образом:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_222.png">
        <img alt="Изображение571" class="frameGraphics" id="571graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_222-572x336.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:337.84314px" />
      </a>
      <a id="a573graphic"></a>
      <a id="bkm573graphic"></a>
    </p>
    <p class="Textbody">Теперь настал черёд поделить эту группу на логические тома. Оно сводится к</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">определению имени тома (опять таки желательно осмысленного — на следующем скриншоте рассмотрен пример тома для текущих проектов); </p>
      </li>
      <li>
        <p class="Textbody">заданию метода соответствия логических экстентов физическим — в примере «чересполосного»; </p>
      </li>
      <li>
        <p class="Textbody">числа «полос» — поскольку в группе томов участвует три устройства, значение его очевидно; </p>
      </li>
      <li>
        <p class="Textbody">размера блока чередования — я сохранил умолчальные 4 килобайта, но его можно увеличить до 512 КБ (опять же не знаю, нужно ли это): </p>
      </li>
    </ul>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_223.png">
        <img alt="Изображение572" class="frameGraphics" id="572graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_223-502x572.png" style="border:1.0px solid #000080;padding:0;width:503.84003px;height:573.83685px" />
      </a>
      <a id="a574graphic"></a>
      <a id="bkm574graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_223.png"> </a>
    </p>
    <p class="Textbody">Затем я задал размер тома и файловую систему для него — в моей системе доступны ext всех видов и XFS:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_224.png">
        <img alt="Изображение573" class="frameGraphics" id="573graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_224-504x572.png" style="border:1.0px solid #000080;padding:0;width:505.84314px;height:573.83685px" />
      </a>
      <a id="a575graphic"></a>
      <a id="bkm575graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_224.png"> </a>
    </p>
    <p class="Textbody">После чего осталось указать условия монтирования тома точку для оного:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_225.png">
        <img alt="Изображение574" class="frameGraphics" id="574graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_225.png" style="border:1.0px solid #000080;padding:0;width:504.8227px;height:547.8337px" />
      </a>
      <a id="a576graphic"></a>
      <a id="bkm576graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_225.png"> </a>
    </p>
    <p class="Textbody">Нажав OK, я получил сообщение, что и такой точки не существует и предложение её создать, от которого, разумеется, невозможно отказаться:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_226.png">
        <img alt="Изображение575" class="frameGraphics" id="575graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_226.png" style="border:1.0px solid #000080;padding:0;width:444.84158px;height:134.84473px" />
      </a>
      <a id="a577graphic"></a>
      <a id="bkm577graphic"></a>
    </p>
    <p class="Textbody">Тем же манеров был создан том для размещёния виртуальных машин — как мне объяснили резонные люди, для них быстродействие дисковых операций также важно. На этом лимит томов с чередованием у меня был исчерпан, и оставшееся пространство я разделил на два «линейных» тома — под старые, но периодически нужные проекты, и под всякую всячину типа мультимедии:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_227.png">
        <img alt="Изображение576" class="frameGraphics" id="576graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_227.png" style="border:1.0px solid #000080;padding:0;width:504.8227px;height:547.8337px" />
      </a>
      <a id="a578graphic"></a>
      <a id="bkm578graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_227.png"> </a>
    </p>
    <p class="Textbody">После чего физическая и логическая картины моей группы томов стали выглядеть так:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_228.png">
        <img alt="Изображение577" class="frameGraphics" id="577graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_228-572x336.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:337.84314px" />
      </a>
      <a id="a579graphic"></a>
      <a id="bkm579graphic"></a>
    </p>
    <p class="Textbody">Оставалось перезагрузиться (для страховки, можно было заказать и немедленное монтирование томов) и начать заполнять тома данными из бэкапов, разумеется, сделанных до начала не только развлечений с LVM, но и до установки Rebecca.</p>
    <h2 id="toc214"><a id="RefHeading18701713816058"></a><a id="bkmRefHeading18701713816058"></a><a id="toc213"></a><a id="bkmtoc213"></a><a id="RefHeading13101136957987"></a><a id="bkmRefHeading13101136957987"></a><a id="bkmRefHeading13101136957987"></a><a id="bkmbkmRefHeading13101136957987"></a>Mint и ZFS</h2>
    <p class="Textbody">Соедующая серия очерков посвящена ZFS — универсальной системе размещёния данных, интегрирующей в себе собственно файловую систему и технологию управления дисковыми массивами и логическими томами. Если softRAID и LVM посвящено множество сетевых материалов, то тема ZFS в Linux'е (так называемая ZFS on Linux) на русском язые освящена существенно слабее. Поэтому я и решил остановиться на ней подробно.</p>
    <h3 id="toc215"><a id="RefHeading18721713816058"></a><a id="bkmRefHeading18721713816058"></a><a id="toc214"></a><a id="bkmtoc214"></a><a id="RefHeading6721136957987"></a><a id="bkmRefHeading6721136957987"></a><a id="bkmRefHeading6721136957987"></a><a id="bkmbkmRefHeading6721136957987"></a>Общее введение</h3>
    <p class="Textbody">Одна из главнейших задач при работе на компьютере — манипулирование данными: создание, модификация, копирование, перемещёние и так далее. И тут первое — это организация их размещёния. Это понятие включает в себя широкий круг частных вопросов — схемы дисковой разметки, управления дисковыми массивами и логическими томами, файловые системы и их монтирование в файловую иерархию. Они тесно связаны между собой, но традиционно решаются каждая с помощью собственного инструментария.</p>
    <p class="Textbody">Однако в последние годы в Linux’е получили распространение интегрированные системы размещёния данных, объединяющие в себе и файловые системы, и задачи управления массивами и томами, и даже, частично, задачи разметки дисков. Такие системы существовали очень давно — со времен доисторического UNIX’а, но были они проприетарными. ZFS же, разработанная фирмой Sun для своей ОС Solaris, ныне распространяется свободно, под лицензией CDDL. Благодаря чему была портирована на FreeBSD, а в последние годы нативно поддерживается и в Linux’е.</p>
    <p class="Textbody">Именно ZFS on Linux и будет героиней нашего романа, и не только в силу своих несравненных достоинств. А во-вторых, развитие проекта ZFS on Linux блестяще демонстрирует торжество инженерного разума над юридической заумью. И потому являет собой просто замечательный литературный сюжет, мимо которого не в силах пройти ни один сочинитель в жанре технологической новеллы. И начать этот сюжет надо издалека.</p>
    <h3 id="toc216"><a id="RefHeading18741713816058"></a><a id="bkmRefHeading18741713816058"></a><a id="toc215"></a><a id="bkmtoc215"></a><a id="RefHeading6741136957987"></a><a id="bkmRefHeading6741136957987"></a><a id="bkmRefHeading6741136957987"></a><a id="bkmbkmRefHeading6741136957987"></a>Дисковая разметка</h3>
    <p class="Textbody">Говорят, что во времена далекие, теперь почти былинные, файловых систем не было: информация на носители записывалась побитно, без всякой организации в именованные её наборы. Впрочем, такой способ записи данных применялся и много позднее — например, при резервном копировании на стриммерные ленты. Можно обходиться без файловых систем и при записи на стандартные блочные устройства — винчестеры, SSD, компакт-диски.</p>
    <p class="Textbody">Однако в большинстве случаев данные на носителях блочного типа организуются в виде файлов, а файлы объединяются в файловые системы — плоские, как в древнем DOS’е, древовидные, как во всех UNIX-подобных операционках, или, так сказать, «многодревные», как в Windows. Каковые могут быть созданы непосредственно на носителе как raw-устройстве, но обычно накладываются на дисковые разделы.</p>
    <p class="Textbody">Исторически сложилось так, что одному разделу соответствовала одна файловая система. Соответственно, и выходить за границы несущего их устройства файловые системы не могли. И если требовалось работать более чем с одной файловой системой на одном физическом накопителе (а в UNIX-подобных ОС это почти всегда так), то был необходим тщательный расчет дискового пространства для каждой из них: ошибки в расчётах влекли весьма неприятные последствия, вплоть до необходимости переразбиения диска и переустановки ОС вообще.</p>
    <p class="Textbody">Правда, дисковые разделы могут не только разделяться, но и объединяться в программные массивы или в группы томов, о которых говорилось в предыдущих очерках.</p>
    <h3 id="toc217"><a id="RefHeading18761713816058"></a><a id="bkmRefHeading18761713816058"></a><a id="toc216"></a><a id="bkmtoc216"></a><a id="RefHeading6761136957987"></a><a id="bkmRefHeading6761136957987"></a><a id="bkmRefHeading6761136957987"></a><a id="bkmbkmRefHeading6761136957987"></a>Файловые системы</h3>
    <p class="Textbody">Как известно ещё с советских атеистических времен, Господь Бог, создавая человека, хотел сделать его умным, честным и партийным. Но оказалось, что даже он, при всём своём всемогуществе, не смог ему дать больше двух качеств вместе.</p>
    <p class="Textbody">Аналогично и с файловыми системами: разработчики хотели бы видеть их быстрыми, надежными и простыми в обращении. Давайте посмотрим, удалось ли им превзойти Господа.</p>
    <p class="Textbody">В UNIX-подобных системах требование быстродействия удовлетворяется, во-первых, оптимизированным расположением каталогов, метаданных и данных файлов на физических носителях. Но во-вторых и главных — кэшированием записи.</p>
    <p class="Textbody">Думаю, каждого, кто начинал знакомство с Linux’ом во времена безраздельного господства файловой системы ext2fs, поражала быстрота выполнения всех файловых операций, обусловленная их асинхронностью — то есть кэшированием данных и метаданных. Оборотная сторона медали — отказ системы по любой причине влёк за собой тяжкие последствия, вплоть до полного ее разрушения. Но и даже когда до полной катастрофы дело не доходило, отказы (например, по питанию) вызывали за собой долгую и нудную процедуру проверки целостности файловой системы.</p>
    <p class="Textbody">Были разработаны различные механизмы решения этой проблемы. Однако основным в Linux стало так называемое журналирование, когда сведения о файловых операциях записываются в специальный файл журнала до того, как эти операции будут фактически выполнены. Это дает возможность после любого сбоя «откатить» файловую систему до последнего непротиворечивого состояния. Оборотной стороной чего, как обычно, является снижение быстродействия — различное для отдельных файловых систем и видов файловых операций.</p>
    <p class="Textbody">Правда, с точки зрения простоты использования ни в одну из файловых систем Linux’а бросить камень рука не подымется: создание и монтирование их никаких трудностей не сулит. Так что требование «партийности» выполняется, пожалуй, при всех соотношениях «ума» и «честности». Но эта ситуация сохраняется, пока мы не начинаем комбинировать «ум, честность и партийность» файловых систем с аналогичными качествами систем управления RAID’ами или с LVM. В результате чего получаем:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">либо быстрое и относительно простое решение на основе RAID Level 0, не блещущее надёжностью; </p>
      </li>
      <li>
        <p class="Textbody">либо надёжное решение без ощутимой потери быстродействия на основе одного из RAID с избыточностью, не являющееся, однако, эталоном простоты; </p>
      </li>
      <li>
        <p class="Textbody">либо, наконец, относительно надёжное и потенциально быстрое решение при использовании технологии LVM — однако и оно не блещёт простотой. </p>
      </li>
    </ul>
    <p class="Textbody">Ибо все эти решения — многоуровневые. И очевидно, что удлинение «цепочки» уровней в любом случае приводит к снижению надежности: чем больше в ней звеньев, тем вероятней отказ всей цепи.</p>
    <p class="Textbody">И тут-то и возникает вопрос: а нельзя ли уменьшить количество уровней, сделать систему более «плоской»? И системы размещёния данных, в том числе и ZFS — попытка ответа на него.</p>
    <h3 id="toc218"><a id="RefHeading18781713816058"></a><a id="bkmRefHeading18781713816058"></a><a id="toc217"></a><a id="bkmtoc217"></a><a id="RefHeading6781136957987"></a><a id="bkmRefHeading6781136957987"></a><a id="bkmRefHeading6781136957987"></a><a id="bkmbkmRefHeading6781136957987"></a>Из истории систем размещёния</h3>
    <p class="Textbody">Не в интересах правды, а истины ради нужно заметить, что ZFS была отнюдь не первой комплексной системой размещёния данных — хотя её исторические предшественницы также именовались просто файловыми системами.</p>
    <p class="Textbody">Первой из таких предшественниц была, видимо, файловая система Veritas (или VxFS), разработанная фирмой Veritas Software и представленная миру в 1991 году. Она же претендует на звание первой в истории мироздания журналируемой файловой системы. Хотя, насколько мне известно, JFS — эпоним всех журналируемых ФС — в своей реализации для AIX появилась в 1990 году, так что вопрос приоритета остаётся не вполне ясным.</p>
    <p class="Textbody">VxFS была основной файловой системой в HP UX, работает также во всех ныне живущих проприетарных UNIX’ах и теоретически может использоваться в Linux’е. Однако о практических примерах последнего я не слышал: VxFS является системой проприетарной и весьма дорогой.</p>
    <p class="Textbody">VxFS тесно интегрирована с менеджером логических томов — VxVM. Благодаря чему в ней возможно изменение (в любую сторону) размера файловой системы «на лету», включение различных режимов использования томов — стриппинг данных, их зеркалирование, а также комбинации того и другого, создание избыточных массивов по типу RAID Level 5, изменение внутренней организации данных без остановки работы. Всё это позволяет VxFS (в сочетании с VxVM) претендовать на звание комплексной системы размещёния данных.</p>
    <p class="Textbody">Впрочем, не меньше к тому оснований было и у AdvFS — файловой системы, разработанной к 1993 году фирмой DEC для своего проприетарного варианта UNIX, именовавшегося сначала OSF/1, затем Digital UNIX, и завершившего свою жизнь под именем Tru64 UNIX. Судьба её была печальной. Снискав заслуженное признание на своей родной платформе DEC Alpha под управлением указанной ОС, она после покупки DEC фирмой Compaq оказалась в загоне. А после того, как Compaq, в свою очередь, был поглощён фирмой Hewlett Packard, использовавшей для своего UNIX’а на платформах HP PA и Itanium только что упомянутую VxFS, AdvFS оказалась совсем не при делах.</p>
    <p class="Textbody">В результате HP сделала щедрый дар сообществу свободного софта вообще и Linux-сообществу в особенности: в середине 2008 года исходники файловой системы AdvFS были открыты под лицензией GPv2 — ради максимальной совместимости с ядром Linux. С предложением использовать их в качестве богатой технологической базы для этой ОС. Правда, оговорка, что сама HP не заинтересована в дальнейшем развитии AdvFS заставляла вспомнить народную присказку: «Возьми, боже, что мне не гоже».</p>
    <p class="Textbody">Да и предложение несколько запоздало: как мы скоро увидим, к тому времени интенсивно развивались и ZFS, и btrfs.</p>
    <p class="Textbody">Однако, помимо исходников, HP предоставила также доступ ко всей документации — благодаря чему об AdvFS при желании можно узнать больше, чем о любой другой проприетарной файловой системе для UNIX-подобных операционок. Это избавляет меня от необходимости описания особенностей AdvFS. Замечу только, что среди них мы увидим все черты развитой комплексной системы размещёния данных. Те самые, с которыми ознакомимся, когда дело дойдёт наконец до рассмотрения устройства ZFS. Но для начала перейдём к обзору уже её истории.</p>
    <h3 id="toc219"><a id="RefHeading18801713816058"></a><a id="bkmRefHeading18801713816058"></a><a id="toc218"></a><a id="bkmtoc218"></a><a id="RefHeading6801136957987"></a><a id="bkmRefHeading6801136957987"></a><a id="bkmRefHeading6801136957987"></a><a id="bkmbkmRefHeading6801136957987"></a>Начало истории ZFS</h3>
    <p class="Textbody">Разработчики ZFS поставили себе честолюбивую цель: создать систему хранения данных, которая отвечала бы всем трем критериям идеала. Разработка её проводилась в компании Sun Microsystems, командой под руководством Джеффа Бонвика и Мэттью Аренса (Matthew Ahrens). Первоначально название ZFS рассматривалось как аббревиатура от Zettabyte File System, но быстро стало просто условным именованием. Его можно интерпретировать как последнюю точку в развитии файловых систем вообще. И в последующем мы увидим: это недалеко от истины.</p>
    <p class="Textbody">Результаты работы над ZFS были представлены миру в августе 2004 года. А в 2006 году она была включена в штатный состав OS Solaris 10 (релиз 6/06). То есть, подобно своим предшественницам, она также была проприетарным продуктом. И пользователям свободных UNIX-подобных систем поначалу от ее существования было ни холодно, ни жарко. Однако период камерного существования ZFS продолжался недолго — уже в ноябре 2005 года, то есть до включения в Solaris, ее поддержка была интегрирована в открытый её вариант, OpenSolaris. Ибо она основывалась на том же ядре SunOS 5, что и коммерческий прототип.</p>
    <p class="Textbody">Исходники ZFS распространяются, как и собственно OpenSolaris, под лицензией CDDL (Common Development and Distribution License). Эта лицензия, базирующаяся на Mozilla Public License (MPL), не влияет на общую лицензию проекта, в состав который включены CDDL-компоненты. И потому оказывается совместимой с большинством свободных лицензий. За исключением... какой? Правильно, GPL во всех её проявлениях.</p>
    <p class="Textbody">Разумеется, ZFS была задействована в клонах openSolaris, таких, как BeleniX, SchilliX и, в первую голову, в Nexenta OS. Правда, последняя развивалась в направлении коммерческой системы хранения данных, а о числе пользователей остальных можно было только гадать.</p>
    <p class="Textbody">Некоторое время ZFS была доступна пользователям Macintosh’а — в Mac OS X Leopard от осени 2007 года. Правда, ходившие перед её выходом слухи, что она будет там файловой системой по умолчанию, оказались несколько преувеличенными: поддержка ZFS оказалась опциональной и лишь в режиме «только для чтения». А в последующих версиях семейства кошачьих вообще исчезла и, видимо, уже не возродится.</p>
    <p class="Textbody">Так что для широких народных масс ZFS по прежнему оставалась недоступной. Пока... пока ее не портировали под FreeBSD в 2007 году, и официально не включили её поддержку в 7-ю версию этой ОС, вышедшую в начале 2008 года. В чём, как и в дальнейшем её развитии, основная заслуга принадлежит Павлу-Якубу Давидеку (Pawel Jakub Dawidek) и Ивану Ворасу (Ivan Voras). Правда, до недавнего времени ZFS нельзя было задействовать при установке FreeBSD средствами её штатного инсталлятора и конфигуратора sysinstall. Однако это без труда можно было осуществить в дальнейшем руками. В том числе и разместить на ZFS корень файловой иерархии.</p>
    <p class="Textbody">С самого начала поддержки ZFS во FreeBSD появилась и возможность задействовать её, что называется, «искаропки», в десктоп-ориентированном клоне последней — PC-BSD. А с переходом FreeBSD, начиная с версии 9.0, на новую программу установки — BSDInstall, эта функция распространилась и на материнскую систему.</p>
    <p class="Textbody">Успех ZFS во FreeBSD, где она стала если не главной файловой системой, то добилась равноправия с UFS2, послужил примером для других BSD-систем. Так, ныне ZFS поддерживается в NetBSD — эта работа была начата Оливером Голдом (Oliver Gould) летом 2007 года в рамках акции Google Summer of Code. А в 2009 году Адам Хамсик (Adam Hamsik) интегрировал её код в ядро NetBSD. Правда, использование ZFS в этой операционке рекомендуется только в экспериментальных целях.</p>
    <p class="Textbody">Наконец, одно время в списках рассылки DragonFlyBSD активно обсуждался вопрос о портировании ZFS и на эту операционку. Потом, правда, разговоры эти стихли — вероятно, в связи с активной разработкой файловой системы Hammer, обладающей во многом аналогичными возможностями. Однако, учитывая лёгкость адаптации к DragonFlyBSD любых сторонних файловых систем, можно не сомневаться, что поддержка ZFS на уровне обмена данными будет включена в неё тогда и если (или если и тогда), когда (и если) это кому-то понадобится.</p>
    <p class="Textbody">Таким образом, пользователям большинства BSD-систем ZFS или уже доступна как нативная, или может стать доступной в ближайшее время.</p>
    <h3 id="toc220"><a id="RefHeading18821713816058"></a><a id="bkmRefHeading18821713816058"></a><a id="toc219"></a><a id="bkmtoc219"></a><a id="RefHeading6821136957987"></a><a id="bkmRefHeading6821136957987"></a><a id="bkmRefHeading6821136957987"></a><a id="bkmbkmRefHeading6821136957987"></a>Из истории юриспруденции</h3>
    <p class="Textbody">А что же Linux, спросите вы меня? Как обстоит дело с поддержкой ZFS в самой массовой из свободных UNIX-подобных операционных систем нашего времени? А вот с Linux’ом все оказывается гораздо сложнее. Ибо не зря поминали мы выше лицензию CDDL. Которая сама по себе очень даже свободная, и не накладывает почти никаких ограничений на распространение защищаемых ею программ.</p>
    <p class="Textbody">В частности, не запрещает CDDL и коммерческого распространения производных продуктов в виде бинарников, без открытия исходных текстов. Как известно, не накладывает такого ограничения и лицензия BSD, почему включение кода поддержки ZFS в любые BSD-системы и проходит юридически безболезненно, как мы только что видели на примере FreeBSD.</p>
    <p class="Textbody">А вот с лицензией GPL обеих актуальных версий (v2 и v3) CDDL входит в диалектическое противоречие. Ибо любые продукты, производные от программ под GPL, вне зависимости от формы распространения, должны сопровождаться исходными текстами. Что делает юридически невозможным включение кода поддержки ZFS непосредственно в ядро Linux, распространяемое, как известно, на условиях GPLv2.</p>
    <p class="Textbody">Кроме того, невозможность включения в ядро Linux кода поддержки ZFS объясняется тем, что GPL требует распространения всех основанных на ней продуктов под GPL же, тогда как CDDL — сохранения её для «своих» компонентов.</p>
    <p class="Textbody">Правда, часть кода ZFS была открыта под GPL с тем, чтобы соответствующий патч можно было включить в загрузчик GRUB. Это обеспечило возможность загрузки Open Solaris непосредственно с ZFS-раздела. Однако оказалось недостаточным для полноценной реализации этой системы, которую можно было бы распространять под данной лицензией.</p>
    <p class="Textbody">Впрочем, не будучи юристом, ломать голову над лицензионными вопросами не буду, и моим читателям не советую, ибо понять это всё равно невозможно. А достаточно лишь запомнить, что всеми резонными и юридически подкованными людьми признано, что поддержки ZFS в ядре Linux быть не может.</p>
    <p class="Textbody">Таким образом, сложилась абсурдная, с точки зрения здравого смысла, ситуация: два программных продукта под свободными лицензиями (обсуждать вопрос, какая из них «свободней другой», мы сейчас не будем), созданные друг для друга, как Huggies и... э-ээ... место пониже спины (дальнейшие события показали, что технических сложностей при портировании ZFS на Linux практически нет), невозможно было использовать в составе одного проекта. По крайней мере, для законопослушных граждан, чтущих... нет, не уголовный кодекс, а принципы свободного программного обеспечения.</p>
    <p class="Textbody">И, разумеется, здравомыслящие люди попытались эту ситуацию разрешить. И первая такая попытка была предпринята ещё в 2006 году в рамках Google Summer of Code. Основывалась она на поддержке ZFS через FUSE (Filesystem in Userspace). Поскольку модуль FUSE работает как пользовательское приложение, необходимости во включение кода ZFS в ядро Linux нет, что снимает все юридические вопросы. Однако встают вопросы другие — производительности и устойчивости.</p>
    <p class="Textbody">Проект ZFS-FUSE развивается по сей день, хотя и не очень быстрыми темпами. Правда, находясь в стадии хронической бета-версии, он до сих пор рассматривается как сугубо экспериментальный. Да и в любом случае в таком виде ZFS выполнять свои функции — быть надёжным хранилищем данных большого объёма — скорее всего, не сможет.</p>
    <p class="Textbody">Так что ZFS-FUSE нельзя считать кардинальным решением вопроса с этой системой размещёния данных в Linux.</p>
    <h3 id="toc221"><a id="RefHeading18841713816058"></a><a id="bkmRefHeading18841713816058"></a><a id="toc220"></a><a id="bkmtoc220"></a><a id="RefHeading6841136957987"></a><a id="bkmRefHeading6841136957987"></a><a id="bkmRefHeading6841136957987"></a><a id="bkmbkmRefHeading6841136957987"></a>Появление героини</h3>
    <p class="Textbody">И тем не менее, решение этой проблемы нашлось — и решение столь же изящное, сколь и очевидное. Его предложил весной 2010 года Брайан Белендорф, некогда один из основных разработчиков web-сервера Apache. Он создал модуль поддержки ZFS, который собирается и может распространяться отдельно от ядра, сохраняя прародительскую лицензию CDDL. А поскольку последняя, как уже говорилось, является лицензией «пофайловой», этим самым обходится антагонистическое противоречие — запрет на распространение продуктов, в которых смешан код, лицензируемый под CDDL и GPL.</p>
    <p class="Textbody">На базе разработки Брайана возникло сразу два проекта. Первый осуществлялся индийской компанией KQ Infotech, которой уже в сентябре 2010 года удалось выпустить работоспособный, пригодный для тестирования Linux-ядра с реализацией файловой системы ZFS. А в январе следующего, 2011, года появилась финальная его версия, доступная тогда в исходниках и в виде двоичных пакетов для Fedora 14, RHEL6, Ubuntu 10.04 и 10.10.</p>
    <p class="Textbody">Однако весной того же года KQ Infotech была куплена фирмой STEC, занимающейся производством SSD-накопителей, каковых, впрочем, в наших палестинах мало кто видел. И работы по дальнейшему развитию нативной поддержки ZFS были свёрнуты. Хотя исходники модуля и сопутствующих компонентов до сих пор доступны, последнее их обновление происходило более года назад. А информации о дальнейшей судьбе проекта с тех пор не появлялось.</p>
    <p class="Textbody">Второй проект реализовывался самим Брайном вместе с сотрудниками Ливерморской национальной лаборатории, каковая, будучи в подчинении Министерства энергетики США, занимается не только вопросами ядерного оружия (эвфемизмы вроде Минсредмаша в ходу не только в бывшем Советском Союзе), но и разработкой суперкомьютеров. В результате скоро возник проект ZFS on Linux — ZFS on Linux, в рамках которого модуль поддержки ZFS и сопутствующие утилиты поддержки, портированные из Solaris — так называемый SPL (Solaris Porting Layer), были доведены до ума, и к началу 2011 года стали пригодны для использования в экспериментальном режиме. А к настоящему времени, несмотря на формальное сохранение статуса release candidatе, порт ZFS on Linux можно считать готовым к практическому применению.</p>
    <p class="Textbody">Правда, майнтайнеры основных дистрибутивов не торопились включать поддержку ZFS в свои системы даже в качестве дополнительных неофициальных пакетов. Подозреваю, что не столько из косности и лени, сколько из-за очередной сложности: видимо, по всё тем же лицензионным ограничениям модули zfs и spl приходится привязывать к фиксированной версии (и даже конкретной сборке) ядра Linux. Что, при регулярных, даже корректирующих, обновлениях последнего требует и их пересборки.</p>
    <p class="Textbody">Тем не менее, разработчики проекта воплотили результаты своей работы в виде PPA-репозитория для Ubuntu. Каковым без проблем могут пользоваться и применители Mint.</p>
    <h3 id="toc222"><a id="RefHeading18861713816058"></a><a id="bkmRefHeading18861713816058"></a><a id="toc221"></a><a id="bkmtoc221"></a><a id="RefHeading6861136957987"></a><a id="bkmRefHeading6861136957987"></a><a id="bkmRefHeading6861136957987"></a><a id="bkmbkmRefHeading6861136957987"></a>Обзор возможностей</h3>
    <p class="Textbody">Прежде чем погружаться в вопросы, связанные с ZFS, читатель, вероятно, хотел бы убедиться в том, что это стоит делать. То есть — ознакомиться с возможностями, которые она ему предоставляет.</p>
    <p class="Textbody">Для начала — немного цифр. В отличие от всех предшествовавших файловых систем и систем размещёния данных, ZFS является 128-битной. То есть теоретическое ограничение на её объём и объёмы её составляющих превышают не только реальные, но и воображаемые потребности любого пользователя. По выражению создателя ZFS, Джеффа Бонвика, для её заполнения данными и их хранения потребовалось бы вскипятить океан.</p>
    <p class="Textbody">Так, объём пула хранения данных (zpool — максимальная единица в системе ZFS) может достигать величины 3×1023 петабайт (а один петабайт, напомню, это 1015 или 250 байт, в зависимости от системы измерения). Каждый пул может включать в себя до 264 устройств (например, дисков), а всего пулов в одной системе может быть тоже не больше 264.</p>
    <p class="Textbody">Пул может быть разделён на 264 наборов данных (dataset — в этом качестве выступают, например, отдельные файловые системы), по 264 каждая. Правда, ни одна из таких файловых систем не может содержать больше 248 файлов. Зато размер любого файла ограничивается опять же значением в 264 байт.</p>
    <p class="Textbody">Количество таких ограничений можно умножить. Как уже было сказано, они лежат вне пределов человеческого воображения. И привожу я их только для того, чтобы вселить в пользователя уверенность: ни он сам, ни его внуки и правнуки в реальности не столкнутся c ограничениями на размер файловой системы или отдельного файла, как это бывало при использовании FAT или ext2fs.</p>
    <p class="Textbody">Так что перейду к особенностям ZFS, наиболее интересным, по моему мнению, десктопному пользователю. Здесь в первую очередь надо отметить гибкое управление устройствами. В пул хранения данных можно объединить произвольное (в обозначенных выше пределах) число дисков и их разделов. Устройства внутри пула могут работать в режиме расщепления данных, зеркалирования или избыточности с подсчётом контрольных сумм, подобно RAID’ам уровней 0, 1 и 5, соответственно. В пул можно включать накопители, специально предназначенные для кэширования дисковых операций, что актуально при совместном использовании SSD и традиционных винчестеров.</p>
    <p class="Textbody">Пул хранения становится доступным для работы сразу после его создания, без рестарта машины. В процессе работы дополнительные диски или разделы, в том числе и устройства кэширования, могут как присоединяться к пулу, так и изыматься из его состава в «горячем» режиме.</p>
    <p class="Textbody">Пул хранения может быть разделён на произвольное количество иерархически организованных файловых систем. По умолчанию размер их не определяется, и растёт по мере заполнения данными. Это избавляет пользователя от необходимости расчёта места, потребного под системные журналы, домашние каталоги пользователей и другие трудно прогнозируемые вещи. С другой стороны, не запрещёно при необходимости и квотирование объёма отдельных файловых систем — например, домашних каталогов отдельных излишне жадных пользователей.</p>
    <p class="Textbody">Файловые системы ZFS также доступны для размещёния на них данных сразу после создания, никаких специальных действий по обеспечению их монтирования не требуется. Создание файловых систем внутри пула — процесс предельно простой: разработчики стремились сделать его не сложнее создания каталогов, и это им вполне удалось. Но при этом составляющие пула остаются именно самостоятельными файловыми системами, которые могут монтироваться со своими специфическими опциями, в зависимости от назначения.</p>
    <p class="Textbody">Среди других возможностей ZFS, интересных настольному пользователю, можно упомянуть:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">создание снапшотов файловой системы, позволяющих восстановить её состояние в случае ошибки; </p>
      </li>
      <li>
        <p class="Textbody">клонирование файловых систем; </p>
      </li>
      <li>
        <p class="Textbody">компрессия данных файловой системы и дедупликация (замена повторяющихся данных ссылками на «первоисточник»); </p>
      </li>
      <li>
        <p class="Textbody">создание нескольких копий блоков с критически важными данными и, напротив, возможность отключения проверки контрольных сумм для повышения скорости доступа к ним. </p>
      </li>
    </ul>
    <p class="Textbody">В общем, даже если не говорить об быстродействии ZFS (а оно весьма высоко, особенно в многодисковых конфигурациях), перечислять её достоинства можно очень долго. Так долго, что поневоле успеваешь задаться вопросом: а есть ли у неё недостатки?</p>
    <p class="Textbody">Разумеется, есть. Хотя большая их часть — скорее особенности: например, ограничения при добавлении или удалении накопителей в пуле, или отсутствие поддежки TRIM.</p>
    <p class="Textbody">По большому счёту для пользователя Linux’а у ZFS обнаруживается два кардинальных недостатка: некоторая усложнённость её использования, обусловленная юридическими факторами, и высокие требования к аппаратуре.</p>
    <p class="Textbody">Первый недостаток если не ликвидирован, то сглажен трудами Брайана Белендорфа (Brian Behlendorf) со товарищи и майнтайнерами прогрессивных дистрибутивов вкупе с примкнувшими к ним независимыми разработчиками. Аппаратные же претензии ZFS мы сейчас и рассмотрим.</p>
    <h3 id="toc223"><a id="RefHeading18881713816058"></a><a id="bkmRefHeading18881713816058"></a><a id="toc222"></a><a id="bkmtoc222"></a><a id="RefHeading6881136957987"></a><a id="bkmRefHeading6881136957987"></a><a id="bkmRefHeading6881136957987"></a><a id="bkmbkmRefHeading6881136957987"></a>Аппаратные потребности</h3>
    <p class="Textbody">Итак, ZFS предоставляет пользователю весьма много возможностей. И потому вправе предъявлять немало претензий к аппаратной части — процессору (изобилие возможностей ZFS создает на него достаточную нагрузку), оперативной памяти и дисковой подсистеме.</p>
    <p class="Textbody">Впрочем, претензии эти отнюдь не сверхъестественные. Так, процессор подойдёт любой из относительно современных, начиная, скажем, с Core 2 Duo. Минимальный объём памяти определяется в 2 ГБ, с оговоркой, что применение компрессии и дедупликации требуют 8 ГБ и более.</p>
    <p class="Textbody">Сама по себе ZFS прекрасно функционирует и на одиночном диске. Однако в полном блеске показывает себя при двух и более накопителях. В многодисковых конфигурациях рекомендуется разнесение накопителей на разные контроллеры: современные SSD способны полностью загрузить все каналы SATA-III, и равномерное распределение нагрузки на пару контроллеров может увеличить быстродействие.</p>
    <p class="Textbody">К «железным» претензиям добавляются и притязания программные. В первую очередь, ZFS on Linux требует 64-битной сборки этой ОС, поскольку в 32-разрядных системах действует ограничение на адресное пространство физической памяти. Кроме того, в конфигурации ядра должнв быть отключена опция CONFIG_PREEMPT.</p>
    <p class="Textbody">Если вас привлекли достоинства ZFS и не устрашили её «железные» аппетиты, самое время опробовать её в деле. Что потребует знакомства с некоторыми специфическими понятиями.</p>
    <h3 id="toc224"><a id="RefHeading18901713816058"></a><a id="bkmRefHeading18901713816058"></a><a id="toc223"></a><a id="bkmtoc223"></a><a id="RefHeading6901136957987"></a><a id="bkmRefHeading6901136957987"></a><a id="bkmRefHeading6901136957987"></a><a id="bkmbkmRefHeading6901136957987"></a>Терминология</h3>
    <p class="Textbody">Центральным понятием ZFS является пул хранения данных (zpool). В него может объединяться несколько физических устройств хранения — дисков или дисковых разделов, причём первый вариант рекомендуется. Но не запрещёно и создание пула из одного диска или его раздела.</p>
    <p class="Textbody">Каждый пул состоит из одного или нескольких виртуальных устройств (vdev). В качестве таковых могут выступать устройства без избыточности (то есть всё те же диски и/или их разделы), или устройства с избыточностью — зеркала и массивы типа RAID-Z:</p>
    <p class="Textbody">Зеркальное устройство (mirror) — виртуальное устройство, хранящее на двух или более физических устройствах, но при чётном их количестве, идентичные копии данных на случай отказа диска;</p>
    <p class="Textbody">RAID-Z — виртуальное устройство из нескольких устройств физических, предназначенное для хранения данных и их контрольных сумм с однократным или двойным контролем чётности. В первом случае теоретически требуется не менее двух, во втором — не менее трёх физических устройств.</p>
    <p class="Textbody">Если пул образован устройствами без избыточности (просто дисками или разделами), то одно из vdev, соответствующее ему целиком, выступает в качестве корневого устройства. Пул из устройств с избыточностью может содержать более одного корневого устройства — например, два зеркала.</p>
    <p class="Textbody">Пулы, образованные виртуальными устройствами, служат вместилищем для наборов данных (dataset). Они бывают следующих видов:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">файловая система (filesystem) — набор данных, смонтированный в определённой точке и ведущий себя подобно любой другой файловой системе; </p>
      </li>
      <li>
        <p class="Textbody">снапшот (snapshot) — моментальный снимок текущего состояния файловой системы, доступный только для чтения; </p>
      </li>
      <li>
        <p class="Textbody">клон (clone) — точная копия файловой системы в момент его создания; создаётся на основе снимка, но, в отличие от него, доступен для записи; </p>
      </li>
      <li>
        <p class="Textbody">том (volume) — набор данных, эмулирующий физическое устройство, например, раздел подкачки. </p>
      </li>
    </ul>
    <p class="Textbody">Наборы данных пула должны носить уникальные имена такого вида:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd">pool_name/path/(dataset_name)(@snapshot_name) </span>
    </p>
    <p class="Textbody">Пулы и наборы данных в именуются по правилам пространства имён ZFS, впрочем, довольно простым. Запрещёнными символами для всех являются символы подчёркивания, дефиса, двоеточия, точки и процента. Имя пула при этом обязательно должно начинаться с алфавитного символа и не совпадать с одним из зарезервированных имён — log, mirror, raidz или spare (последнее обозначает имя устройства «горячего» резерва). Все остальные имена, в соответствие с демократическими традициями пространства имён ZFS, разрешены.</p>
    <p class="Textbody">А вот об именах физических устройств, включаемых в пул, следует сказать особо.</p>
    <h3 id="toc225"><a id="RefHeading18921713816058"></a><a id="bkmRefHeading18921713816058"></a><a id="toc224"></a><a id="bkmtoc224"></a><a id="RefHeading6921136957987"></a><a id="bkmRefHeading6921136957987"></a><a id="bkmRefHeading6921136957987"></a><a id="bkmbkmRefHeading6921136957987"></a>Модели именования устройств</h3>
    <p class="Textbody">В современном Linux’е использование для накопителей имён «верхнего уровня», имеющих вид /dev/sda, не является обязательным, а в некоторых случаях и просто нежелательно. Однако правила менеджера устройств udev позволяют определять и другие модели идентификации накопителей:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">метке тома (/dev/disk/by-label); </p>
      </li>
      <li>
        <p class="Textbody">идентификатору диска (/dev/disk/by-id); </p>
      </li>
      <li>
        <p class="Textbody">пути к дисковому устройству (/dev/disk/by-path); </p>
      </li>
      <li>
        <p class="Textbody">универсальному уникальному идентификатору, Universally Unique IDentifier (/dev/disk/by-uuid). </p>
      </li>
    </ul>
    <p class="Textbody">А с полным списком вариантов идентификации блочных устройств можно ознакомиться, просмотрев имена подкаталогов в каталоге /dev/disk, их содержимое — это символические ссылки на имена «верхнего уровня».</p>
    <p class="Textbody">С идентификацией по метке тома и по UUID, вероятно, знакомо большинство читателей. И к тому же в пространстве имён ZFS они не используются. А вот с идентификацией by-path и by-id нужно познакомиться поближе.</p>
    <p class="Textbody">Модель именования by-path использует имена устройств, привязанные к их положению на шине PCI и включающие номер шины и канала на ней. Имя дискового устройства выглядит примерно так:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd">pci-0000:00:1f.2-scsi-0:0:0:0 </span>
    </p>
    <p class="Textbody">Дисковые разделы маркируются добавлением к имени устройства суффикса part#.</p>
    <p class="Textbody">Модель именования by-path идентифицирует устройства вполне однозначно, и особенно эффективна при наличии более чем одного дискового контроллера. Однако сами имена и устройств, и разделов описываются довольно сложной для восприятия последовательностью. Да и в большинстве «десктопных» ситуаций модель эта избыточна.</p>
    <p class="Textbody">Модель идентификации by-id представляет имена носителей информации в форме, наиболее доступной для человеческого понимания. Они образованы из названия интерфейса, имени производителя, номера модели, серийного номера устройства и, при необходимости, номера раздела, например:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd">ata-SanDisk_SDSSDX120GG25_120823400863-part1 </span>
    </p>
    <p class="Textbody">Таким образом, все компоненты имени устройства в модели by-id определяются не условиями его подключения или какими-то правилам, а задаются производителем и жёстко прошиты в «железе». И потому эта модель является наиболее однозначной для именования устройств. А также, что немаловажно, строится по понятной человеку логике.</p>
    <p class="Textbody">Какую из моделей именования устройств выбрать для данного пула — зависит от его назначения и масштабов. Имена «верхнего уровня» целесообразно применять для однодисковых пулов (особенно если в машине второго диска нет и не предвидится). Они же, по причине простоты и удобопонятности, рекомендуются для экспериментальных и разрабатываемых пулов. И очень не рекомендуются — во всех остальных случаях, так как зависят от условий подключения накопителей.</p>
    <p class="Textbody">Этого недостатка лишена модель by-id: как пишет Брайан, при её использовании «диски можно отключить, случайно смешать и подключить опять произвольным образом — и пул будет по-прежнему корректно работать». Как недостаток её рассматривается сложность конфигурирования больших пулов с избыточностью. И потому она рекомендуется для применения в «десктопных» и «квартирных» (типа семейного сервера) условиях.</p>
    <p class="Textbody">Для больших (более 10 устройств) пулов из дисков, подключённых к нескольким контроллерам, рекомендуется идентификация by-path. Однако в наших целях она громоздка и избыточна.</p>
    <p class="Textbody">Наконец, ZFS on Linux предлагает и собственную модель идентификации — /dev/disk/zpool, в котором именам by-path ставятся в соответствие уникальные и осмысленные «человекочитаемые» имена, даваемые пользователем. Модель эта рекомендуется для очень больших пулов, каковых на настольной машине ожидать трудно.</p>
    <p class="Textbody">Так что дальше я буду использовать имена «верхнего уровня», говоря об абстрактных или экспериментальных ситуациях, и об именах by-id, когда речь зайдёт о практических примерах применения ZFS.</p>
    <h3 id="toc226"><a id="RefHeading18941713816058"></a><a id="bkmRefHeading18941713816058"></a><a id="toc225"></a><a id="bkmtoc225"></a><a id="RefHeading6941136957987"></a><a id="bkmRefHeading6941136957987"></a><a id="bkmRefHeading6941136957987"></a><a id="bkmbkmRefHeading6941136957987"></a>Включение поддержки ZFS в Mint</h3>
    <p class="Textbody">Для практического использования ZFS on Linux перво-наперво необходимо обеспечить её поддержку в вашем дистрибутиве — ибо по причинам, описанным ранее, сама собой она не поддержится ни в одном Linux’е.</p>
    <p class="Textbody">Как это сделать, зависит от дистрибутива. В Сети можно найти подробные инструкции для Ubuntu, которые легко распространяются на все производные от неё системы, в том числе и на Mint.</p>
    <p class="Textbody">Как уже было сказано, пакеты поддержки ZFS представлены в PPA-репозитори, где они реализованы в виде сценариев dkms, предполагающих сборку модулей под текущую версию ядра. Пакеты эти объединены в метапакет zfs-native, существующий в двух варианта — <a href="https://launchpad.net/%7Ezfs-native/+archive/ubuntu/stable»%20target=">ZFS Stable Releases</a> и <a href="https://launchpad.net/%7Ezfs-native/+archive/ubuntu/daily»%20target=">ZFS Daily Releases</a>, то есть стабильной и тестовой сборках, соответственно.</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_229.png">
        <img alt="Изображение578" class="frameGraphics" id="578graphic" src="http://alv.me/wp-content/img/im_cin_img/09-disks_229-572x470.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:471.82745px" />
      </a>
      <a id="a580graphic"></a>
      <a id="bkm580graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/09-disks_229.png"> </a>
    </p>
    <p class="Textbody">Для использования ZFS в Ubuntu для начала нужно подключить нужный PPA-репозиторий. Поскольку все последующие действия потребуют прав суперпользователя, перво-наперво обретаем их на длительное время командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo -i</span> </p>
    <p class="Textbody">с вводом пользовательского пароля. А затем собственно подключаем репозиторий:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># add-apt-repository ppa:zfs-native/stable</span> </p>
    <p class="Textbody">Или, при желании поэкспериментировать --</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># add-apt-repository ppa:zfs-native/daily</span> </p>
    <p class="Textbody">Обновляем кэш:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># apt update</span> </p>
    <p class="Textbody">Теперь строим дерево зависимостей — в Mint 17.1 Rebecca это обязательный шаг, хотя ранее я обходился без него:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># apt build-dep ubuntu-zfs</span> </p>
    <p class="Textbody">И собираем необходимые пакеты:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># apt install ubuntu-zfs</span> </p>
    <p class="Textbody">Поскольку в репозитории они существуют не в бинарном виде, а в виде исходников, приведённая команда потянет за собой сборочный инструментарий. И сама сборка пакетов займёт определённое время. Но рано или поздно она закончится, и можно будет скомандовать</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># modprobe zfs</span> </p>
    <p class="Textbody">и проверить результат командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># lsmod | grep zfs</span> </p>
    <p class="Textbody">вывод которой будет выглядеть примерно так:</p>
    <p class="Textbody"><span style="background-color:#dddddd">zfs                  1158757  4</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">zcommon                51283  1 zfs</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">znvpair                81997  2 zfs,zcommon</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">zavl                   15011  1 zfs</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">zunicode              331226  1 zfs</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">spl                    88617  5 zfs,zcommon,znvpair,zavl,zunicode</span> </p>
    <p class="Textbody">После чего остаётся создать точку монтирования для пула ZFS — в моём случае таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># mkdir /home/data</span> </p>
    <p class="Textbody">Дать ей атрибуты принадлежности обычному пользователю:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># chown -R alv:alv /home/data</span> </p>
    <p class="Textbody">Теперь можно приступать к применению ZFS в мирных практических целях.</p>
    <h3 id="toc227"><a id="RefHeading18961713816058"></a><a id="bkmRefHeading18961713816058"></a><a id="toc226"></a><a id="bkmtoc226"></a><a id="RefHeading6961136957987"></a><a id="bkmRefHeading6961136957987"></a><a id="bkmRefHeading6961136957987"></a><a id="bkmbkmRefHeading6961136957987"></a>Создаём простой пул</h3>
    <p class="Textbody">Освоив ранее основные понятия, мы научились понимать ZFS. Для обратной же задачи — чтобы ZFS понимала нас — нужно ознакомиться с её командами. Главные из них — две: zpool для создания и управления пулами, и zfs для создания и управления наборами данных. Немного, правда? Хотя каждая из этих команд включает множество субкоманд, с которыми мы со временем разберёмся.</p>
    <p class="Textbody">Очевидно, что работу с ZFS следует начинать с создания пула хранения. Начнём с этого и мы. В простейшем случае однодисковой конфигурации это делается так:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zpool create tank dev_name </span>
    </p>
    <p class="Textbody">Здесь create — субкоманда очевидного назначня, tank — имя создаваемого пула (оно обычно даётся в примерах, но на самом деле может быть любым — с учётом ограничений ZFS, я использую имя data), а dev_name — имя устройства, включаемого в пул. Каковое может строиться по любой из описанных ранее моделей. И, чтобы не повторяться, напомню: все команды по манипуляции с пулами и наборами данных в них выполняются от лица администратора.</p>
    <p class="Textbody">В случае, если в состав пула включается один диск, и второго не предвидится, можно использовать имя устройства верхнего уровня — например, sda для цельного устройства (обратим внимание, что путь к файлу устройства указывать не нужно). Однако реально такая ситуация маловероятна: загрузка с ZFS проблематична, так что как минимум потребуется раздел с традиционной файловой системой под /boot (и/или под корень файловой иерархии), так что команда примет вид вроде следующего:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zpool create data sda3 </span>
    </p>
    <p class="Textbody">Однако если можно ожидать в дальнейшем подсоединения новых накопителей и их включения в существующий пул, то лучше воспользоваться именем по модели by-id, например:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zpool create data ata-Crucial_CT512MX100SSD1_14330CEEA98C-part3 </span>
    </p>
    <p class="Textbody">Очевидно, что в случае однодискового пула ни о какой избыточности говорить не приходится. Однако уже при двух дисках возможны варианты. Первый — создание пула без избыточности:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zpool create data dev_name1 dev_name2 </span>
    </p>
    <p class="Textbody">где dev_name1 и dev_name1 — имена устройств в принятой модели именования.</p>
    <p class="Textbody">В приведённом примере будет создано нечто вроде RAID’а нулевого уровня, с расщеплением (stripping) данных на оба устройства. Каковыми могут быть как дисковые разделы, так и диски целиком. Причём, в отличие от RAID0, диски (или разделы) не обязаны быть одинакового размера.</p>
    <p class="Textbody">После указанной команды никаких сообщений не последует. No news — good news, говорят англичане; в данном случае это означает, что пул был благополучно создан. В чём можно немедленно убедиться двумя способами. Во-первых, в корневом каталоге появляется точка его монтирования /data. А во-вторых, этой цели послужит субкоманда status:<br /># zpool status data</p>
    <p class="Textbody">которая выведет нечто вроде этого:</p>
    <p class="Textbody"><span style="background-color:#dddddd">pool: data</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">state: ONLINE</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">scan: none requested</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">config:</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME        STATE     READ WRITE CKSUM</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">mypool      ONLINE       0     0     0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">sdd       ONLINE       0     0     0</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">sdf       ONLINE       0     0     0</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">errors: No known data errors</span> </p>
    <p class="Textbody">А с помощью субкоманды list можно узнать объём новообразованного пула:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># zpool list data</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">data  18,9G    93K  18,9G     0%  1.00x  ONLINE  -</span> </p>
    <p class="Textbody">Легко видеть, что он равен сумме объёмов обеих флэшек, если «маркетинговые» гигабайты пересчитать в «настоящие».</p>
    <p class="Textbody">К слову сказать, если дать субкоманду list без указания аргумента — имени пула, то она выведет информацию о всех пулах, задействованных в системе. В моём случае это выглядит так:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># zpool list</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">exp   18,9G    93K  18,9G     0%  1.00x  ONLINE  -</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">data  199G  20,8G   178G    10%  1.00x  ONLINE  -</span> </p>
    <p class="Textbody">Обращаю внимание, что даже чисто информационные субкоманды вроде list и status требуют прав администратора.</p>
    <p class="Textbody">Разумеется, два пула в одной, да ещё и настольной, машине — излишняя роскошь. Так что пул, созданный в экспериментальных целях, подлежит уничтожению, что делается с помощью субкоманды destroy:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zpool destroy exp</span> </p>
    <p class="Textbody">После чего он пропадёт из списка пулов. А что можно сделать с пулом до его уничтожения, увидим со временем.</p>
    <h3 id="toc228"><a id="RefHeading18981713816058"></a><a id="bkmRefHeading18981713816058"></a><a id="toc227"></a><a id="bkmtoc227"></a><a id="RefHeading6981136957987"></a><a id="bkmRefHeading6981136957987"></a><a id="bkmRefHeading6981136957987"></a><a id="bkmbkmRefHeading6981136957987"></a>«Избыточные» пулы</h3>
    <p class="Textbody">Избавившись от ставшего ненужным пула, рассмотрим второй вариант — создание пула с зеркальным устройством. Создаём его из двух накопителей одинакового объёма:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zpool create -f exp2 mirror sdf sdg</span> </p>
    <p class="Textbody">Проверка показывает, что итоговый пул, как и следовало ожидать, равен объёму одного накопителя:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># zpool list mypool</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">exp2  3,72G  91,5K  3,72G     0%  1.00x  ONLINE  -</span> </p>
    <p class="Textbody">При различии объёмов больший диск будет «обрезан» до объёма меньшего.</p>
    <p class="Textbody">Полное зеркалирование любыми, по моему мнению, в настольных условиях — роскошь непозволительная: банальные бэкапы данных проще и надёжнее. Тем не менее, не исключаю, что некоторая избыточность на уровне проверки контрольных сумм может оказаться не лишней, да и не столь накладна. Так что давайте посмотрим и на третий вариант пула из более чем одного устройства — RAID-Z.</p>
    <p class="Textbody">Теоретически виртуальное устройство с одинарным контролем чётности, как уже говорилось, можно создать при наличии двух устройств физических. Однако практически это оказывается накладно, особенно если устройства не одинакового размера. Поэтому задействуем под него три накопителя:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zpool create exp3 raidz sdd sdf sdg</span> </p>
    <p class="Textbody">что даст нам следующую картину:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># zpool list exp3</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">exp3  11,1G   205K  11,1G     0%  1.00x  ONLINE  -</span> </p>
    <p class="Textbody">Впрочем, как мне кажется, в настольных условиях не стоит выделки и эта овчинка.</p>
    <h3 id="toc229"><a id="RefHeading19001713816058"></a><a id="bkmRefHeading19001713816058"></a><a id="toc228"></a><a id="bkmtoc228"></a><a id="RefHeading7001136957987"></a><a id="bkmRefHeading7001136957987"></a><a id="bkmRefHeading7001136957987"></a><a id="bkmbkmRefHeading7001136957987"></a>Пул кэшируемый</h3>
    <p class="Textbody">И, наконец, последний вариант организации пула из более чем одного устройства — создание пула с кэшированием. Для чего создаём из двух устройств простой пул без избыточности и подсоединяем к нему устройство для кэша:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zpool create exp4 sdd sdf cache sdg</span> </p>
    <p class="Textbody">Очевидно, что устройство для кэширования не должно входить в пул любого рода — ни в простой, ни в избыточный. Что мы и видим в выводе субкоманды list:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># zpool list exp4</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">exp4  18,9G    82K  18,9G     0%  1.00x  ONLINE  -</span> </p>
    <p class="Textbody">где никаких следов его обнаружить не удаётся. Если же появляются сомнения, а подключилось ли оно на самом деле, обращаемся к субкоманде status, которая покажет беспочвенность наших опасений.</p>
    <p class="Textbody">Как я уже говорил в обзоре возможностей ZFS, подключение устройства кэширования имеет смысл при наличии большого традиционного винчестера (или винчестеров) и относительно небольшого SSD, которое и играет роль дискового кэша.</p>
    <h3 id="toc230"><a id="RefHeading19021713816058"></a><a id="bkmRefHeading19021713816058"></a><a id="toc229"></a><a id="bkmtoc229"></a><a id="RefHeading7021136957987"></a><a id="bkmRefHeading7021136957987"></a><a id="bkmRefHeading7021136957987"></a><a id="bkmbkmRefHeading7021136957987"></a>О некоторых опциях команды zpool</h3>
    <p class="Textbody">Команда zpool поддерживает ещё множество субкоманд, предназначенных для экспорта и импорта пула, добавления к нему устройств и изъятия оных, и так далее. Но сейчас я расскажу о некоторых опциях, которые могут оказаться необходимыми при создании пула.</p>
    <p class="Textbody">Одна из важный опций — -f: она предписывает принудительное выполнение данной операции и требуется, например, при создании пула из неразмеченных устройств.</p>
    <p class="Textbody">Полезной может оказаться опция -n. Она определяет тестовый режим выполнения определённой субкоманды, то есть выводит результат, например, субкоманды zpool create без фактического создания пула. И, соответственно, сообщает об ошибках, если таковые имеются.</p>
    <p class="Textbody">Интересна также опция -m mountpoint. Как уже говорилось, при создании пула по умолчанию в корне файловой иерархии создаётся каталог /pool_name, который в дальнейшем будет точкой монтирования файловых систем ZFS. Возможно, что это окажется не самым лучшим местом для их размещёния, и, как мы увидим в дальнейшем, это несложно будет изменить. Но можно задать каталог для пула сразу — например, /home/data: это и будет значением опции -m. Никто не запрещает определить в качестве такового и какой-либо из существующих каталогов, если он пуст, иначе автоматическое монтирование файловых систем пула в него окажется невозможным.</p>
    <p class="Textbody">Наконец, нынче важное значение приобретает опция ashift=#, значением которой является размер блока файловой системы в виде степеней двойки. По умолчанию при создании пула размер блока определяется автоматически, и до некоторого времени это было оптимально. Однако затем, с одной стороны, появились диски так называемого Advanced Format, в других размер блока равен 4 КБ. С другой стороны, получили распространение SSD-накопители, обычно также имеющие четырёхкилобайтный блок. В этих условиях автоматика ZFS может работать некорректно, что приводит к падению производительности пула.</p>
    <p class="Textbody">Для предотвращения означенного безобразия и была придумана опция ashift. Значение её по умолчанию — 0, что соответствует автоматическому определению размера блока. Прочие же возможные значения лежат в диапазоне от 9 для блока в 512 байт (29 = 512) до 16 для 64-килобайтного блока (216 = 65536). В интересующем нас случае четырёхкилобайтного блока оно составляет 12 (212 = 4096). Именно последнее значение и следует указать явным образом при создании пула из винчестеров AF или большинства SSD-накопителей.</p>
    <h3 id="toc231"><a id="RefHeading19041713816058"></a><a id="bkmRefHeading19041713816058"></a><a id="toc230"></a><a id="bkmtoc230"></a><a id="RefHeading7041136957987"></a><a id="bkmRefHeading7041136957987"></a><a id="bkmRefHeading7041136957987"></a><a id="bkmbkmRefHeading7041136957987"></a>Создание файловых систем</h3>
    <p class="Textbody">Пулы хранения представляют собой вместилища для наборов данных, для манипуляции которыми предназначена вторая из главнейших команд — zfs. Самыми важными наборами данных являются файловые системы, к рассмотрению которых мы и переходим.</p>
    <p class="Textbody">Для создания файловых систем предназначена субкоманда create команды zfs, которая требует единственного аргумента — имени создаваемой ФС и обычно не нуждается ни в каких опциях:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zfs create pool_name/fs_name </span>
    </p>
    <p class="Textbody">Внутри пула можно создавать сколь угодно сложную иерархию файловых систем. Единственное условие — родительская файловая система для системы более глубокого уровня вложенности должна быть создана заблаговременно. Ниже я покажу это на конкретном примере создания файловых систем внутри каталога /home — наиболее оправданное место для размещёния наборов данных ZFS.</p>
    <p class="Textbody">Начну я немножечко издалека. При стандартной установке Mint не обойтись без создания учетной записи обычного пользователя, и, следовательно, в каталоге /home будет присутствовать по крайней мере один подкаталог — /home/username.</p>
    <p class="Textbody">Смонтировать же файловую систему ZFS в непустой каталог невозможно, и, значит, мы не можем сразу прибегнуть к опции -m для определения «постоянной прописки» создаваемого пула.</p>
    <p class="Textbody">Поэтому для начала делаем для пула «прописку» во временной точке — пусть это будет традиционный /tank:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zpool create -o ashift=12 tank ata-SanDisk_SDSSDX120GG25_120823400863-part3 ata-SanDisk_SDSSDX120GG25_120823402786-part3</span> </p>
    <p class="Textbody">Теперь создаём файловую систему для будущего домашнего каталога:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs create tank/home</span> </p>
    <p class="Textbody">А внутри же неё — необходимые дочерние ветви, как то:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># zfs create tank/home/alv</span> </p>
    <p class="Textbody"> </p>
    <p class="Textbody">которая потом заменит мой домашний каталог — в нём я не держу ничего, кроме конфигурационных файлов;</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs create tank/home/proj</span> </p>
    <p class="Textbody">это файловая система для моих текущих проектов, и так далее.</p>
    <p class="Textbody">Как и было обещано разработчиками ZFS, процедура ничуть не сложнее, чем создание обычных каталогов. Благодаря этому файловые системы можно легко создавать по мере надобности, для решения какой-либо частной задачи. И столь же легко уничтожать их, когда задача эта выполнена. Что делается таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs destroy pool_name/fs_name</span> </p>
    <p class="Textbody">Использовать субкоманду destroy следует аккуратно: никакого запроса на подтверждение при этом не будет. Правда, и уничтожить файловую систему, занятую в каком-либо текущем процессе, можно только с указанием опции -f, а файловую систему, содержащую системы дочерние, не получится убить и таким образом.</p>
    <p class="Textbody">Ни в какой специальной операции монтирования новообразованные файловые системы не нуждаются — оно происходит автоматически в момент их создания, о чём свидетельствует следующая команда:<br />$ mount | grep tank tank/home on /tank/home type zfs (rw,atime,xattr) tank/home/alv on /tank/home/alv type zfs (rw,atime,xattr) tank/home/proj on /tank/home/proj type zfs (rw,atime,xattr) ...</p>
    <p class="Textbody">Для обеспечения монтирования файловых систем ZFS при рестарте машины не требуется и никаких записей в файле /etc/fstab: это также происходит само собой, совершенно нечувствительно для пользователя. Правда, если для файловой системы ZFS определить свойство mountpoint=legacy, то с ней можно управляться и традиционным способом.</p>
    <p class="Textbody">Как и для обычного каталога, объём каждой файловой системы ничем не лимитирован, и в момент создания для любой из них потенциально доступно всё пространство пула, которое равномерно уменьшается по мере разрастания файловых систем. На данный момент в моей системе это выглядит так.</p>
    <p class="Textbody">Казалось бы, для тех же целей можно ограничиться обычными каталогами. Однако в наборах данных ZFS мы имеем дело с полноценными файловыми системами, для которых могут быть установлены индивидуальные свойства, аналогичные опциям монтирования файловых систем традиционных. Чем мы сейчас и займёмся.</p>
    <h3 id="toc232"><a id="RefHeading19061713816058"></a><a id="bkmRefHeading19061713816058"></a><a id="toc231"></a><a id="bkmtoc231"></a><a id="RefHeading7061136957987"></a><a id="bkmRefHeading7061136957987"></a><a id="bkmRefHeading7061136957987"></a><a id="bkmbkmRefHeading7061136957987"></a>Файловые системы: устанавливаем свойства</h3>
    <p class="Textbody">При создании файловая система ZFS получает по умолчанию определённый набор свойств, во многом сходный с атрибутами традиционных файловых систем, определяемыми опциями их монтирования. Полный их список можно получить командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs get all fs_name</span> </p>
    <p class="Textbody">Свойств этих очень много, однако далеко не все они представляют для нас интерес. Важно только помнить, что любое из свойств каждой файловой системы можно поменять с помощью субкоманды set и её параметра вида свойство=значение. Причём изменение свойств для материнской системы рекурсивно распространяется на все дочерние. Однако для любой последней свойства можно изменить в индивидуальном порядке. Что я сейчас и проиллюстрирую на примерах.</p>
    <p class="Textbody">Так, абсолютно лишним представляется свойство atime, то есть обновление времени последнего доступа к файлам. Оно, во-первых, снижает быстродействие, с другой — способствует износу SSD-накопителей (правда, нынче и то, и другое чисто символичны). Так что отключаем это свойство для всех файловых систем:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs set atime=off tank/home</span> </p>
    <p class="Textbody">Аналогичным образом расправляемся и со свойством xattr:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs set xattr=off tank/home</span> </p>
    <p class="Textbody">А вот дальше можно заняться и индивидуализацией. Как я уже говорил, в момент создания файловые системы ZFS «безразмерны». Если это не подходит, для них можно установить квоты. Однако я этого делать не буду — в моём случае это приводит к потере половины смысла ZFS. А вот зарезервировать место для критически важных каталогов, дабы его не отъела, скажем, мультимедиа, известная своей прожорливостью, будет не лишним. И потому я для файловых систем tank/home/proj и tank/home/alv устанавливаю свойство reservation. Для файловой системы проектов оно будет максимальным:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs set reservation=10G tank/home/proj</span> </p>
    <p class="Textbody">Для остальных ограничусь более скромным гигабайтом резерва.</p>
    <p class="Textbody">Далее, поскольку данные в файловой системе tank/home/proj для меня действительно важны, и шутить с ними я склонен даже гораздо меньше, чем с дамами, предпринимаю дополнительные меры по их сохранности путём удвоения числа копий (по умолчанию оно равно 1):</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs set copies=2 tank/home/proj</span> </p>
    <p class="Textbody">А для данных не столь важных — тех, что часто проще скачать заново, нежели отыскать на локальной машине, можно выполнить и обратную операцию — отказаться от подсчёта контрольных сумм:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zfs set checksum=off tank/home/media</span> </p>
    <p class="Textbody">Для файловых систем, содержащих хорошо сжимаемые данные (например, для моего домашнего каталога, где лежат одни dot-файлы), можно включить компрессию:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zfs set compression=on tank/home/alv </span>
    </p>
    <p class="Textbody">Я этого не делал: экономия места получается грошовая, а нагрузка на процессор и расход памяти, как говорят, очень приличные. Однако это свойство целесообразно включать в системах с огромными логами, если выделить под них файловую систему в пуле ZFS.</p>
    <p class="Textbody">При желании для некоторых файловых систем (например, того же домашнего каталога) можно отключить такие свойства, как exec, setuid, devices — легко догадаться, что результат будет аналогичен указанию опций монтирования noexec, nosuid, nodev для традиционных файловых файловых систем. И, разумеется, для файловых систем, изменение которых нежелательно, можно придать свойство readonly.</p>
    <p class="Textbody">Все необходимые свойства файловых систем желательно установить до их наполнения контентом, ибо многие из них (например, компрессия) обратной силы не имеют.</p>
    <h3 id="toc233"><a id="RefHeading19081713816058"></a><a id="bkmRefHeading19081713816058"></a><a id="toc232"></a><a id="bkmtoc232"></a><a id="RefHeading7081136957987"></a><a id="bkmRefHeading7081136957987"></a><a id="bkmRefHeading7081136957987"></a><a id="bkmbkmRefHeading7081136957987"></a>Перемонтирование</h3>
    <p class="Textbody">После создания файловых систем и задания всех необходимых их свойств наступает психологический момент для перемонтирования их по месту «постоянной прописки» — то есть в каталог /home. Что потребует некоторых подготовительных действий.</p>
    <p class="Textbody">Поскольку предполагается, что все новообразованные файловые системы должны быть полностью доступны обычному пользователю (то есть мне, любимому), перво-наперво следует изменить атрибуты из принадлежности — ведь создавались они от имени администратора и принадлежат юзеру по имени root. Для чего даю команду:<br /># chown -R alv:users /tank/home/*</p>
    <p class="Textbody">Теперь нужно скопировать конфиги из каталога /home/alv в /tank/home/alv:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># cp -Rp /home/alv/.* /tank/home/alv/ </span>
    </p>
    <p class="Textbody">не забыв про опцию -p для сохранения атрибутов.</p>
    <p class="Textbody">Все предыдущие операции можно было выполнять, получив права администратора с помощью команды sudo. Причём где угодно — в текстовом виртуальном терминале или в терминальном окне Иксового сеанса. Теперь же потребуется переавторизоваться в «голой» консоли.</p>
    <p class="Textbody">Монтирование файловых систем ZFS в каталог с любым содержимым невозможно, так что требуется очистить каталог /home от следов прежней жизнедеятельности пользователя таким образом:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># rm -Rf /home/alv </span>
    </p>
    <p class="Textbody">При хоть одном активном пользовательском процессе в ответ на это последует сообщение об ошибке. Так что, возможно, перед этим придётся убить все реликтовые процессы, запущенные в Иксах от имени пользователя. Сначала выявляем их командой</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># ps aux | grep alv </span>
    </p>
    <p class="Textbody">обращая внимание на идентификаторы процессов (PID). А затем последовательно мочим их в сортире:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># kill -9 #### </span>
    </p>
    <p class="Textbody">Альтернативный способ — разрузка системы в recovery mode с выбором пункта меню root, что в Mint эквивалентно однопользовательскому режиму. В этом случае никаких пользовательских процессов не будет по определению, и перенос файлов из /home/username в /tank/home/username можно выполнить напрямую.</p>
    <p class="Textbody">Выполнив все указанные действия, определяем для набора данных tank/home свойство mountpoint, что и осуществит перемонтирование:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># zfs set mountpoint=/home tank/home </span>
    </p>
    <p class="Textbody">Теперь остаётся только с помощью команды ls убедиться, что в /home появились новые подкаталоги с нужными атрибутами:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd">drwxr-xr-x 26 alv users 48 Sep 23 14:27 alv/<br />drwxr-xr-x 18 alv users 18 Sep 22 02:28 proj/<br />... </span>
    </p>
    <p class="Textbody">А команда</p>
    <p class="Textbody">
      <span style="background-color:#dddddd"># mount | grep /home </span>
    </p>
    <p class="Textbody">покажет нам новые точки монтирования файловых систем:</p>
    <p class="Textbody">
      <span style="background-color:#dddddd">tank/home on /home type zfs (rw,noatime,noxattr)<br />tank/home/alv on /home/alv type zfs (rw,noatime,noxattr)<br />tank/home/proj on /home/proj type zfs (rw,noatime,noxattr)<br />... </span>
    </p>
    <p class="Textbody">На этом дело с подготовкой файловых систем ZFS к практической работе можно считать законченным: при перезагрузке машины все они будут благополучно смонтированы в автоматическом режиме.</p>
    <h3 id="toc234"><a id="RefHeading19101713816058"></a><a id="bkmRefHeading19101713816058"></a><a id="toc233"></a><a id="bkmtoc233"></a><a id="RefHeading7101136957987"></a><a id="bkmRefHeading7101136957987"></a><a id="bkmRefHeading7101136957987"></a><a id="bkmbkmRefHeading7101136957987"></a>Подключение пула ZFS, созданного в другой системе</h3>
    <p class="Textbody">Здесь речь пойдёт о том, как подключить к некоей Linux-системе (конкретно, Ubuntu) пул ZFS, ранее созданный в другой системе — теоретически это могут быть Solaris, FreeBSD или более иной дистрибутив Linux, для которого предусмотрена поддержка ZFS on Linux. Но практически я опробовал только последний вариант, о чём и расскажу.</p>
    <p class="Textbody">Перво-наперво нужно перезагрузиться в ту систему, в которой создавался пул (в моём случае это была openSUSE), и экспортировать его командой:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># zpool export data</span> </p>
    <p class="Textbody">где data — имя пула с точкой монтирования /home/data.</p>
    <p class="Textbody">Следующий шаг — вернуться в Ubuntu и создать в ней аналогичную точку монтирования для пула ZFS — в моём случае таким образом:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo mkdir /home/data</span> </p>
    <p class="Textbody">Дать ей атрибуты принадлежности обычному пользователю:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo chown -R alv:alv /home/data</span> </p>
    <p class="Textbody">И импортировать созданный в openSUSE пул ZFS:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ sudo zpool import -f data</span> </p>
    <p class="Textbody">Не забыв об опции -f, предписывающей принудительной выполнение импорта. Без неё ответом на эту команду будет сообщение об ошибке.</p>
    <p class="Textbody">Теперь в каталоге /home/data можно видеть те же самые файловые системы ZFS, которые были созданы в родителькой для пула системе, вместе со всеми размещёнными в них данными. С которыми можно начинать работать.</p>
    <p class="Textbody">Сказанное справедливо, если идентификаторы пользователя в обеих системах совпадают — в моём случае это именно так. Однако в случае общем это совсем не обязательно — и тогда надо озаботиться каким-либо способом обеспечения совместного доступа к ним из разных систем. Впрочем, к ZFS, о которой мы сейчас разговариваем, это не имеет ни малейшего отношения.</p>
    <h2 id="toc235"><a id="RefHeading19121713816058"></a><a id="bkmRefHeading19121713816058"></a><a id="toc234"></a><a id="bkmtoc234"></a><a id="RefHeading13121136957987"></a><a id="bkmRefHeading13121136957987"></a><a id="bkmRefHeading13121136957987"></a><a id="bkmbkmRefHeading13121136957987"></a>Индивидуализация системы</h2>
    <p class="Textbody">Последний очерк посвящается апофеозу знакомства с дистрибутивом Mint и его Cinnamon — сборке индивидуализированной системы на его основе. Как сказал то ли один из премьер-министров Великобритании, то ли некий президент Франции (кому только это изречение ни приписывали?):</p>
    <p class="Textbody">Тот, кто в (информационной) юности не мечтал собрать свой дистрибутив Linux'а, не имеет сердца. Тот, кто продолжает мечтать об этом в (информационной) зрелости — не имеет разума.</p>
    <p class="Textbody">Однако применительно к Linux Mint вполне возможно сочетать сердечность и разумность даже в преклонные годы, ибо собрать свою индивидуализированную систему на базе этого дистрибутива и просто, и полезно.</p>
    <h3 id="toc236"><a id="RefHeading19141713816058"></a><a id="bkmRefHeading19141713816058"></a><a id="toc235"></a><a id="bkmtoc235"></a><a id="RefHeading7121136957987"></a><a id="bkmRefHeading7121136957987"></a><a id="bkmRefHeading7121136957987"></a><a id="bkmbkmRefHeading7121136957987"></a>Свой Mint: введение</h3>
    <p class="Textbody">Во время первого знакомства с с Mint у меня сложилось впечатление, что в его инсталляции настолько мало лишних программ, что не стоило и заморачиваться с их удалением. Однако при дальнейшем рассмотрении оказалось, что лишних (для меня) приложений вполне достаточно — например, вся мультимедиа. С другой стороны, ряд привычных для меня программ (например, те же мультимединые) приходилось доустанавливать. И появилась мысль изготовить свой установочный диск этого дистрибутива. На котором не было бы ничего лишнего (повторяю, для меня). И, напротив, были бы все приложения, которые мне так или иначе пришлось доустанавливать.</p>
    <p class="Textbody">В сети можно найти упоминания о нескольких инструментах для изготовления собственного дистрибутива на базе Ubuntu и её производных (а Mint, как известно, принадлежит к их числу):</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">oem-config-remaster — утилита командной строки, позволяющая сделать снапшот установленной системы; </p>
      </li>
      <li>
        <p class="Textbody">remastersys — утилита для резервного копирования установленной системы и создания на её базе Live-носителя; именно таким образом собирается, например, <a href="http://matuntu.ru/" target="_blank">дистрибутив Matuntu</a> — отечественный вариант Ubuntu с MATE в качестве рабочей среды; </p>
      </li>
      <li>
        <p class="Textbody">Ubuntu Builder-- программа с графическим интерфейсом, позволяющая скомпоновать свой дистрибутив попакетно. </p>
      </li>
    </ul>
    <p class="Textbody">Однако первые две показались мне сложноватыми и избыточными для моих целей, а последняя, похоже, прекратила своё развитие — версии её для Ubuntu Trusty, на которой основываются текущие релизы Mint, в PPA-репозитории не обнаружилось.</p>
    <p class="Textbody">И в итоге я остановился на программе Ubuntu Customization Kit (далее — UCK): гугление показало, что это примерно то, что мне нужно, ибо специально предназначается для коррекции состава пакетов в первую очередь.</p>
    <h3 id="toc237"><a id="RefHeading19161713816058"></a><a id="bkmRefHeading19161713816058"></a><a id="toc236"></a><a id="bkmtoc236"></a><a id="RefHeading7141136957987"></a><a id="bkmRefHeading7141136957987"></a><a id="bkmRefHeading7141136957987"></a><a id="bkmbkmRefHeading7141136957987"></a>UCK: обзор</h3>
    <p class="Textbody">Программа UCK в виде одноимённого пакета имеется в официальном репозитории, и потому может быть установлена любым из стандартных способов. После этого в секции Администрирование главного меню Cinnamon появляется пункт, который, как ни странно, называется Ubuntu Customization Kit, через который эту программу и можно запустить. Но прежде чем смотреть, что она после этого делает, попробуем представить, что у неё внутре.</p>
    <p class="Textbody">Всякий, кому приходилось заниматься модификацией существующего установочного образа какого-либо дистрибутива, представляет себе основные этапы этого процесса:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">монтирование образа как loop-устройства; </p>
      </li>
      <li>
        <p class="Textbody">развёртывание её файловой системы — нынче все дистрибутивы используют какой-либо механизм компрессии, в частности в убунтоидах это SquashFS; </p>
      </li>
      <li>
        <p class="Textbody">монтирование в loop-систему как связанных (bind) таких служебных, но абсолютно необходимых каталогов материнской системы, как /dev, /sys и, на всякий случай, /proc; </p>
      </li>
      <li>
        <p class="Textbody">выполнение операции chroot в loop-каталог, становящийся таким образом корневым; </p>
      </li>
      <li>
        <p class="Textbody">выполнение в chroot-окружении необходимых действий по удалению ненужных пакетов и установке необходимых; </p>
      </li>
      <li>
        <p class="Textbody">выход из chroot-окружения и обратная запаковка loop-каталога; </p>
      </li>
      <li>
        <p class="Textbody">размонтирование loop-устройства и создание из него загрузочного iso-образа с помощью isolinux. </p>
      </li>
    </ul>
    <p class="Textbody">Интуитивно понятно, что UCK не делает ничего иного, кроме перечисленного — он просто автоматизирует описанный процесс, делая его этапы почти незаметными для применителя.</p>
    <p class="Textbody">Основные исполняемые файлы пакета uck (а их 16 штук) собраны, понятное дело, в каталоге /usr/bin и имеют префикс uck-*. Все они являются самыми обычными шелл-скриптами, причём по их именам легко догадаться о назначении каждого. «Головным», то есть запускающим весь процесс скриптом является /usr/bin/uck-gui — именно он вызывается через пункт меню Администрирование -&gt; Ubuntu Customization Kit:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_000.png">
        <img alt="Изображение579" class="frameGraphics" id="579graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_000-572x417.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:418.8385px" />
      </a>
      <a id="a581graphic"></a>
      <a id="bkm581graphic"></a>
    </p>
    <p class="Textbody">А через редактор меню можно посмотреть на его свойства:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_000a.png">
        <img alt="Изображение580" class="frameGraphics" id="580graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_000a.png" style="border:1.0px solid #000080;padding:0;width:471.82745px;height:212.85419px" />
      </a>
      <a id="a582graphic"></a>
      <a id="bkm582graphic"></a>
    </p>
    <p class="Textbody">По скриншоту можно догадаться о присутствии в строке запуска опции --wait-before-exit, отвечающей за ожидание нажатия Enter перед выходом из программы после успешного завершения её работы.</p>
    <p class="Textbody">Кстати говоря, при неуспешном завершении, то есть возникновении ошибки по любой причине (например, нехватке места на целевом устройстве), ничего не происходит, кроме остановки работы. Никаких возвратов назад не предусмотрено, остаётся только закрывать главное терминальное окно программы (о котором далее) и начинать всё сначала. Так что, учитывая длительность распаковки SquashFS и необходимость удаления образовавшихся в процессе файлов (а их — многие десятки тысяч, что на файловой системе, например, XFS затягивается очень надолго), лучше действовать аккуратно и по возможности не ошибаться.</p>
    <p class="Textbody">Команда uck-gui запускается от лица обычного пользователя — пароль для доступа к административным привилегиям запрашивается только тогда, когда они на самом деле потребуются. Кроме указанной --wait-before-exit, она имеет ещё как минимум две опции. Первая, -m, обеспечивающая кеширование модифицированных частей образа, работает, как сказано в man (1) uck-gui, не всегда, и потому в стандартной ситуации не используется.</p>
    <p class="Textbody">Вторая опция также штатно не задействована, но она может оказаться важной для применителя. Это опция remaster-dir, определяющая рабочий каталог для UCK, отличный от умолчального ~/tmp. Через редактор меню Cinnamon я переопределил этот каталог как ~/data/my-mint, поэтому итоговая команда для запуска UCK через меню приобрела такой вид:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">uck-gui --wait-before-exit /home/data/my-mint</span> </p>
    <p class="Textbody">Кроме запуска процесса, сценарий uck-gui отвечает, в том числе, и за выбор типа десктопа — unity, gnome, kde, или others. Однако попытки вносить здесь какие-либо изменения (например, пополнение списка доступных десктопов) никакого результата за собой не повлекут. То есть добавленные десктопы появятся в меню их выбора, но ничего не изменится.</p>
    <p class="Textbody">Потому что на самом деле кроме исполняемых скриптов в каталоге /usr/bin, основным компонентом UCK является также каталог /usr/lib/uck/. А в нём, кроме всего прочего — файл /usr/lib/uck/customization-profiles/localized_cd/customize, представляющий собой исполняемый шелл-сценарий, который отвечает в том числе и за вызов терминальной программы. Запомним его — в некоторых случаях он подлежит ручному редактированию.</p>
    <p class="Textbody">Впрочем, всё сказанное проще продемонстрировать на примере конкретной сборки своего варианта дистрибутива, чем мы сейчас и займёмся.</p>
    <h3 id="toc238"><a id="RefHeading19181713816058"></a><a id="bkmRefHeading19181713816058"></a><a id="toc237"></a><a id="bkmtoc237"></a><a id="RefHeading7161136957987"></a><a id="bkmRefHeading7161136957987"></a><a id="bkmRefHeading7161136957987"></a><a id="bkmbkmRefHeading7161136957987"></a>UCK: процесс</h3>
    <p class="Textbody">Сразу после запуска UCK перед нами появляется пустое терминальное окно и на фоне его — приглашение программы:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_001.png">
        <img alt="Изображение581" class="frameGraphics" id="581graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_001-572x346.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:347.85892px" />
      </a>
      <a id="a583graphic"></a>
      <a id="bkm583graphic"></a>
    </p>
    <p class="Textbody">В нём указаны системные требования, не являющие собой ничего сверхъестественного: 5 ГБ свободного пространства в каталоге ~/tmp (или его аналоге, определённом выше) и доступ в Интернет. Так что можно смело нажимать OK и приступать к кастомизации, которая начинается<br />с выбора локали — сначала для инсталлятора:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_002.png">
        <img alt="Изображение582" class="frameGraphics" id="582graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_002.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:401.83054px" />
      </a>
      <a id="a584graphic"></a>
      <a id="bkm584graphic"></a>
    </p>
    <p class="Textbody">Затем — для Live-носителя:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_003.png">
        <img alt="Изображение583" class="frameGraphics" id="583graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_003-572x355.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:356.8542px" />
      </a>
      <a id="a585graphic"></a>
      <a id="bkm585graphic"></a>
    </p>
    <p class="Textbody">И наконец — для и инсталлированной системы:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_004.png">
        <img alt="Изображение584" class="frameGraphics" id="584graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_004.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:401.83054px" />
      </a>
      <a id="a586graphic"></a>
      <a id="bkm586graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_004.png"> </a>
    </p>
    <p class="Textbody">Список всех доступных содержится в файле /usr/lib/uck/langlist. Причём, при желании иметь русифицированную систему, можно ограничиться отметкой боксика ru во всех трёх случаях. Впрочем, в Live-среде локаль всё равно останется en_US (о чём программа честно предупреждает). Однако язык инсталлтора будет русским. А в установленной системе локаль по умолчанию определится как надо:</p>
    <p class="Textbody"><span style="background-color:#dddddd">~ $ locale</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">LANG=ru_RU.UTF-8</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">...</span> </p>
    <p class="Textbody">И к ней автоматически добавятся такие:</p>
    <p class="Textbody"><span style="background-color:#dddddd">~ $ locale -a</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">C</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">C.UTF-8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_AG</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_AG.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_AU.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_BW.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_CA.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_DK.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_GB.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_HK.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_IE.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_IN</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_IN.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_NG</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_NG.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_NZ.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_PH.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_SG.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_US.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_ZA.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_ZM</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_ZM.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">en_ZW.utf8</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">POSIX</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">ru_RU.utf8</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">ru_UA.utf8</span> </p>
    <p class="Textbody">Правда в Mint, в отличие от Ubuntu, ни одна из многочисленных английских локалей не будет всплывать в самый неподходящий момент.</p>
    <p class="Textbody">Следующий шаг кастомизации — выбор рабочей среды:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_005.png">
        <img alt="Изображение585" class="frameGraphics" id="585graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_005-572x372.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:373.82428px" />
      </a>
      <a id="a587graphic"></a>
      <a id="bkm587graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_005.png"> </a>
    </p>
    <p class="Textbody">На самом деле он определяет не среду, а терминальную программу, в которой будет жить chroot-окружение. При выборе первых трёх вариантов её будет соответствующий штатный терминал (Konsole, GNOME Terminal или Xfce Terminal), в случае варианта четвёртого будут просто перебраны они же плюс LXTerminal из LXDE. Соответственно, запустится тот, что найдётся первым, так что выбор пункта other подойдёт в подавляющем большинстве случаев, вне зависимости от десктопа, используемого на потрошимом Live-носителе.</p>
    <p class="Textbody">На самый крайняк предусмотрен запуск XTerm, который, казалось бы, имеется в любом дистрибутиве. Но вот в Mint'е ни в одной официальной редакции его как раз нет. Поэтому при сборке системы с десктопом MATE потребуется редактирование того самого файла /usr/lib/uck/customization-profiles/localized_cd/customize, который я ранее предлагал запомнить. То есть в его секцию function run_console() следует вписать такие строки:</p>
    <p class="Textbody"><span style="background-color:#dddddd">         if [ «$CONSOLE_APP» = «» ]; then</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">                 CONSOLE_APP=`which mate-terminal`</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">                 CONSOLE_APP_OPTIONS=(-t «UCK customization console» -e /bin/bash)</span> </p>
    <p class="Textbody">Я на всякий случай дописал в него также определения для терминальных программ Sakura и Terminator, которые временами использую.</p>
    <p class="Textbody"><span style="background-color:#dddddd">        if [ «$CONSOLE_APP» = «» ]; then</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">                CONSOLE_APP=`which terminator`</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">                CONSOLE_APP_OPTIONS=(-t «UCK customization console» -e /bin/bash)</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        fi</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">        if [ «$CONSOLE_APP» = «» ]; then</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">                CONSOLE_APP=`which sakura`</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">                CONSOLE_APP_OPTIONS=(-t «UCK customization console» -e /bin/bash)</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">        fi</span> </p>
    <p class="Textbody">Теоретически тут можно переопределить и командную оболочку (например, /bin/zsh), но я этим заморачиваться не стал.</p>
    <p class="Textbody">Теперь потребовуется выбрать образ диска, который будет подвергнут потрошению — через обычное окно открытия файла. После чего будущему образу предлагается дать имя:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_006.png">
        <img alt="Изображение586" class="frameGraphics" id="586graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_006.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:138.85101px" />
      </a>
      <a id="a588graphic"></a>
      <a id="bkm588graphic"></a>
    </p>
    <p class="Textbody">Впрочем, имя это, насколько я понял, в дальнейшем нигде не используется, так что особо напрягать свою фантазию не нужно.</p>
    <p class="Textbody">Далее следует серия вопросов — о желании кастомизировать будущий образ мануально:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_007.png">
        <img alt="Изображение587" class="frameGraphics" id="587graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_007.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:401.83054px" />
      </a>
      <a id="a589graphic"></a>
      <a id="bkm589graphic"></a>
    </p>
    <p class="Textbody">Об удалении Windows-related файлов, типа autorun.inf (которых, впрочем, на установочном носителе Mint и так нет):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_008.png">
        <img alt="Изображение588" class="frameGraphics" id="588graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_008.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:401.83054px" />
      </a>
      <a id="a590graphic"></a>
      <a id="bkm590graphic"></a>
    </p>
    <p class="Textbody">О создании гибридного образа — то есть пригодного для записи как на OD, так и на USB:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_009.png">
        <img alt="Изображение589" class="frameGraphics" id="589graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_009.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:401.83054px" />
      </a>
      <a id="a591graphic"></a>
      <a id="bkm591graphic"></a>
    </p>
    <p class="Textbody">На все эти вопросы я, по понятным причинам, отвечал положительно, иначе и говорд городить бы не стоило.</p>
    <p class="Textbody">Далее сообщается, что вся необходимая информация собрана, по введении пароля можно приступать к сборке диска, который будет помещён в path2/remaster-new-files под именем livecd.iso (спрашивается, зачем придумывать ему осмысленное имя?):</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_010.png">
        <img alt="Изображение590" class="frameGraphics" id="590graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_010.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:401.83054px" />
      </a>
      <a id="a592graphic"></a>
      <a id="bkm592graphic"></a>
    </p>
    <p class="Textbody">А для начала процесса в исходном терминальном окне надо ввести пароль для доступа к адмнистративным привилегиям:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_011.png">
        <img alt="Изображение591" class="frameGraphics" id="591graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_011-572x326.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:327.82742px" />
      </a>
      <a id="a593graphic"></a>
      <a id="bkm593graphic"></a>
    </p>
    <p class="Textbody">Вслед за этим происходит монтирование исходного образа, его разворачивание и декомпрессии SquashFS, которая занимает немало времени:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_012.png">
        <img alt="Изображение592" class="frameGraphics" id="592graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_012-572x326.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:327.82742px" />
      </a>
      <a id="a594graphic"></a>
      <a id="bkm594graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_012.png"> </a>
    </p>
    <p class="Textbody">Когда же она закончится, каталог, определённый в качестве remaster-dir, будет выглядеть так:</p>
    <p class="Textbody"><span style="background-color:#dddddd">ls [remaster-dir]</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">build.log</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">customization-scripts/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">remaster-apt-cache/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">remaster-new-files/</span> </p>
    <p class="Textbody"><span style="background-color:#dddddd">remaster-root/</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">remaster-root/home</span> </p>
    <p class="Textbody">Очевидно, что build.log содержит протоколирование хода процесса, а в каталоге customization-scripts/ собраны скрипты кастомизации, сгенерированные посредством сценариев из /usr/lib/uck/. В каталоге remaster-apt-cache/ будет помещён локальный кеш устанавливаемых пакетов, а сами они в подкаталоге remaster-apt-cache/archives — аналоге /var/cache/apt/archives установленной системы. Таким образом, скачанные пакеты не засоряют ни корень развёрнутой из Live-образа системы (он расположен в каталоге remaster-root/), ни, тем более, каталог для сборки уже непосредственно нового образа — remaster-new-files/. В последнем после успешного завершения всего предприятия этот самый образ, под именем livecd.iso, и окажется. Ну а remaster-root/home, ясное дело, является домашним каталогом администратора (аналог /root обычной файловой иерархии).</p>
    <p class="Textbody">Далее предлагается выбрать «заказное» действие — Run console application или Continue building:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_013.png">
        <img alt="Изображение593" class="frameGraphics" id="593graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_013.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:401.83054px" />
      </a>
      <a id="a595graphic"></a>
      <a id="bkm595graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_013.png"> </a>
    </p>
    <p class="Textbody">Выбор первого пункта очевиден. Он влечёт за собой выполнение той самой команды chroot, о которой я говорил раньше, и запуск того самого терминала, который был неявным образом определён на стадии так называемого выбора десктопа:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_014.png">
        <img alt="Изображение594" class="frameGraphics" id="594graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_014-572x357.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:358.85733px" />
      </a>
      <a id="a596graphic"></a>
      <a id="bkm596graphic"></a>
    </p>
    <p class="Textbody">Обращаю внимание — командная оболочка в терминале — Bash, запущенная от лица администратора. То есть в дальнейшем для установки/удаления пакетов и прочих подобных мероприятий команда sudo не понадобится.</p>
    <p class="Textbody">Если предыдущие стадии завершились успешно, то начинается самое важное: собственно потрошение исходного образа. Тут требуется аккуратность и последовательность, нарушение которой влечёт ошибки, которые, как я уже говорил, крайне нежелательны. Так что в следующем миниочерке процедура потрошения будет рассмотрена подробно. А пока завершу описание основного процесса.</p>
    <p class="Textbody">По завершении потрошения опять возникает панель с предложением выбрать «заказное» действие — и теперь столь же очевиден выбор второго из них:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_015.png">
        <img alt="Изображение595" class="frameGraphics" id="595graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_015.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:401.83054px" />
      </a>
      <a id="a597graphic"></a>
      <a id="bkm597graphic"></a>
    </p>
    <p class="Textbody">После чего начнается исполнение сценариев кастомизации, плавно переходящее в компрессию системы в виде SquashFS — это будет самым долгим делом во всём процессе:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_016.png">
        <img alt="Изображение596" class="frameGraphics" id="596graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_016-572x326.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:327.82742px" />
      </a>
      <a id="a598graphic"></a>
      <a id="bkm598graphic"></a>
    </p>
    <p class="Textbody">Однако всё когда-нибудь кончается — и упаковка SquashFS закончится сообщением об успехе операции и напоминанием о том, где и под каким именем можно найти её результат:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_017.png">
        <img alt="Изображение597" class="frameGraphics" id="597graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_017.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:401.83054px" />
      </a>
      <a id="a599graphic"></a>
      <a id="bkm599graphic"></a>
    </p>
    <p class="Textbody">Приняв это к сведению, я узнал, что собранный образ не вместится на стандартный семисотмегабайтный CD:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_018.png">
        <img alt="Изображение598" class="frameGraphics" id="598graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_018.png" style="border:1.0px solid #000080;padding:0;width:501.83685px;height:401.83054px" />
      </a>
      <a id="a600graphic"></a>
      <a id="bkm600graphic"></a>
    </p>
    <p class="Textbody">Что, как выяснилось, соответствовало действительности, о чём скажу в следующем миниочерке. А пока оставалось только нажать OK, что повлекло закрытие окна сборки. А в первом терминале — нажать Enter, в результате закроется и он:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_019.png">
        <img alt="Изображение599" class="frameGraphics" id="599graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_019-572x326.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:327.82742px" />
      </a>
      <a id="a601graphic"></a>
      <a id="bkm601graphic"></a>
    </p>
    <p class="Textbody">А итоговый образ, как уже говорилось, можно найти в каталоге /home/data/my-mint/remaster-new-files под именем livecd.iso.</p>
    <h3 id="toc239"><a id="RefHeading19201713816058"></a><a id="bkmRefHeading19201713816058"></a><a id="toc238"></a><a id="bkmtoc238"></a><a id="RefHeading7181136957987"></a><a id="bkmRefHeading7181136957987"></a><a id="bkmRefHeading7181136957987"></a><a id="bkmbkmRefHeading7181136957987"></a>«Потрошение» образа</h3>
    <p class="Textbody">А теперь я вернусь назад и расскажу о своём опыте «потрошения» исходного образа Cinnamon-редакции Mint. Не как пример для подражания или, тем более, копирования, но как вариант возможных действий. И себе на память — в качестве шпаргалки, тоже пригодится.</p>
    <p class="Textbody">«Потрошению» подвергся образ Cinnamon-редакции Mint 17.1 Rebecca в 64-битном варианте:</p>
    <p class="Textbody">
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_020.png">
        <img alt="Изображение600" class="frameGraphics" id="600graphic" src="http://alv.me/wp-content/img/im_cin_img/10-uck_020-572x537.png" style="border:1.0px solid #000080;padding:0;width:573.83685px;height:538.83844px" />
      </a>
      <a id="a602graphic"></a>
      <a id="bkm602graphic"></a>
      <a href="http://alv.me/wp-content/img/2015/01/10-uck_020.png"> </a>
    </p>
    <p class="Textbody">Для начала я подключил PPA-репозитории, которые предполагал использовать:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># add-apt-repository -y ppa:mystic-mirage/komodo-edit &amp;&amp; add-apt-repository -y  ppa:zfs-native/stable &amp;&amp; add-apt-repository -y ppa:andrew-crew-kuznetsov/crew</span> </p>
    <p class="Textbody">Напоминаю, что командная оболочка запущена от имени администратора, что символизиуется видом приглашения командной строки в виде решётки #.</p>
    <p class="Textbody">Подключение репозиториев можно проделать и с помощью mintsources, запустив его из командной строки. И тут только не следует тянуть с этим делом — после удаления ненужных (мне) программ он может работать с ошибками. Если же прибегнуть к стандартному add-apt-repository, то этой проблемы не возникает, и подключение PPA-репозиториев можно отложить.</p>
    <p class="Textbody">Как обычно, подключение репозиториев надо завершить обновлением кеша пакетов:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># apt update</span> </p>
    <p class="Textbody">И теперь, казалось бы, самое время выполнить общее обновление системы. Однако — увы: у меня оно ни разу не проходило ни через mintupdate, ни через apt upgrade ни в каких вариантах: ни с отключением Менеджера обновлений в хост-системе в первом случае, ни с ручной фиксацией версий пакетов, не обновляемых mintupdate — во втором. Так что попытки эти я оставил, переходя сразу к удалению пакетов, которые полагаю лишними — Libreoffice, GIMP, все мультимедийные, Thunderbird и всякие мелочи, типа Tomboy:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># apt purge tomboy gimp thunderbird libreoffice* banshee brasero totem vlc gimp-data libgimp2.0</span> </p>
    <p class="Textbody">Далее настала очередь шрифтов — удалению подверглись кхмерские, таиландские и прочие шрифты, столь необходимые в наших широтах:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># apt purge fonts-kacst fonts-kacst-one fonts-khmeros-core fonts-lao fonts-lklug-sinhala fonts-nanum fonts-sil-abyssinica fonts-sil-padauk fonts-takao-pgothic fonts-thai-tlwg fonts-tibetan-machine fonts-tlwg-garuda fonts-tlwg-kinnari fonts-tlwg-loma fonts-tlwg-mono fonts-tlwg-purisa fonts-tlwg-sawasdee fonts-tlwg-typewriter fonts-tlwg-typist fonts-tlwg-typo fonts-tlwg-umpush fonts-tlwg-waree ttf-indic-fonts-core ttf-punjabi-fonts</span> </p>
    <p class="Textbody">И напоследок — удаление драйверов видеокарт, последние представители которых были списаны в утиль много лет назад:</p>
    <p class="Textbody"><span style="background-color:#dddddd"># apt purge</span> </p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">xserver-xorg-video-cirrus xserver-xorg-video-mga xserver-xorg-video-neomagic xserver-xorg-video-openchrome xserver-xorg-video-qxl xserver-xorg-video-s3 xserver-xorg-video-savage xserver-xorg-video-siliconmotion xserver-xorg-video-sis xserver-xorg-video-sisusb xserver-xorg-video-tdfx xserver-xorg-video-trident xserver-xorg-video-ati xserver-xorg-video-mach64 xserver-xorg-video-vmware xserver-xorg-video-vmware</span> </p>
    <p class="Textbody">Массовое удаление пакетов по традиции следует завершать командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># apt autoremove</span> </p>
    <p class="Textbody">Она удаляет «осиротелые» зависимости, от которых больше ничего не зависит. Впрочем, в моём случае таковых не оказалось.</p>
    <p class="Textbody">Теперь настало время <span style="text-decoration:line-through">собирать камни</span> устанавливать пакеты. Каковых оказалось не так много:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># apt install zsh gprename hunspell-ru-ie-yo mc mdadm uck shutter komodo-edit komodo-edit-ru gnumeric abiword gnome-mplayer asunder lame flac terminator tilda yagf system-config-lvm f2fs-tools nilfs-tools btrfs-tools ubuntu-zfs google-earth-stable virtualbox-4.3</span> </p>
    <p class="Textbody">Вдаваться в объяснения, почему именно эти пакеты, полагаю здесь неуместным. Ну а порядок их перечисления в строк — абсолютно случайный, и образовался по мере воспоминания.</p>
    <p class="Textbody">Напоследок была установлена новая Opera, предварительно скачанная и помещённая в каталог path2/remaster-root/tmp:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># apt deb path2/remaster-root/tmp</span> </p>
    <p class="Textbody">После установки пакетов остались последние штрихи — обеспечить «нескучные обои» некоторые мелочи. Первая задача была решена лобовым копированием с хост-системы (и в её среде) каталога с моими любимыми фоновыми картинками в каталог path2/remaster-root/usr/share/backgrounds. И созданием (уже в chroot-окружении) символической ссылки:</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd"># ln -s ../linuxmint-alv/Mount_of_the_Rising_Sun.jpg \ default_background.jpg</span> </p>
    <p class="Textbody">Далее, с хост-системы же были перенесены настроечные файлы:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Textbody">мои конфиги для Zsh — ~/.zshrc и ~/.zshenv — в каталог /etc/zsh под именами newuser.zshrc.recommended и zshenv, соответственно; </p>
      </li>
      <li>
        <p class="Textbody">файла customize, описывающего доступные для UNC терминалы — в каталог path2/remaster-root/usr/lib/uck/customization-profiles/localized_cd/ (с тем же именем); </p>
      </li>
      <li>
        <p class="Textbody">файлов словаря для русского спеллинга в Komodo Edit (ru_RU.aff и ru_RU.dic) — в калалог path2/remaster-root/usr/lib/komodo-edit/mozilla/dictionaries. </p>
      </li>
    </ul>
    <p class="Textbody">И теперь оставалось только выйти из chroot-окружения и дождаться окончания сборки нового образа. Объём которого составил 1484 МБ — против 1478 МБ образа исходного. Но я и не ставил своей целью его уменьшение.</p>
    <p class="Textbody">Получившийся образ был скопирован куда надо, получил нормальное имя alv-rebecca.02.iso и контрольную сумму командой</p>
    <p class="Textbody" style="margin-top:0;margin-bottom:17.990553px"><span style="background-color:#dddddd">$ md5sum alv-rebecca.02.iso &gt; alv-rebecca.02.md5</span> </p>
    <p class="Textbody">После этого образ подвергся проверке сначала в Live-режиме, а затем был установлен в виртуальной машине — проверять его на реальном железе мне в данный момент негде. Тем не менее, поскольку все предыдущие опыты такого рода заканчивались успешно, я решил поделиться своим образом с народом — вдруг кому пригодится. Так что скачать его можно с <a href="https://yadi.sk/d/GX2m7lpMeFbYd" target="_blank">Яндекс.Диска</a>.</p>
    <h3 id="toc240"><a id="RefHeading19221713816058"></a><a id="bkmRefHeading19221713816058"></a><a id="toc239"></a><a id="bkmtoc239"></a><a id="RefHeading7201136957987"></a><a id="bkmRefHeading7201136957987"></a><a id="bkmRefHeading7201136957987"></a><a id="bkmbkmRefHeading7201136957987"></a>Заключение</h3>
    <p class="Textbody">В заключение этого очерка скажу пару слов о том, зачем всё это делалось и делается — хотя, возможно, с этого следовало начать. Ибо вопрос этот возникает возникает довольно часто. Правда, я обычно отвечаю на него не вполне политкорректно:</p>
    <p class="Textbody">Если вы не знаете, зачем это — значит, вам это не нужно.</p>
    <p class="Textbody">Но можно попробовать ответить и иначе. Собирал я образы, разумеется, в первую очередь для себя, любимого, дабы иметь возможность устанавливать Mint с его Cinnamon в той комплектации, которая устраивает меня на 146%.</p>
    <p class="Textbody">Во-вторых, с этого образа система будет устанавливаться на машины моих товарищей, не имеющих, по большей части, сложившихся предпочтений по части прикладного софта.</p>
    <p class="Textbody">В-третьих, образ может быть использован для не совсем стандартных инсталляций, например, с подключением softRAID, что штатно его инсталлятором не поддерживается, на файловую систему Ext4 с отключённым журналирование (что до недавнего времени пропагандировалось Google как самое быстрое решение), для подключения существующего пула ZFS или создания нового.</p>
    <p class="Textbody">В четвёртых, просто для экспериментов с дисковыми разделами и файловыми системами, в том числе и с относительно экзотическими, такими, как f2fs или nilfs2.</p>
    <p class="Textbody">И, наконец, в-пятых и последних — этот образ может послужить основой для специализированных сборок под некоторые задачи, например, связанные с цифровой картографией.</p>
    <h2 id="toc241"><a id="RefHeading19241713816058"></a><a id="bkmRefHeading19241713816058"></a><a id="toc240"></a><a id="bkmtoc240"></a><a id="RefHeading22049803676888"></a><a id="bkmRefHeading22049803676888"></a><a id="bkmRefHeading22049803676888"></a><a id="bkmbkmRefHeading22049803676888"></a>Вместо заключения. Порядок действий при настройке</h2>
    <p class="Textbody">Обычно в заключении к книгам, подобных  <a href="http://alv.me/?p=8357">этой</a><a href="http://alv.me/?p=8357"> </a>, принято писать общие слова о достоинствах предмета описания (а заодно и автора оного). Отступлю от этой традиции и довольно конкретно опишу, в каком порядке лучше всего выполнять манипуляции по настройке дистрибутива Mint и среды Cinnamon, опираясь на всё изложенное выше в этих очерках. Разумеется, здесь в конспективном виде приводится мой личный алгоритм действий — как всегда, не в качестве образца для подражания, а как напоминание о необходимости выработки алгоритма собственного. </p>
    <p class="Textbody">Первое, что я делаю после установки почти любого дистрибутива, с почти любой рабочей средой (и Mint с его Cinnamon не исключение) — переименовываю стандартные подкаталоги в своём домашнем каталоге. Если устанавливать систему с русской локалью, по умолчанию список этих подкаталогов будет таким:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ ls -1 ~/</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Видео</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Документы</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Загрузки</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Изображения</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Музыка</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Общедоступные</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Рабочий стол</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Шаблоны</span> </p>
    <p class="Textbody">Что, конечно же, соответствует пресловутому  <a href="http://www.freedesktop.org/wiki/Software/xdg-user-dirs/" target="_blank">стандарту freedesktop.org</a><a href="http://www.freedesktop.org/wiki/Software/xdg-user-dirs/" target="_blank"> </a>. Но, по понятным причинам, крайне не удобно при работе в CLI. Зато легко исправляется такой командой: </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ LANG=C xdg-user-dirs-gtk-update --force</span> </p>
    <div style="text-align:center">
      <img alt="Изображение602" class="frameGraphics" id="602graphic" src="Alexey_Alv_Fedorchuk_Linux_Mint_i_ego_Cinnamon-img/Alexey_Alv_Fedorchuk_Linux_Mint_i_ego_Cinnamon-img1.png" style="width:645.01416px;height:464.01263px" />
    </div>
    <p class="Textbody">Вместо  LANG=C  можно указать  LANG=POSIX  или  LANG=en_US , это одно и то же. И в любом случае за этим последует панель с запросом подтверждения: С ним следует согласиться, предварительно поставив «птицу» в боксике  Don't ask methis again , чтобы в дальнейшем избежать повторения вопроса. После чего список подкаталогов в домашнем каталоге мгновенно приобретёт такой вид: </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ ls -1 ~/</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Desktop/</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Documents/</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Downloads/</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">lost+found/</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Music/</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Pictures/</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Public/</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Templates/</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">Videos/</span> </p>
    <p class="Textbody">Который позвволяет более не задумываться о переключении раскладки клавиатуры во время навигации по файловой системе.</p>
    <p class="Textbody">Следующие мои действия — создание комфортной среды обитания меня, любимого, что начинается с установки любимой оболочки Zsh:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ apt install zsh</span> </p>
    <p class="Textbody">Затем копирование (с внешнего носителя или из сети, например, с Яндекс.диска) моих конфигов для неё в домашний каталог:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ cp path2/{.zshrc,.zshenv} mytmp ~/</span> </p>
    <p class="Textbody" style="font-family:&#39;Helvetica Neue&#39;, Helvetica, sans-serif;font-style:normal;font-variant:normal;font-weight:normal;font-size:17.0px;color:#333333;letter-spacing:1.0px;text-transform:none">И, наконец, превращение Zsh в login shell:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ chsh -s /bin/zsh</span> </p>
    <p class="Textbody">Как я уже гворил, в последнее время без выпадающего терминала я чувствую себя как без рук. И потому следующий шаг — установка оного:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ apt install tilda</span> </p>
    <p class="Textbody">И внесение программы Tilda в список для  Автозапуска  в секции  Параметры   Ситемных настроек  среды Cinnamon. </p>
    <p class="Textbody">Раньше одним из первых моих действий по настройке среды была смена шрифтов интерфейса. Однако с появлением в Mint семейства гарнитур Notos оказалось, что в штатной теме оформления Cinnamon, именуемой Mint-X, меня в общем всё устраивает по умолчанию, а всякими частными украшательствами, типа подбора нескучных обоев и скринсейвером, я занимаюсь на досуге, под настроение.</p>
    <p class="Textbody">А вот что для меня важно в среде обитания — это настройка клавиатуры, в которую для меня входят:</p>
    <ul style="margin-top:0;margin-bottom:0;list-style-type:disc;clear:left">
      <li>
        <p class="Standard">включение привычных хоткеев для переключения между рабочими областями и управления окнами, в том числе их тайлингом;</p>
      </li>
      <li>
        <p class="Standard">установка привычного варианта русской раскладки (Typewriter Legacy);</p>
      </li>
      <li>
        <p class="Standard">выбор подходящих переключателей раскладки, клавиши  Compose  и некоторых других параметров совместимости. </p>
      </li>
    </ul>
    <p class="Textbody">Первоочередность установки языково-зависимых параметров клавиатуры вызвана тем, что обустройство в новой системе я почти всегда сочетаю с описанием этого процесса, которое выполняю на языке родных осин. И — в любимом текстовом редакторе, роль которого последнее время выполняет Komodo Edit, каковой устанавливается в это же время:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ apt install komodo-edit komodo-edit-ru</span> </p>
    <p class="Textbody">И из внешнего источника в каталог  ~/.komodoedit  копируются необходимые конфиги и макросы. В том числе и словарные файлы для проверки русской орфографии, что требует предварительного подключения следующих репозиториев: </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ sudo add-apt-repository -y ppa:mystic-mirage/komodo-edit</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ sudo add-apt-repository -y ppa:andrew-crew-kuznetsov/crew</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ sudo apt update</span> </p>
    <p class="Textbody">Сочиняемые описания обычно нужно иллюстрировать скриншотами. А поскольку штатное средство для этого, имеющееся в Cinnamon, ниже всякой критики, то заодно устанавливается и соответствующий инструмент:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ apt install shutter</span> </p>
    <p class="Textbody">Все эти вопросы были подробно рассмотрены в соответствующих очерках, и здесь я вдаваться в детализацию не буду.</p>
    <p class="Textbody">Создав таким образом подходящую среду как для дальнейших действий, так и для их описания, можно заняться разборками с файловыми системами и системами размещения данных — в моём домашнем каталоге хранятся только файлв настроек приложений, рабочие данные я размещаю вне его.</p>
    <p class="Textbody">Тут первое, что можно (если нужно) сделать — это отключить журналирование для файловой системы ext4, на которой у меня располагаются корень файловой иерархии и его ветвь  ~/  (то есть, точнее,  /home/alv ). Делается это такими командами: </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ sudo tune2fs -O ^has_journal /dev/sda1</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ sudo tune2fs -O ^has_journal /dev/sda2</span> </p>
    <p class="Textbody">А успех операции проверяется командой</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ sudo tune2fs -l /dev/sda# | grep journal</span> </p>
    <p class="Textbody">которая должна просто вернуть приглашение командной строки.</p>
    <p class="Textbody">Вопрос о том, нужно ли отключать журналирование для ext4, я здесь обсуждать не буду — ответ на него каждый должен дать себе сам.</p>
    <p class="Textbody">Далее возможны варианты в зависимости от того, что предполагается использовать для хранения данных — LVM, softRAID или ZFS. Первый случай ни к каким подготовительным действиям не обязывает — к созданию физических томов и их групп, а также логических групп и томов поверх них можно приступать сразу, с помощью соответствующих консольных утилит. Однако, если есть желание воспользоваться интегрирующей их графической оболочкой, сооветствующий пакет надо установить:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ apt install system-config-lvm</span> </p>
    <p class="Textbody">Если для размещения данных был выбран softRAID, то пакет для работы с ним должен быть установлен в обязательном порядке, в стандартной установке Mint таковой отсутствует:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ apt install mdadm</span> </p>
    <p class="Textbody">Больше всего телодвижений потребует использование ZFS. И тут проще всего начать с получения «бессрочных» административных прав:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd">$ sudo -i</span> </p>
    <p class="Textbody">После чего подключить нужный репозиторий и обновить кеш:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd"># add-apt-repository ppa:zfs-native/stable</span> </p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd"># apt update</span> </p>
    <p class="Textbody">Затем построить дерево зависимостей:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd"># apt build-dep ubuntu-zfs</span> </p>
    <p class="Textbody">Далее — собрать пакеты поддержки:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd"># apt install ubuntu-zfs</span> </p>
    <p class="Textbody">И, наконец, загрузив модули, необходимые для работы ZFS:</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd"># modprobe zfs</span> </p>
    <p class="Textbody">проверить результат командой</p>
    <p class="Textbody" style="font-family:Courier, monospace;font-style:normal;font-variant:normal;font-weight:normal;color:#222222;letter-spacing:1.0px;text-transform:none"><span style="background-color:#dddddd"># lsmod | grep zfs</span> </p>
    <p class="Textbody">Теперь наступает этап массового удаления ненужных пакетов и установки нужных. Останавливаться на нём я не буду — во-первых, это дело индивидуальных вкусов, а во-вторых, последнее время я устанавливаю Mint с самосборных образов, изготовленных посрджеством UCK, как было описано в последнем очерке. В этих образах ничего ненужного уже нет, а (почти) всё нужное присутствует.</p>
    <p class="Textbody" style="font-family:&#39;Helvetica Neue&#39;, Helvetica, sans-serif;font-style:normal;font-variant:normal;font-weight:normal;font-size:17.0px;color:#333333;letter-spacing:1.0px;text-transform:none">Так что — за работу, товарищи!</p>
    <h2 id="toc242"><a id="RefHeading19261713816058"></a><a id="bkmRefHeading19261713816058"></a><a id="toc241"></a><a id="bkmtoc241"></a><a id="RefHeading13141136957987"></a><a id="bkmRefHeading13141136957987"></a><a id="bkmRefHeading13141136957987"></a><a id="bkmbkmRefHeading13141136957987"></a>Приложение. Перечень ресурсов</h2>
    <p class="Textbody">Эта книга была бы неполной без Перечня ресурсов, связанных с Mint и Cinnamon. Я не ставил себе целью собрать все сайты и блоги, в которых упоминаются этот дистрибутив и эта среда, даже русскоязычные. И потому, возможно, в моём Перечне ресурсов есть зияющие прорехи.</p>
    <p class="Textbody">С другой стороны, все дистрибутивы семейства Ubuntu (а Mint в широком смысле слова принадлежит к этому клану) связаны друг с другом настолько тесно, что заставляют вспомнить, что говорили по этому поводу резонные люди из Одессы. Так что в Перечень попали некоторые ресурсы, имеющие к Mint и Cinnamon косвенное отношение. По иронии судьбы, это как раз самые интересные ресурсы из в русскоязычных ресурсов.</p>
    <p class="Textbody">И ещё дисклаймер: делался этот Перечень в первую очередь для себя, любимого — на предмет упрощения работы над книгой. Так что несёт на себе отчётливый след вкусовщины, дедовщины и прочего субьективизма.</p>
    <h3 id="toc243"><a id="RefHeading19281713816058"></a><a id="bkmRefHeading19281713816058"></a><a id="toc242"></a><a id="bkmtoc242"></a><a id="RefHeading7221136957987"></a><a id="bkmRefHeading7221136957987"></a><a id="bkmRefHeading7221136957987"></a><a id="bkmbkmRefHeading7221136957987"></a>Англоязычные ресурсы</h3>
    <p class="Textbody">Англоязычные ресурсы начинаются, разумеется, с <a href="http://forums.linuxmint.com/viewforum.php?f=75" target="_blank">официального сайта Linux Mint</a>, и тесно связанных с ним <a href="http://blog.linuxmint.com/" target="_blank">Linux Mint Blog</a>'а (новости о дистрибутиве вообще), <a href="http://segfault.linuxmint.com/" target="_blank">сайта Segfault</a> (новости разработки) и <a href="http://forums.linuxmint.com/" target="_blank">официального форума</a>. На последнем имеется <a href="http://forums.linuxmint.com/viewforum.php?f=75" target="_blank">русскоязычный раздел</a>.</p>
    <p class="Textbody">Здесь же, рядом, имеется <a href="http://cinnamon.linuxmint.com/" target="_blank">официальная страничка Cinnamon</a>, но похоже, что сама по себе она прекратила своё развитие, все новости относительно этой среды — на Mint Blog'е и Segfault'е. Однако разделы с <a href="http://cinnamon-spices.linuxmint.com/themes" target="_blank">темами</a>, <a href="http://cinnamon-spices.linuxmint.com/applets" target="_blank">апплетами</a>, <a href="http://cinnamon-spices.linuxmint.com/desklets" target="_blank">десклетами</a> и <a href="http://cinnamon-spices.linuxmint.com/extensions" target="_blank">расширениями</a> исправно пополняются.</p>
    <p class="Textbody">Установочные образы всех поддерживаемых версий — по ссылкам <a href="http://www.linuxmint.com/download_all.php" target="_blank">отсюда</a>. В наших палестинах, возможно, имеет смысл обратиться к <a href="http://mirror.yandex.ru/linuxmint/" target="_blank">зеркалу Яндекса</a>.</p>
    <p class="Textbody">Официальные репозитории — <a href="http://packages.linuxmint.com/" target="_blank">основной</a> (с многочисленными зеркалами на каждом километре, здесь и по всему свету, за исключением России) и <a href="http://packages.linuxmint.com/" target="_blank">extra</a> (кажется, без зеркал вообще).</p>
    <p class="Textbody">Источники дополнительных пакетов — всё тот же бездонный <a href="https://launchpad.net/" target="_blank">Launchpad</a> и несколько более мелководный <a href="http://www.getdeb.net/" target="_blank">GetDeb</a>.</p>
    <p class="Textbody"><a href="https://github.com/linuxmint/" target="_blank">Linux Mint на Github</a>'е — исходники Cinnamon и всех дистрибутив-специфических компонентов. Отсюда можно забрать и исходники Cinnamon <a href="https://github.com/linuxmint/Cinnamon/tags" target="_blank">одним архивом</a>.</p>
    <p class="Textbody">Всякого рода красивости (темы, обои, пиктограммки) в большом количестве можно найти на <a href="http://linuxmint-art.org/" target="_blank">LinuxMint-Art</a>. И в ещё большем — на <a href="http://www.noobslab.com/" target="_blank">NoobsLab</a>.</p>
    <h3 id="toc244"><a id="RefHeading19301713816058"></a><a id="bkmRefHeading19301713816058"></a><a id="toc243"></a><a id="bkmtoc243"></a><a id="RefHeading7241136957987"></a><a id="bkmRefHeading7241136957987"></a><a id="bkmRefHeading7241136957987"></a><a id="bkmbkmRefHeading7241136957987"></a>Русскоязычные ресурсы</h3>
    <p class="Textbody">О существовании <a href="http://forums.linuxmint.com/viewforum.php?f=75" target="_blank">русскоязычного раздела</a> на официальном форуме проекта я уже упоминал. Однако самые интересные форумы, как я уже говорил, имеют к Mint довольно косвенное отношение.</p>
    <p class="Textbody">Первый в этом ряду — <a href="http://rosinka.rosix.ru/index.php" target="_blank">форум Росинка</a>. Некогда он образовался для поддержки одноимённого проекта — отечественной сборки Linux Mint. Сам проект то ли заморожен, то ли прекратил развитие (последняя активность датируется октябрём 2013, когда вышла альфа-версия сборки на основе Mint 15, в свою очередь датированной маем того же года). Но форум его живёт — на нём обсуждаются вопросы, связанные с дистрибутивами семейства Mint, Ubuntu и соплеменными.</p>
    <p class="Textbody">Второй — <a href="http://matuntu.ru/index.php" target="_blank">форум Matuntu</a>. Он образовался совсем недавно, летом 2014 года, однако связанный с ним проект — отечественная сборка Ubuntu с рабочей средой MATE — возник ещё в те времена, когда об официальной поддержке этого десктопа в этом дистрибутиве никто и не заикался. Ныне же и проект, и форум активно развиваются. Причём на форуме обсуждается не только титульный дистрибутив, но весь спектр родственных систем, включая и Mint с Cinnamon.</p>
    <p class="Textbody">Впрочем, существует и русскоязычный сайт и форум, носящий имя титульного дистрибутива. И не просто русскоязычный, а даже с русским доменным именем — <a href="" target="_blank">Линукс Минт</a>. Имеется сайт, также с форумом, с более традиционным именем — <a href="http://mintlinux.ru/" target="_blank">Официальное русскоязычное сообщество Linux Mint</a>.</p>
    <p class="Textbody">От коллективного творчества переходим к индивидуальному. Первое, что здесь имеет самое непосредственное отношение к Mint и Cinnamon — это <a href="http://mintmem.com/" target="_blank">сайт MintMem</a>, который ведёт Валерий Желябовский aka Brego. Где, кроме того, можно найти материалы по замечательному текстовому редактору Komodo Edit.</p>
    <p class="Textbody">Следующий ресурс, носящий название <a href="http://vasilisc.com/" target="_blank">Авторские статьи об Open Source</a> — также результат индивидуального творчества, и принадлежит Василию Алексеенко aka vasilisc. Правда, основная его тематика — Ubuntu и сородичи. Но, как я уже говорил, подчас очень трудно сказать, где кончается Ubuntu и начинается Mint.</p>
    <p class="Textbody">На этом я пока поставлю… надеюсь, что не точку, а всего лишь запятую. В расчёте на то, что Рунет будет прирастать ресурсами по Mint и Cinnamon. Но, поскольку книга рассчитана в том числе и на совсем начинающих применителей, завершу это приложение небольшим списком русскоязычных ресурсов общего характера.</p>
    <h3 id="toc245"><a id="RefHeading19321713816058"></a><a id="bkmRefHeading19321713816058"></a><a id="toc244"></a><a id="bkmtoc244"></a><a id="RefHeading7261136957987"></a><a id="bkmRefHeading7261136957987"></a><a id="bkmRefHeading7261136957987"></a><a id="bkmbkmRefHeading7261136957987"></a>Ресурсы по Linux и UNIX вообще</h3>
    <p class="Textbody">Здесь в первую очередь следует назвать <a href="http://rus-linux.net/" target="_blank">Linux по-русски</a> — сайт Виктора Костромина, который он ведёт с 1999 года. И который, с одной стороны, является самым полным каталогом ссылок на русскоязычные ресурсы по нашей теме, а сдругой стороны, содержит большое количество авторских материалов, оригинальных и переводных.</p>
    <p class="Textbody">Ориентироваться в океане свободного софта помогут ресурсы <a href="http://linsoft.info/" target="_blank">Linsoft</a> и <a href="http://zenway.ru/" target="_blank">Zen Way</a> — структурированные и аннотированные каталоги программ для Linux сотоварищи. А отыскать интересующий пакет в сборке под конкретный дистрибутив можно на <a href="http://pkgs.org/" target="_blank">Linux Packages Search</a>.</p>
    <p class="Textbody">Новостных Linux-и FOSS-ресурсов — бессчётное множество, наверное, больше, чем по настоящему интересных новостей по этой теме. Поэтому выбор их для того, чтобы быть в курсе событий — дело сугубо субъективное. Для меня он определился давно: <a href="http://opennet.ru/" target="_blank">Opennet</a> — один из старейших порталов Рунета, который ведёт Максим Чирков, и <a href="http://www.nixp.ru/" target="_blank">Nixp</a> — новостной сайт с элементами социальной сети, организованный Дмитрием Шуруповым.</p>
    <p class="Textbody">Общие вопросы, связанные Linux и FOSS, обсуждаются на многих форумах, но среди них я поставил бы на первое место <a href="http://unixforum.org/" target="_blank">Unixforum.org</a>, существующий уже более 10 лет. Кроме того, рассматриваемая тематика часто обсуждается в социальной сети <a href="http://juick.com/" target="_blank">Juick</a> — здесь можно также быстро, часто в реальном времени, получить ответы на не вполне тривиальные вопросы.</p>
    <p class="Textbody">И, наконец, тематике Linux и FOSS целиком посвящён «бумажный» журнал <a href="http://www.linuxformat.ru/" target="_blank">Linuxformat</a>, материалы которого со временем становятся свободно доступными в онлайне в виде <a href="http://www.linuxformat.ru/archive" target="_blank">PDF-версии</a> и <a href="http://wiki.linuxformat.ru/" target="_blank">WiKi</a>. Впрочем, и <a href="http://www.linuxformat.ru/subscribe" target="_blank">подписку на него</a> тоже ещё никто не запретил.</p>
    <div id="a1region">
      <div id="1">
        <p class="ContentsHeading">Оглавление</p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc0">Аннотация </a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc1">Об этой книге</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc2">Введение в Linux Mint</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc3">Лирическое вступление</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc4">Что такое Mint</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc5">Немного истории</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc6">Возвращаясь к современности</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc7">Введение в Cinnamon</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc8">История</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc9">Особенности</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc10">Распространение</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc11">Поддержка</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc12">Linux Mint: установка</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc13">Mint и Cinnamon: обзор среды</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc14">Cinnamon. Общий вид</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc15">Управляющая панель</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc16">Главное меню</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc17">Вызов приложений</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc18">Управление окнами</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc19">Тайлинг окон</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc20">Управление тайлингом</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc21">Тайлинг на практике</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc22">Интерфейс Cinnamon: краткий итог</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc23">Cinnamon и системные настройки</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc24">Системные настройки: вступление</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc25">Секция Оформление</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc26">Cinnamon и собственные темы</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc27">Секция Параметры</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc28">Автозапуск</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc29">Апплеты, десклеты и расширения</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc30">Панель и рабочий стол</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc31">Окна и их тайлинг</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc32">Рабочие области и Горячие углы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc33">Конфиденциальность, Общие, Уведомления</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc34">Детали учётной записи</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc35">Прочие параметры</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc36">Секция Оборудование</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc37">О системе и дисплее</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc38">Клавиатура</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc39">Раскладки и переключатели</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc40">Мышь и сенсорная панель</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc41">Звук</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc42">Принтеры и цвет</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc43">Секция Администрирование</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc44">Окно входа в систему</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc45">Пользователи и группы</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc46">Mint: фирменный инструментарий</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc47">Вступление</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc48">Менеджер программ mintinstall</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc49">Интермедия об аккаунте в сообществе</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc50">Менеджер репозиториев software-sources</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc51">Менеджер обновлений mintupdate</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc52">Средства визуализация пакетов</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc53">Средство резервного копирования mintbackup</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc54">Программа записи USB mintstick</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc55">Языковые настройки — mintlocale</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc56">Менеджер драйверов и интегрированное видео AMD</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc57">Прочие настройки</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc58">Редактор dconf</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc59">Mint и консоль</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc60">GRUB2: восстановление загрузчика</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc61">Основы командного интерфейса</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc62">Введение в CLI</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc63">Командная строка</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc64">Автодополнение</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc65">Опции</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc66">Пример: опции команды ls</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc67">Аргументы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc68">Пути к файлам</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc69">Кое-что об исключениях</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc70">Псевдонимы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc71">Переменные</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc72">Навигация и редактирование</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc73">Управляющие последовательности</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc74">История команд</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc75">Поиск в истории</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc76">Регулярные выражения</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc77">Экранирование</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc78">О кавычках</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc79">Вводные слова о командных конструкциях</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc80">Совместное выполнение команд</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc81">Перенаправление</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc82">Конвейеры</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc83">Понятие о фильтрах</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc84">Сценарии оболочки</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc85">Понятие о функциях</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc86">Настройка шелла</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc87">Утилиты CLI</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc88">Самая главная команда</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc89">Команда sudo</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc90">Создание файлов и каталогов</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc91">Аттрибуция файлов</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc92">Навигация по файловой системе</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc93">Информация о файлах</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc94">Манипулирование файлами</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc95">Архивация…</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc96">… и компрессия</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc97">Утилита find и xargs при ней</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc98">Команды обработки текстов: введение</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc99">Просмотр файлов</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc100">Сравнение, объединение и деление файлов</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc101">Поиск в файлах: grep сотоварищи</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc102">Поиск в файлах: утилита search</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc103">Sed: средство потокового редактирования</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc104">Текстовый редактор nano</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc105">Mint и Zsh</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc106">Zsh как login shell</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc107">Документация</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc108">Настройка приглашения</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc109">Темы приглашений</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc110">Приёмы навигации</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc111">Автодополнение</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc112">История команд</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc113">Рекурсивный поиск</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc114">Перенаправление расширенное и множественное</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc115">Просто псевдонимы и псевдонимы глобальные</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc116">Псевдонимы-суффиксы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc117">Конфигурирование</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc118">Пакеты и репозитории</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc119">Пакеты, зависимости, библиотеки</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc120">Формат пакетов</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc121">Репозитории: введение</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc122">Устройство репозиториев Ubuntu</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc123">Особенности репозитория Mint</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc124">О PPA-репозиториях</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc125">Подключение PPA-репозиториев</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc126">Управление пакетами</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc127">Терминологическое введение</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc128">Средства для работы с пакетами. Обзор</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc129">Установщик пакетов dpkg</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc130">Установщик пакетов GDebi</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc131">Утилита apt. Реализация для Linux Mint</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc132">Введение</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc133">Общее описание</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc134">Применение</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc135">Информация о пакетах</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc136">Работа с бинарными пакетами</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc137">Обновление системы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc138">Работа с пакетами исходных текстов</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc139">Итог</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc140">Примечание: кратко об apt из APT</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc141">Управление пакетами: Synaptic</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc142">Введение</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc143">Обзор</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc144">Настройка</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc145">Удаление пакетов: нетрадиционный метод</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc146">Пользовательские приложения</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc147">Файловый менеджер Nemo</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc148">Обзор возможностей</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc149">Nemo и его терминал</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc150">Некоторые расширения Nemo</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc151">Nemo и Dropbox</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc152">Nemo и Яндекс.Диск</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc153">Программы эмуляции терминала</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc154">GNOME Terminal</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc155">Terminator</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc156">Выпадающий терминал Tilda</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc157">Текстовые редакторы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc158">Введение</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc159">Текстовый редактор Gedit</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc160">Альтернативные редакторы: введение</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc161">Текстовый редактор Geany</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc162">Вступление</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc163">Файл</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc164">Правка</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc165">Поиск</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc166">Вид</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc167">Документ</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc168">Проект</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc169">Сборка</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc170">Инструменты</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc171">Справка</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc172">Инструментальная панель</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc173">Поле редактирования, боковая панель и окно сообщений</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc174">Настройка</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc175">Geany и его плагины</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc176">Geany и его макросы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc177">Geany и multiterm</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc178">Geany и управление файлами</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc179">Geany: управление проектами</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc180">Текстовый редактор Komodo Edit</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc181">Обзор</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc182">Русификация</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc183">Управление проектами</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc184">Макросы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc185">Настройки</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc186">Вывод графики</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc187">И последнее о Komodo Edit</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc188">Заключение по редакторам</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc189">Графика</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc190">Средства сканирования: Simple Scan</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc191">Создание экранных снимков</a>
        </p>
        <p class="Contents4">
          <span class="SectionNumber"></span>
          <a href="#toc192">Вступление</a>
        </p>
        <p class="Contents4">
          <span class="SectionNumber"></span>
          <a href="#toc193">GNOME Screenshot</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc194">Shutter</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc195">Вьюверы изображений</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc196">Офисные приложения</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc197">Вступление</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc198">Abiword</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc199">Gnumeric</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc200">Мультимедиа</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc201">Медиа-потребительство</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc202">Оцифровка аудио-компактов</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc203">softRAID, LVM, ZFS</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc204">Общее введение</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc205">Инструменты дисковой разметки и форматирования</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc206">Виды дисковой разметки</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc207">CLI: инструменты разметки</a>
        </p>
        <p class="Contents4">
          <span class="SectionNumber"></span>
          <a href="#toc208">Утилита fdisk</a>
        </p>
        <p class="Contents4">
          <span class="SectionNumber"></span>
          <a href="#toc209">Утилита cfdisk</a>
        </p>
        <p class="Contents4">
          <span class="SectionNumber"></span>
          <a href="#toc210">Утилиты форматирования</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc211">Про графические морды и особенно про GNOME Disks</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc212">Mint и softRAID</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc213">Mint и LVM</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc214">Mint и ZFS</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc215">Общее введение</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc216">Дисковая разметка</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc217">Файловые системы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc218">Из истории систем размещёния</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc219">Начало истории ZFS</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc220">Из истории юриспруденции</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc221">Появление героини</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc222">Обзор возможностей</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc223">Аппаратные потребности</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc224">Терминология</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc225">Модели именования устройств</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc226">Включение поддержки ZFS в Mint</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc227">Создаём простой пул</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc228">«Избыточные» пулы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc229">Пул кэшируемый</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc230">О некоторых опциях команды zpool</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc231">Создание файловых систем</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc232">Файловые системы: устанавливаем свойства</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc233">Перемонтирование</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc234">Подключение пула ZFS, созданного в другой системе</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc235">Индивидуализация системы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc236">Свой Mint: введение</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc237">UCK: обзор</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc238">UCK: процесс</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc239">«Потрошение» образа</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc240">Заключение</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc241">Вместо заключения. Порядок действий при настройке</a>
        </p>
        <p class="Contents2">
          <span class="SectionNumber"></span>
          <a href="#toc242">Приложение. Перечень ресурсов</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc243">Англоязычные ресурсы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc244">Русскоязычные ресурсы</a>
        </p>
        <p class="Contents3">
          <span class="SectionNumber"></span>
          <a href="#toc245">Ресурсы по Linux и UNIX вообще</a>
        </p>
      </div>
      <p class="Textbody"> </p>
    </div>
    <p class="Textbody"> </p>
  </body>
</html>
